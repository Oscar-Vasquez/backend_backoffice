
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model activities
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type activities = $Result.DefaultSelection<Prisma.$activitiesPayload>
/**
 * Model branches
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type branches = $Result.DefaultSelection<Prisma.$branchesPayload>
/**
 * Model categories
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model companies
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model email_campaigns
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type email_campaigns = $Result.DefaultSelection<Prisma.$email_campaignsPayload>
/**
 * Model email_templates
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type email_templates = $Result.DefaultSelection<Prisma.$email_templatesPayload>
/**
 * Model gift_cards
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type gift_cards = $Result.DefaultSelection<Prisma.$gift_cardsPayload>
/**
 * Model invoice_items
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type invoice_items = $Result.DefaultSelection<Prisma.$invoice_itemsPayload>
/**
 * Model invoice_packages
 * 
 */
export type invoice_packages = $Result.DefaultSelection<Prisma.$invoice_packagesPayload>
/**
 * Model invoices
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type invoices = $Result.DefaultSelection<Prisma.$invoicesPayload>
/**
 * Model notification_preferences
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type notification_preferences = $Result.DefaultSelection<Prisma.$notification_preferencesPayload>
/**
 * Model notification_users
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type notification_users = $Result.DefaultSelection<Prisma.$notification_usersPayload>
/**
 * Model notifications_operator
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type notifications_operator = $Result.DefaultSelection<Prisma.$notifications_operatorPayload>
/**
 * Model operator_types
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type operator_types = $Result.DefaultSelection<Prisma.$operator_typesPayload>
/**
 * Model operators
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type operators = $Result.DefaultSelection<Prisma.$operatorsPayload>
/**
 * Model packages
 * 
 */
export type packages = $Result.DefaultSelection<Prisma.$packagesPayload>
/**
 * Model payment_types
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type payment_types = $Result.DefaultSelection<Prisma.$payment_typesPayload>
/**
 * Model payments
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model plan_addresses
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type plan_addresses = $Result.DefaultSelection<Prisma.$plan_addressesPayload>
/**
 * Model plan_features
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type plan_features = $Result.DefaultSelection<Prisma.$plan_featuresPayload>
/**
 * Model plans
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type plans = $Result.DefaultSelection<Prisma.$plansPayload>
/**
 * Model products
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model type_users
 * 
 */
export type type_users = $Result.DefaultSelection<Prisma.$type_usersPayload>
/**
 * Model users
 * This model has constraints using non-default deferring rules and requires additional setup for migrations. Visit https://pris.ly/d/constraint-deferring for more info.
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model vehicles
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type vehicles = $Result.DefaultSelection<Prisma.$vehiclesPayload>
/**
 * Model wallets
 * 
 */
export type wallets = $Result.DefaultSelection<Prisma.$walletsPayload>
/**
 * Model saved_cards
 * 
 */
export type saved_cards = $Result.DefaultSelection<Prisma.$saved_cardsPayload>
/**
 * Model payment_methods
 * 
 */
export type payment_methods = $Result.DefaultSelection<Prisma.$payment_methodsPayload>
/**
 * Model transaction_categories
 * 
 */
export type transaction_categories = $Result.DefaultSelection<Prisma.$transaction_categoriesPayload>
/**
 * Model transactions
 * 
 */
export type transactions = $Result.DefaultSelection<Prisma.$transactionsPayload>
/**
 * Model transaction_types
 * 
 */
export type transaction_types = $Result.DefaultSelection<Prisma.$transaction_typesPayload>
/**
 * Model referral_sources
 * 
 */
export type referral_sources = $Result.DefaultSelection<Prisma.$referral_sourcesPayload>
/**
 * Model cash_closures
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type cash_closures = $Result.DefaultSelection<Prisma.$cash_closuresPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const activity_status_enum: {
  pending: 'pending',
  completed: 'completed',
  failed: 'failed',
  cancelled: 'cancelled'
};

export type activity_status_enum = (typeof activity_status_enum)[keyof typeof activity_status_enum]


export const activity_type_enum: {
  login: 'login',
  logout: 'logout',
  create: 'create',
  update: 'update',
  delete: 'delete',
  view: 'view'
};

export type activity_type_enum = (typeof activity_type_enum)[keyof typeof activity_type_enum]


export const invoice_status_enum: {
  draft: 'draft',
  sent: 'sent',
  paid: 'paid',
  partial: 'partial',
  overdue: 'overdue',
  cancelled: 'cancelled'
};

export type invoice_status_enum = (typeof invoice_status_enum)[keyof typeof invoice_status_enum]


export const invoice_type_enum: {
  marketplace: 'marketplace',
  package: 'package',
  other: 'other'
};

export type invoice_type_enum = (typeof invoice_type_enum)[keyof typeof invoice_type_enum]


export const operator_role_enum: {
  admin: 'admin',
  manager: 'manager',
  staff: 'staff',
  guest: 'guest',
  Contador: 'Contador',
  gerente_de_sucursal: 'gerente_de_sucursal',
  programador: 'programador'
};

export type operator_role_enum = (typeof operator_role_enum)[keyof typeof operator_role_enum]


export const operator_status_enum: {
  active: 'active',
  inactive: 'inactive',
  suspended: 'suspended',
  pending: 'pending'
};

export type operator_status_enum = (typeof operator_status_enum)[keyof typeof operator_status_enum]


export const package_status_enum: {
  pending: 'pending',
  in_transit: 'in_transit',
  delivered: 'delivered',
  returned: 'returned',
  lost: 'lost',
  canceled: 'canceled'
};

export type package_status_enum = (typeof package_status_enum)[keyof typeof package_status_enum]


export const payment_method_enum: {
  cash: 'cash',
  credit_card: 'credit_card',
  debit_card: 'debit_card',
  bank_transfer: 'bank_transfer',
  paypal: 'paypal',
  crypto: 'crypto',
  gift_card: 'gift_card',
  store_credit: 'store_credit'
};

export type payment_method_enum = (typeof payment_method_enum)[keyof typeof payment_method_enum]


export const payment_status_enum: {
  pending: 'pending',
  completed: 'completed',
  failed: 'failed',
  refunded: 'refunded',
  partially_refunded: 'partially_refunded',
  chargeback: 'chargeback'
};

export type payment_status_enum = (typeof payment_status_enum)[keyof typeof payment_status_enum]


export const priority_enum: {
  low: 'low',
  medium: 'medium',
  high: 'high',
  critical: 'critical'
};

export type priority_enum = (typeof priority_enum)[keyof typeof priority_enum]


export const product_status_enum: {
  active: 'active',
  inactive: 'inactive',
  out_of_stock: 'out_of_stock',
  discontinued: 'discontinued',
  coming_soon: 'coming_soon'
};

export type product_status_enum = (typeof product_status_enum)[keyof typeof product_status_enum]


export const shipping_status_enum: {
  pending: 'pending',
  processing: 'processing',
  shipped: 'shipped',
  delivered: 'delivered',
  returned: 'returned',
  cancelled: 'cancelled'
};

export type shipping_status_enum = (typeof shipping_status_enum)[keyof typeof shipping_status_enum]

}

export type activity_status_enum = $Enums.activity_status_enum

export const activity_status_enum: typeof $Enums.activity_status_enum

export type activity_type_enum = $Enums.activity_type_enum

export const activity_type_enum: typeof $Enums.activity_type_enum

export type invoice_status_enum = $Enums.invoice_status_enum

export const invoice_status_enum: typeof $Enums.invoice_status_enum

export type invoice_type_enum = $Enums.invoice_type_enum

export const invoice_type_enum: typeof $Enums.invoice_type_enum

export type operator_role_enum = $Enums.operator_role_enum

export const operator_role_enum: typeof $Enums.operator_role_enum

export type operator_status_enum = $Enums.operator_status_enum

export const operator_status_enum: typeof $Enums.operator_status_enum

export type package_status_enum = $Enums.package_status_enum

export const package_status_enum: typeof $Enums.package_status_enum

export type payment_method_enum = $Enums.payment_method_enum

export const payment_method_enum: typeof $Enums.payment_method_enum

export type payment_status_enum = $Enums.payment_status_enum

export const payment_status_enum: typeof $Enums.payment_status_enum

export type priority_enum = $Enums.priority_enum

export const priority_enum: typeof $Enums.priority_enum

export type product_status_enum = $Enums.product_status_enum

export const product_status_enum: typeof $Enums.product_status_enum

export type shipping_status_enum = $Enums.shipping_status_enum

export const shipping_status_enum: typeof $Enums.shipping_status_enum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activities
 * const activities = await prisma.activities.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activities
   * const activities = await prisma.activities.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.activities`: Exposes CRUD operations for the **activities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activities.findMany()
    * ```
    */
  get activities(): Prisma.activitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branches`: Exposes CRUD operations for the **branches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branches.findMany()
    * ```
    */
  get branches(): Prisma.branchesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email_campaigns`: Exposes CRUD operations for the **email_campaigns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_campaigns
    * const email_campaigns = await prisma.email_campaigns.findMany()
    * ```
    */
  get email_campaigns(): Prisma.email_campaignsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email_templates`: Exposes CRUD operations for the **email_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_templates
    * const email_templates = await prisma.email_templates.findMany()
    * ```
    */
  get email_templates(): Prisma.email_templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gift_cards`: Exposes CRUD operations for the **gift_cards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gift_cards
    * const gift_cards = await prisma.gift_cards.findMany()
    * ```
    */
  get gift_cards(): Prisma.gift_cardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice_items`: Exposes CRUD operations for the **invoice_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoice_items
    * const invoice_items = await prisma.invoice_items.findMany()
    * ```
    */
  get invoice_items(): Prisma.invoice_itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice_packages`: Exposes CRUD operations for the **invoice_packages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoice_packages
    * const invoice_packages = await prisma.invoice_packages.findMany()
    * ```
    */
  get invoice_packages(): Prisma.invoice_packagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoices`: Exposes CRUD operations for the **invoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoices.findMany()
    * ```
    */
  get invoices(): Prisma.invoicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification_preferences`: Exposes CRUD operations for the **notification_preferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_preferences
    * const notification_preferences = await prisma.notification_preferences.findMany()
    * ```
    */
  get notification_preferences(): Prisma.notification_preferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification_users`: Exposes CRUD operations for the **notification_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_users
    * const notification_users = await prisma.notification_users.findMany()
    * ```
    */
  get notification_users(): Prisma.notification_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications_operator`: Exposes CRUD operations for the **notifications_operator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications_operators
    * const notifications_operators = await prisma.notifications_operator.findMany()
    * ```
    */
  get notifications_operator(): Prisma.notifications_operatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operator_types`: Exposes CRUD operations for the **operator_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operator_types
    * const operator_types = await prisma.operator_types.findMany()
    * ```
    */
  get operator_types(): Prisma.operator_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operators`: Exposes CRUD operations for the **operators** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operators
    * const operators = await prisma.operators.findMany()
    * ```
    */
  get operators(): Prisma.operatorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packages`: Exposes CRUD operations for the **packages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.packages.findMany()
    * ```
    */
  get packages(): Prisma.packagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_types`: Exposes CRUD operations for the **payment_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_types
    * const payment_types = await prisma.payment_types.findMany()
    * ```
    */
  get payment_types(): Prisma.payment_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan_addresses`: Exposes CRUD operations for the **plan_addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_addresses
    * const plan_addresses = await prisma.plan_addresses.findMany()
    * ```
    */
  get plan_addresses(): Prisma.plan_addressesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan_features`: Exposes CRUD operations for the **plan_features** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_features
    * const plan_features = await prisma.plan_features.findMany()
    * ```
    */
  get plan_features(): Prisma.plan_featuresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plans`: Exposes CRUD operations for the **plans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plans.findMany()
    * ```
    */
  get plans(): Prisma.plansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type_users`: Exposes CRUD operations for the **type_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Type_users
    * const type_users = await prisma.type_users.findMany()
    * ```
    */
  get type_users(): Prisma.type_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicles`: Exposes CRUD operations for the **vehicles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicles.findMany()
    * ```
    */
  get vehicles(): Prisma.vehiclesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallets`: Exposes CRUD operations for the **wallets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallets.findMany()
    * ```
    */
  get wallets(): Prisma.walletsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saved_cards`: Exposes CRUD operations for the **saved_cards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saved_cards
    * const saved_cards = await prisma.saved_cards.findMany()
    * ```
    */
  get saved_cards(): Prisma.saved_cardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_methods`: Exposes CRUD operations for the **payment_methods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_methods
    * const payment_methods = await prisma.payment_methods.findMany()
    * ```
    */
  get payment_methods(): Prisma.payment_methodsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction_categories`: Exposes CRUD operations for the **transaction_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaction_categories
    * const transaction_categories = await prisma.transaction_categories.findMany()
    * ```
    */
  get transaction_categories(): Prisma.transaction_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction_types`: Exposes CRUD operations for the **transaction_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaction_types
    * const transaction_types = await prisma.transaction_types.findMany()
    * ```
    */
  get transaction_types(): Prisma.transaction_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral_sources`: Exposes CRUD operations for the **referral_sources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referral_sources
    * const referral_sources = await prisma.referral_sources.findMany()
    * ```
    */
  get referral_sources(): Prisma.referral_sourcesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cash_closures`: Exposes CRUD operations for the **cash_closures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cash_closures
    * const cash_closures = await prisma.cash_closures.findMany()
    * ```
    */
  get cash_closures(): Prisma.cash_closuresDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    activities: 'activities',
    branches: 'branches',
    categories: 'categories',
    companies: 'companies',
    email_campaigns: 'email_campaigns',
    email_templates: 'email_templates',
    gift_cards: 'gift_cards',
    invoice_items: 'invoice_items',
    invoice_packages: 'invoice_packages',
    invoices: 'invoices',
    notification_preferences: 'notification_preferences',
    notification_users: 'notification_users',
    notifications_operator: 'notifications_operator',
    operator_types: 'operator_types',
    operators: 'operators',
    packages: 'packages',
    payment_types: 'payment_types',
    payments: 'payments',
    plan_addresses: 'plan_addresses',
    plan_features: 'plan_features',
    plans: 'plans',
    products: 'products',
    type_users: 'type_users',
    users: 'users',
    vehicles: 'vehicles',
    wallets: 'wallets',
    saved_cards: 'saved_cards',
    payment_methods: 'payment_methods',
    transaction_categories: 'transaction_categories',
    transactions: 'transactions',
    transaction_types: 'transaction_types',
    referral_sources: 'referral_sources',
    cash_closures: 'cash_closures'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "activities" | "branches" | "categories" | "companies" | "email_campaigns" | "email_templates" | "gift_cards" | "invoice_items" | "invoice_packages" | "invoices" | "notification_preferences" | "notification_users" | "notifications_operator" | "operator_types" | "operators" | "packages" | "payment_types" | "payments" | "plan_addresses" | "plan_features" | "plans" | "products" | "type_users" | "users" | "vehicles" | "wallets" | "saved_cards" | "payment_methods" | "transaction_categories" | "transactions" | "transaction_types" | "referral_sources" | "cash_closures"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      activities: {
        payload: Prisma.$activitiesPayload<ExtArgs>
        fields: Prisma.activitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>
          }
          findFirst: {
            args: Prisma.activitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>
          }
          findMany: {
            args: Prisma.activitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>[]
          }
          create: {
            args: Prisma.activitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>
          }
          createMany: {
            args: Prisma.activitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.activitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>[]
          }
          delete: {
            args: Prisma.activitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>
          }
          update: {
            args: Prisma.activitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>
          }
          deleteMany: {
            args: Prisma.activitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.activitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>[]
          }
          upsert: {
            args: Prisma.activitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitiesPayload>
          }
          aggregate: {
            args: Prisma.ActivitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivities>
          }
          groupBy: {
            args: Prisma.activitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.activitiesCountArgs<ExtArgs>
            result: $Utils.Optional<ActivitiesCountAggregateOutputType> | number
          }
        }
      }
      branches: {
        payload: Prisma.$branchesPayload<ExtArgs>
        fields: Prisma.branchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.branchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.branchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          findFirst: {
            args: Prisma.branchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.branchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          findMany: {
            args: Prisma.branchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>[]
          }
          create: {
            args: Prisma.branchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          createMany: {
            args: Prisma.branchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.branchesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>[]
          }
          delete: {
            args: Prisma.branchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          update: {
            args: Prisma.branchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          deleteMany: {
            args: Prisma.branchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.branchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.branchesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>[]
          }
          upsert: {
            args: Prisma.branchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          aggregate: {
            args: Prisma.BranchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranches>
          }
          groupBy: {
            args: Prisma.branchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.branchesCountArgs<ExtArgs>
            result: $Utils.Optional<BranchesCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      email_campaigns: {
        payload: Prisma.$email_campaignsPayload<ExtArgs>
        fields: Prisma.email_campaignsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.email_campaignsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.email_campaignsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>
          }
          findFirst: {
            args: Prisma.email_campaignsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.email_campaignsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>
          }
          findMany: {
            args: Prisma.email_campaignsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>[]
          }
          create: {
            args: Prisma.email_campaignsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>
          }
          createMany: {
            args: Prisma.email_campaignsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.email_campaignsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>[]
          }
          delete: {
            args: Prisma.email_campaignsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>
          }
          update: {
            args: Prisma.email_campaignsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>
          }
          deleteMany: {
            args: Prisma.email_campaignsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.email_campaignsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.email_campaignsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>[]
          }
          upsert: {
            args: Prisma.email_campaignsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_campaignsPayload>
          }
          aggregate: {
            args: Prisma.Email_campaignsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail_campaigns>
          }
          groupBy: {
            args: Prisma.email_campaignsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Email_campaignsGroupByOutputType>[]
          }
          count: {
            args: Prisma.email_campaignsCountArgs<ExtArgs>
            result: $Utils.Optional<Email_campaignsCountAggregateOutputType> | number
          }
        }
      }
      email_templates: {
        payload: Prisma.$email_templatesPayload<ExtArgs>
        fields: Prisma.email_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.email_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.email_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          findFirst: {
            args: Prisma.email_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.email_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          findMany: {
            args: Prisma.email_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          create: {
            args: Prisma.email_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          createMany: {
            args: Prisma.email_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.email_templatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          delete: {
            args: Prisma.email_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          update: {
            args: Prisma.email_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          deleteMany: {
            args: Prisma.email_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.email_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.email_templatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          upsert: {
            args: Prisma.email_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          aggregate: {
            args: Prisma.Email_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail_templates>
          }
          groupBy: {
            args: Prisma.email_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Email_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.email_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Email_templatesCountAggregateOutputType> | number
          }
        }
      }
      gift_cards: {
        payload: Prisma.$gift_cardsPayload<ExtArgs>
        fields: Prisma.gift_cardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gift_cardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gift_cardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>
          }
          findFirst: {
            args: Prisma.gift_cardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gift_cardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>
          }
          findMany: {
            args: Prisma.gift_cardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>[]
          }
          create: {
            args: Prisma.gift_cardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>
          }
          createMany: {
            args: Prisma.gift_cardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.gift_cardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>[]
          }
          delete: {
            args: Prisma.gift_cardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>
          }
          update: {
            args: Prisma.gift_cardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>
          }
          deleteMany: {
            args: Prisma.gift_cardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gift_cardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.gift_cardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>[]
          }
          upsert: {
            args: Prisma.gift_cardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gift_cardsPayload>
          }
          aggregate: {
            args: Prisma.Gift_cardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGift_cards>
          }
          groupBy: {
            args: Prisma.gift_cardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gift_cardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.gift_cardsCountArgs<ExtArgs>
            result: $Utils.Optional<Gift_cardsCountAggregateOutputType> | number
          }
        }
      }
      invoice_items: {
        payload: Prisma.$invoice_itemsPayload<ExtArgs>
        fields: Prisma.invoice_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoice_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoice_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          findFirst: {
            args: Prisma.invoice_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoice_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          findMany: {
            args: Prisma.invoice_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>[]
          }
          create: {
            args: Prisma.invoice_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          createMany: {
            args: Prisma.invoice_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invoice_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>[]
          }
          delete: {
            args: Prisma.invoice_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          update: {
            args: Prisma.invoice_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          deleteMany: {
            args: Prisma.invoice_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoice_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invoice_itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>[]
          }
          upsert: {
            args: Prisma.invoice_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          aggregate: {
            args: Prisma.Invoice_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice_items>
          }
          groupBy: {
            args: Prisma.invoice_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Invoice_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoice_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Invoice_itemsCountAggregateOutputType> | number
          }
        }
      }
      invoice_packages: {
        payload: Prisma.$invoice_packagesPayload<ExtArgs>
        fields: Prisma.invoice_packagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoice_packagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoice_packagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>
          }
          findFirst: {
            args: Prisma.invoice_packagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoice_packagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>
          }
          findMany: {
            args: Prisma.invoice_packagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>[]
          }
          create: {
            args: Prisma.invoice_packagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>
          }
          createMany: {
            args: Prisma.invoice_packagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invoice_packagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>[]
          }
          delete: {
            args: Prisma.invoice_packagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>
          }
          update: {
            args: Prisma.invoice_packagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>
          }
          deleteMany: {
            args: Prisma.invoice_packagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoice_packagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invoice_packagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>[]
          }
          upsert: {
            args: Prisma.invoice_packagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_packagesPayload>
          }
          aggregate: {
            args: Prisma.Invoice_packagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice_packages>
          }
          groupBy: {
            args: Prisma.invoice_packagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Invoice_packagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoice_packagesCountArgs<ExtArgs>
            result: $Utils.Optional<Invoice_packagesCountAggregateOutputType> | number
          }
        }
      }
      invoices: {
        payload: Prisma.$invoicesPayload<ExtArgs>
        fields: Prisma.invoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          findFirst: {
            args: Prisma.invoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          findMany: {
            args: Prisma.invoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>[]
          }
          create: {
            args: Prisma.invoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          createMany: {
            args: Prisma.invoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invoicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>[]
          }
          delete: {
            args: Prisma.invoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          update: {
            args: Prisma.invoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          deleteMany: {
            args: Prisma.invoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invoicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>[]
          }
          upsert: {
            args: Prisma.invoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          aggregate: {
            args: Prisma.InvoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoices>
          }
          groupBy: {
            args: Prisma.invoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoicesCountArgs<ExtArgs>
            result: $Utils.Optional<InvoicesCountAggregateOutputType> | number
          }
        }
      }
      notification_preferences: {
        payload: Prisma.$notification_preferencesPayload<ExtArgs>
        fields: Prisma.notification_preferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notification_preferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notification_preferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          findFirst: {
            args: Prisma.notification_preferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notification_preferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          findMany: {
            args: Prisma.notification_preferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>[]
          }
          create: {
            args: Prisma.notification_preferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          createMany: {
            args: Prisma.notification_preferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notification_preferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>[]
          }
          delete: {
            args: Prisma.notification_preferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          update: {
            args: Prisma.notification_preferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          deleteMany: {
            args: Prisma.notification_preferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notification_preferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notification_preferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>[]
          }
          upsert: {
            args: Prisma.notification_preferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          aggregate: {
            args: Prisma.Notification_preferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_preferences>
          }
          groupBy: {
            args: Prisma.notification_preferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_preferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notification_preferencesCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_preferencesCountAggregateOutputType> | number
          }
        }
      }
      notification_users: {
        payload: Prisma.$notification_usersPayload<ExtArgs>
        fields: Prisma.notification_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notification_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notification_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>
          }
          findFirst: {
            args: Prisma.notification_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notification_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>
          }
          findMany: {
            args: Prisma.notification_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>[]
          }
          create: {
            args: Prisma.notification_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>
          }
          createMany: {
            args: Prisma.notification_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notification_usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>[]
          }
          delete: {
            args: Prisma.notification_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>
          }
          update: {
            args: Prisma.notification_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>
          }
          deleteMany: {
            args: Prisma.notification_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notification_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notification_usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>[]
          }
          upsert: {
            args: Prisma.notification_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_usersPayload>
          }
          aggregate: {
            args: Prisma.Notification_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_users>
          }
          groupBy: {
            args: Prisma.notification_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.notification_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_usersCountAggregateOutputType> | number
          }
        }
      }
      notifications_operator: {
        payload: Prisma.$notifications_operatorPayload<ExtArgs>
        fields: Prisma.notifications_operatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notifications_operatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notifications_operatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>
          }
          findFirst: {
            args: Prisma.notifications_operatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notifications_operatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>
          }
          findMany: {
            args: Prisma.notifications_operatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>[]
          }
          create: {
            args: Prisma.notifications_operatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>
          }
          createMany: {
            args: Prisma.notifications_operatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notifications_operatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>[]
          }
          delete: {
            args: Prisma.notifications_operatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>
          }
          update: {
            args: Prisma.notifications_operatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>
          }
          deleteMany: {
            args: Prisma.notifications_operatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notifications_operatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notifications_operatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>[]
          }
          upsert: {
            args: Prisma.notifications_operatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifications_operatorPayload>
          }
          aggregate: {
            args: Prisma.Notifications_operatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications_operator>
          }
          groupBy: {
            args: Prisma.notifications_operatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notifications_operatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.notifications_operatorCountArgs<ExtArgs>
            result: $Utils.Optional<Notifications_operatorCountAggregateOutputType> | number
          }
        }
      }
      operator_types: {
        payload: Prisma.$operator_typesPayload<ExtArgs>
        fields: Prisma.operator_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.operator_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.operator_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>
          }
          findFirst: {
            args: Prisma.operator_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.operator_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>
          }
          findMany: {
            args: Prisma.operator_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>[]
          }
          create: {
            args: Prisma.operator_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>
          }
          createMany: {
            args: Prisma.operator_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.operator_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>[]
          }
          delete: {
            args: Prisma.operator_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>
          }
          update: {
            args: Prisma.operator_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>
          }
          deleteMany: {
            args: Prisma.operator_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.operator_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.operator_typesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>[]
          }
          upsert: {
            args: Prisma.operator_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operator_typesPayload>
          }
          aggregate: {
            args: Prisma.Operator_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperator_types>
          }
          groupBy: {
            args: Prisma.operator_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Operator_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.operator_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Operator_typesCountAggregateOutputType> | number
          }
        }
      }
      operators: {
        payload: Prisma.$operatorsPayload<ExtArgs>
        fields: Prisma.operatorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.operatorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.operatorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>
          }
          findFirst: {
            args: Prisma.operatorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.operatorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>
          }
          findMany: {
            args: Prisma.operatorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>[]
          }
          create: {
            args: Prisma.operatorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>
          }
          createMany: {
            args: Prisma.operatorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.operatorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>[]
          }
          delete: {
            args: Prisma.operatorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>
          }
          update: {
            args: Prisma.operatorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>
          }
          deleteMany: {
            args: Prisma.operatorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.operatorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.operatorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>[]
          }
          upsert: {
            args: Prisma.operatorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorsPayload>
          }
          aggregate: {
            args: Prisma.OperatorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperators>
          }
          groupBy: {
            args: Prisma.operatorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.operatorsCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorsCountAggregateOutputType> | number
          }
        }
      }
      packages: {
        payload: Prisma.$packagesPayload<ExtArgs>
        fields: Prisma.packagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.packagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.packagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          findFirst: {
            args: Prisma.packagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.packagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          findMany: {
            args: Prisma.packagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>[]
          }
          create: {
            args: Prisma.packagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          createMany: {
            args: Prisma.packagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.packagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>[]
          }
          delete: {
            args: Prisma.packagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          update: {
            args: Prisma.packagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          deleteMany: {
            args: Prisma.packagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.packagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.packagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>[]
          }
          upsert: {
            args: Prisma.packagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          aggregate: {
            args: Prisma.PackagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackages>
          }
          groupBy: {
            args: Prisma.packagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.packagesCountArgs<ExtArgs>
            result: $Utils.Optional<PackagesCountAggregateOutputType> | number
          }
        }
      }
      payment_types: {
        payload: Prisma.$payment_typesPayload<ExtArgs>
        fields: Prisma.payment_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          findFirst: {
            args: Prisma.payment_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          findMany: {
            args: Prisma.payment_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>[]
          }
          create: {
            args: Prisma.payment_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          createMany: {
            args: Prisma.payment_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>[]
          }
          delete: {
            args: Prisma.payment_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          update: {
            args: Prisma.payment_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          deleteMany: {
            args: Prisma.payment_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_typesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>[]
          }
          upsert: {
            args: Prisma.payment_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_typesPayload>
          }
          aggregate: {
            args: Prisma.Payment_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_types>
          }
          groupBy: {
            args: Prisma.payment_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_typesCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      plan_addresses: {
        payload: Prisma.$plan_addressesPayload<ExtArgs>
        fields: Prisma.plan_addressesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plan_addressesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plan_addressesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>
          }
          findFirst: {
            args: Prisma.plan_addressesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plan_addressesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>
          }
          findMany: {
            args: Prisma.plan_addressesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>[]
          }
          create: {
            args: Prisma.plan_addressesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>
          }
          createMany: {
            args: Prisma.plan_addressesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.plan_addressesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>[]
          }
          delete: {
            args: Prisma.plan_addressesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>
          }
          update: {
            args: Prisma.plan_addressesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>
          }
          deleteMany: {
            args: Prisma.plan_addressesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plan_addressesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.plan_addressesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>[]
          }
          upsert: {
            args: Prisma.plan_addressesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_addressesPayload>
          }
          aggregate: {
            args: Prisma.Plan_addressesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan_addresses>
          }
          groupBy: {
            args: Prisma.plan_addressesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plan_addressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.plan_addressesCountArgs<ExtArgs>
            result: $Utils.Optional<Plan_addressesCountAggregateOutputType> | number
          }
        }
      }
      plan_features: {
        payload: Prisma.$plan_featuresPayload<ExtArgs>
        fields: Prisma.plan_featuresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plan_featuresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plan_featuresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>
          }
          findFirst: {
            args: Prisma.plan_featuresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plan_featuresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>
          }
          findMany: {
            args: Prisma.plan_featuresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>[]
          }
          create: {
            args: Prisma.plan_featuresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>
          }
          createMany: {
            args: Prisma.plan_featuresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.plan_featuresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>[]
          }
          delete: {
            args: Prisma.plan_featuresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>
          }
          update: {
            args: Prisma.plan_featuresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>
          }
          deleteMany: {
            args: Prisma.plan_featuresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plan_featuresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.plan_featuresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>[]
          }
          upsert: {
            args: Prisma.plan_featuresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_featuresPayload>
          }
          aggregate: {
            args: Prisma.Plan_featuresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan_features>
          }
          groupBy: {
            args: Prisma.plan_featuresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plan_featuresGroupByOutputType>[]
          }
          count: {
            args: Prisma.plan_featuresCountArgs<ExtArgs>
            result: $Utils.Optional<Plan_featuresCountAggregateOutputType> | number
          }
        }
      }
      plans: {
        payload: Prisma.$plansPayload<ExtArgs>
        fields: Prisma.plansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>
          }
          findFirst: {
            args: Prisma.plansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>
          }
          findMany: {
            args: Prisma.plansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>[]
          }
          create: {
            args: Prisma.plansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>
          }
          createMany: {
            args: Prisma.plansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.plansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>[]
          }
          delete: {
            args: Prisma.plansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>
          }
          update: {
            args: Prisma.plansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>
          }
          deleteMany: {
            args: Prisma.plansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.plansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>[]
          }
          upsert: {
            args: Prisma.plansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plansPayload>
          }
          aggregate: {
            args: Prisma.PlansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlans>
          }
          groupBy: {
            args: Prisma.plansGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlansGroupByOutputType>[]
          }
          count: {
            args: Prisma.plansCountArgs<ExtArgs>
            result: $Utils.Optional<PlansCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      type_users: {
        payload: Prisma.$type_usersPayload<ExtArgs>
        fields: Prisma.type_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.type_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.type_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>
          }
          findFirst: {
            args: Prisma.type_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.type_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>
          }
          findMany: {
            args: Prisma.type_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>[]
          }
          create: {
            args: Prisma.type_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>
          }
          createMany: {
            args: Prisma.type_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.type_usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>[]
          }
          delete: {
            args: Prisma.type_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>
          }
          update: {
            args: Prisma.type_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>
          }
          deleteMany: {
            args: Prisma.type_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.type_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.type_usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>[]
          }
          upsert: {
            args: Prisma.type_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_usersPayload>
          }
          aggregate: {
            args: Prisma.Type_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType_users>
          }
          groupBy: {
            args: Prisma.type_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Type_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.type_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Type_usersCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      vehicles: {
        payload: Prisma.$vehiclesPayload<ExtArgs>
        fields: Prisma.vehiclesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehiclesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehiclesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          findFirst: {
            args: Prisma.vehiclesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehiclesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          findMany: {
            args: Prisma.vehiclesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          create: {
            args: Prisma.vehiclesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          createMany: {
            args: Prisma.vehiclesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehiclesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          delete: {
            args: Prisma.vehiclesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          update: {
            args: Prisma.vehiclesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          deleteMany: {
            args: Prisma.vehiclesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehiclesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.vehiclesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          upsert: {
            args: Prisma.vehiclesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          aggregate: {
            args: Prisma.VehiclesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicles>
          }
          groupBy: {
            args: Prisma.vehiclesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehiclesGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehiclesCountArgs<ExtArgs>
            result: $Utils.Optional<VehiclesCountAggregateOutputType> | number
          }
        }
      }
      wallets: {
        payload: Prisma.$walletsPayload<ExtArgs>
        fields: Prisma.walletsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          findFirst: {
            args: Prisma.walletsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          findMany: {
            args: Prisma.walletsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>[]
          }
          create: {
            args: Prisma.walletsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          createMany: {
            args: Prisma.walletsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.walletsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>[]
          }
          delete: {
            args: Prisma.walletsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          update: {
            args: Prisma.walletsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          deleteMany: {
            args: Prisma.walletsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.walletsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.walletsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>[]
          }
          upsert: {
            args: Prisma.walletsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          aggregate: {
            args: Prisma.WalletsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallets>
          }
          groupBy: {
            args: Prisma.walletsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletsGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletsCountArgs<ExtArgs>
            result: $Utils.Optional<WalletsCountAggregateOutputType> | number
          }
        }
      }
      saved_cards: {
        payload: Prisma.$saved_cardsPayload<ExtArgs>
        fields: Prisma.saved_cardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saved_cardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saved_cardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>
          }
          findFirst: {
            args: Prisma.saved_cardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saved_cardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>
          }
          findMany: {
            args: Prisma.saved_cardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>[]
          }
          create: {
            args: Prisma.saved_cardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>
          }
          createMany: {
            args: Prisma.saved_cardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saved_cardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>[]
          }
          delete: {
            args: Prisma.saved_cardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>
          }
          update: {
            args: Prisma.saved_cardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>
          }
          deleteMany: {
            args: Prisma.saved_cardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saved_cardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saved_cardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>[]
          }
          upsert: {
            args: Prisma.saved_cardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saved_cardsPayload>
          }
          aggregate: {
            args: Prisma.Saved_cardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaved_cards>
          }
          groupBy: {
            args: Prisma.saved_cardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Saved_cardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.saved_cardsCountArgs<ExtArgs>
            result: $Utils.Optional<Saved_cardsCountAggregateOutputType> | number
          }
        }
      }
      payment_methods: {
        payload: Prisma.$payment_methodsPayload<ExtArgs>
        fields: Prisma.payment_methodsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_methodsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_methodsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          findFirst: {
            args: Prisma.payment_methodsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_methodsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          findMany: {
            args: Prisma.payment_methodsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>[]
          }
          create: {
            args: Prisma.payment_methodsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          createMany: {
            args: Prisma.payment_methodsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_methodsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>[]
          }
          delete: {
            args: Prisma.payment_methodsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          update: {
            args: Prisma.payment_methodsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          deleteMany: {
            args: Prisma.payment_methodsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_methodsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_methodsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>[]
          }
          upsert: {
            args: Prisma.payment_methodsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          aggregate: {
            args: Prisma.Payment_methodsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_methods>
          }
          groupBy: {
            args: Prisma.payment_methodsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_methodsCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodsCountAggregateOutputType> | number
          }
        }
      }
      transaction_categories: {
        payload: Prisma.$transaction_categoriesPayload<ExtArgs>
        fields: Prisma.transaction_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaction_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaction_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>
          }
          findFirst: {
            args: Prisma.transaction_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaction_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>
          }
          findMany: {
            args: Prisma.transaction_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>[]
          }
          create: {
            args: Prisma.transaction_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>
          }
          createMany: {
            args: Prisma.transaction_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transaction_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>[]
          }
          delete: {
            args: Prisma.transaction_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>
          }
          update: {
            args: Prisma.transaction_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.transaction_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaction_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transaction_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.transaction_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Transaction_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction_categories>
          }
          groupBy: {
            args: Prisma.transaction_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Transaction_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaction_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Transaction_categoriesCountAggregateOutputType> | number
          }
        }
      }
      transactions: {
        payload: Prisma.$transactionsPayload<ExtArgs>
        fields: Prisma.transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findFirst: {
            args: Prisma.transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findMany: {
            args: Prisma.transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          create: {
            args: Prisma.transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          createMany: {
            args: Prisma.transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          delete: {
            args: Prisma.transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          update: {
            args: Prisma.transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          deleteMany: {
            args: Prisma.transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          upsert: {
            args: Prisma.transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      transaction_types: {
        payload: Prisma.$transaction_typesPayload<ExtArgs>
        fields: Prisma.transaction_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaction_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaction_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          findFirst: {
            args: Prisma.transaction_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaction_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          findMany: {
            args: Prisma.transaction_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>[]
          }
          create: {
            args: Prisma.transaction_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          createMany: {
            args: Prisma.transaction_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transaction_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>[]
          }
          delete: {
            args: Prisma.transaction_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          update: {
            args: Prisma.transaction_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          deleteMany: {
            args: Prisma.transaction_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaction_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transaction_typesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>[]
          }
          upsert: {
            args: Prisma.transaction_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_typesPayload>
          }
          aggregate: {
            args: Prisma.Transaction_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction_types>
          }
          groupBy: {
            args: Prisma.transaction_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Transaction_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaction_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Transaction_typesCountAggregateOutputType> | number
          }
        }
      }
      referral_sources: {
        payload: Prisma.$referral_sourcesPayload<ExtArgs>
        fields: Prisma.referral_sourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.referral_sourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referral_sourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>
          }
          findFirst: {
            args: Prisma.referral_sourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referral_sourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>
          }
          findMany: {
            args: Prisma.referral_sourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>[]
          }
          create: {
            args: Prisma.referral_sourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>
          }
          createMany: {
            args: Prisma.referral_sourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.referral_sourcesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>[]
          }
          delete: {
            args: Prisma.referral_sourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>
          }
          update: {
            args: Prisma.referral_sourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>
          }
          deleteMany: {
            args: Prisma.referral_sourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.referral_sourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.referral_sourcesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>[]
          }
          upsert: {
            args: Prisma.referral_sourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_sourcesPayload>
          }
          aggregate: {
            args: Prisma.Referral_sourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral_sources>
          }
          groupBy: {
            args: Prisma.referral_sourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Referral_sourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.referral_sourcesCountArgs<ExtArgs>
            result: $Utils.Optional<Referral_sourcesCountAggregateOutputType> | number
          }
        }
      }
      cash_closures: {
        payload: Prisma.$cash_closuresPayload<ExtArgs>
        fields: Prisma.cash_closuresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cash_closuresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cash_closuresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>
          }
          findFirst: {
            args: Prisma.cash_closuresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cash_closuresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>
          }
          findMany: {
            args: Prisma.cash_closuresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>[]
          }
          create: {
            args: Prisma.cash_closuresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>
          }
          createMany: {
            args: Prisma.cash_closuresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cash_closuresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>[]
          }
          delete: {
            args: Prisma.cash_closuresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>
          }
          update: {
            args: Prisma.cash_closuresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>
          }
          deleteMany: {
            args: Prisma.cash_closuresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cash_closuresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cash_closuresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>[]
          }
          upsert: {
            args: Prisma.cash_closuresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_closuresPayload>
          }
          aggregate: {
            args: Prisma.Cash_closuresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCash_closures>
          }
          groupBy: {
            args: Prisma.cash_closuresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cash_closuresGroupByOutputType>[]
          }
          count: {
            args: Prisma.cash_closuresCountArgs<ExtArgs>
            result: $Utils.Optional<Cash_closuresCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    activities?: activitiesOmit
    branches?: branchesOmit
    categories?: categoriesOmit
    companies?: companiesOmit
    email_campaigns?: email_campaignsOmit
    email_templates?: email_templatesOmit
    gift_cards?: gift_cardsOmit
    invoice_items?: invoice_itemsOmit
    invoice_packages?: invoice_packagesOmit
    invoices?: invoicesOmit
    notification_preferences?: notification_preferencesOmit
    notification_users?: notification_usersOmit
    notifications_operator?: notifications_operatorOmit
    operator_types?: operator_typesOmit
    operators?: operatorsOmit
    packages?: packagesOmit
    payment_types?: payment_typesOmit
    payments?: paymentsOmit
    plan_addresses?: plan_addressesOmit
    plan_features?: plan_featuresOmit
    plans?: plansOmit
    products?: productsOmit
    type_users?: type_usersOmit
    users?: usersOmit
    vehicles?: vehiclesOmit
    wallets?: walletsOmit
    saved_cards?: saved_cardsOmit
    payment_methods?: payment_methodsOmit
    transaction_categories?: transaction_categoriesOmit
    transactions?: transactionsOmit
    transaction_types?: transaction_typesOmit
    referral_sources?: referral_sourcesOmit
    cash_closures?: cash_closuresOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchesCountOutputType
   */

  export type BranchesCountOutputType = {
    activities: number
    gift_cards: number
    invoices: number
    operators: number
    packages: number
    plans: number
    products: number
    users: number
    vehicles: number
  }

  export type BranchesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | BranchesCountOutputTypeCountActivitiesArgs
    gift_cards?: boolean | BranchesCountOutputTypeCountGift_cardsArgs
    invoices?: boolean | BranchesCountOutputTypeCountInvoicesArgs
    operators?: boolean | BranchesCountOutputTypeCountOperatorsArgs
    packages?: boolean | BranchesCountOutputTypeCountPackagesArgs
    plans?: boolean | BranchesCountOutputTypeCountPlansArgs
    products?: boolean | BranchesCountOutputTypeCountProductsArgs
    users?: boolean | BranchesCountOutputTypeCountUsersArgs
    vehicles?: boolean | BranchesCountOutputTypeCountVehiclesArgs
  }

  // Custom InputTypes
  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchesCountOutputType
     */
    select?: BranchesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitiesWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountGift_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gift_cardsWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountOperatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operatorsWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: packagesWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plansWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehiclesWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    products: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoriesCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    branches: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | CompaniesCountOutputTypeCountBranchesArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchesWhereInput
  }


  /**
   * Count Type Email_templatesCountOutputType
   */

  export type Email_templatesCountOutputType = {
    email_campaigns: number
  }

  export type Email_templatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email_campaigns?: boolean | Email_templatesCountOutputTypeCountEmail_campaignsArgs
  }

  // Custom InputTypes
  /**
   * Email_templatesCountOutputType without action
   */
  export type Email_templatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email_templatesCountOutputType
     */
    select?: Email_templatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Email_templatesCountOutputType without action
   */
  export type Email_templatesCountOutputTypeCountEmail_campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_campaignsWhereInput
  }


  /**
   * Count Type InvoicesCountOutputType
   */

  export type InvoicesCountOutputType = {
    invoice_items: number
    invoice_packages: number
    payments: number
  }

  export type InvoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_items?: boolean | InvoicesCountOutputTypeCountInvoice_itemsArgs
    invoice_packages?: boolean | InvoicesCountOutputTypeCountInvoice_packagesArgs
    payments?: boolean | InvoicesCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicesCountOutputType
     */
    select?: InvoicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountInvoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_itemsWhereInput
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountInvoice_packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_packagesWhereInput
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type Operator_typesCountOutputType
   */

  export type Operator_typesCountOutputType = {
    operators: number
  }

  export type Operator_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operators?: boolean | Operator_typesCountOutputTypeCountOperatorsArgs
  }

  // Custom InputTypes
  /**
   * Operator_typesCountOutputType without action
   */
  export type Operator_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator_typesCountOutputType
     */
    select?: Operator_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Operator_typesCountOutputType without action
   */
  export type Operator_typesCountOutputTypeCountOperatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operatorsWhereInput
  }


  /**
   * Count Type OperatorsCountOutputType
   */

  export type OperatorsCountOutputType = {
    activities: number
    email_templates: number
    invoices: number
    notifications_operator: number
    packages: number
  }

  export type OperatorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | OperatorsCountOutputTypeCountActivitiesArgs
    email_templates?: boolean | OperatorsCountOutputTypeCountEmail_templatesArgs
    invoices?: boolean | OperatorsCountOutputTypeCountInvoicesArgs
    notifications_operator?: boolean | OperatorsCountOutputTypeCountNotifications_operatorArgs
    packages?: boolean | OperatorsCountOutputTypeCountPackagesArgs
  }

  // Custom InputTypes
  /**
   * OperatorsCountOutputType without action
   */
  export type OperatorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorsCountOutputType
     */
    select?: OperatorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperatorsCountOutputType without action
   */
  export type OperatorsCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitiesWhereInput
  }

  /**
   * OperatorsCountOutputType without action
   */
  export type OperatorsCountOutputTypeCountEmail_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_templatesWhereInput
  }

  /**
   * OperatorsCountOutputType without action
   */
  export type OperatorsCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
  }

  /**
   * OperatorsCountOutputType without action
   */
  export type OperatorsCountOutputTypeCountNotifications_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notifications_operatorWhereInput
  }

  /**
   * OperatorsCountOutputType without action
   */
  export type OperatorsCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: packagesWhereInput
  }


  /**
   * Count Type PackagesCountOutputType
   */

  export type PackagesCountOutputType = {
    invoice_packages: number
  }

  export type PackagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_packages?: boolean | PackagesCountOutputTypeCountInvoice_packagesArgs
  }

  // Custom InputTypes
  /**
   * PackagesCountOutputType without action
   */
  export type PackagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesCountOutputType
     */
    select?: PackagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackagesCountOutputType without action
   */
  export type PackagesCountOutputTypeCountInvoice_packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_packagesWhereInput
  }


  /**
   * Count Type Payment_typesCountOutputType
   */

  export type Payment_typesCountOutputType = {
    payment_methods: number
  }

  export type Payment_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_methods?: boolean | Payment_typesCountOutputTypeCountPayment_methodsArgs
  }

  // Custom InputTypes
  /**
   * Payment_typesCountOutputType without action
   */
  export type Payment_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_typesCountOutputType
     */
    select?: Payment_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Payment_typesCountOutputType without action
   */
  export type Payment_typesCountOutputTypeCountPayment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_methodsWhereInput
  }


  /**
   * Count Type PlansCountOutputType
   */

  export type PlansCountOutputType = {
    invoice_items: number
    plan_addresses: number
    plan_features: number
    users: number
  }

  export type PlansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_items?: boolean | PlansCountOutputTypeCountInvoice_itemsArgs
    plan_addresses?: boolean | PlansCountOutputTypeCountPlan_addressesArgs
    plan_features?: boolean | PlansCountOutputTypeCountPlan_featuresArgs
    users?: boolean | PlansCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * PlansCountOutputType without action
   */
  export type PlansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlansCountOutputType
     */
    select?: PlansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlansCountOutputType without action
   */
  export type PlansCountOutputTypeCountInvoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_itemsWhereInput
  }

  /**
   * PlansCountOutputType without action
   */
  export type PlansCountOutputTypeCountPlan_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plan_addressesWhereInput
  }

  /**
   * PlansCountOutputType without action
   */
  export type PlansCountOutputTypeCountPlan_featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plan_featuresWhereInput
  }

  /**
   * PlansCountOutputType without action
   */
  export type PlansCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    invoice_items: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_items?: boolean | ProductsCountOutputTypeCountInvoice_itemsArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountInvoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_itemsWhereInput
  }


  /**
   * Count Type Type_usersCountOutputType
   */

  export type Type_usersCountOutputType = {
    users: number
  }

  export type Type_usersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Type_usersCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * Type_usersCountOutputType without action
   */
  export type Type_usersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type_usersCountOutputType
     */
    select?: Type_usersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Type_usersCountOutputType without action
   */
  export type Type_usersCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    email_campaigns: number
    invoices: number
    notification_preferences: number
    notification_users: number
    packages: number
    saved_cards: number
    wallets: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email_campaigns?: boolean | UsersCountOutputTypeCountEmail_campaignsArgs
    invoices?: boolean | UsersCountOutputTypeCountInvoicesArgs
    notification_preferences?: boolean | UsersCountOutputTypeCountNotification_preferencesArgs
    notification_users?: boolean | UsersCountOutputTypeCountNotification_usersArgs
    packages?: boolean | UsersCountOutputTypeCountPackagesArgs
    saved_cards?: boolean | UsersCountOutputTypeCountSaved_cardsArgs
    wallets?: boolean | UsersCountOutputTypeCountWalletsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountEmail_campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_campaignsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotification_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_preferencesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotification_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_usersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: packagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSaved_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saved_cardsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletsWhereInput
  }


  /**
   * Count Type Payment_methodsCountOutputType
   */

  export type Payment_methodsCountOutputType = {
    payments: number
    transactions: number
  }

  export type Payment_methodsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Payment_methodsCountOutputTypeCountPaymentsArgs
    transactions?: boolean | Payment_methodsCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * Payment_methodsCountOutputType without action
   */
  export type Payment_methodsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_methodsCountOutputType
     */
    select?: Payment_methodsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Payment_methodsCountOutputType without action
   */
  export type Payment_methodsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * Payment_methodsCountOutputType without action
   */
  export type Payment_methodsCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type Transaction_categoriesCountOutputType
   */

  export type Transaction_categoriesCountOutputType = {
    other_transaction_categories: number
    transactions: number
  }

  export type Transaction_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_transaction_categories?: boolean | Transaction_categoriesCountOutputTypeCountOther_transaction_categoriesArgs
    transactions?: boolean | Transaction_categoriesCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * Transaction_categoriesCountOutputType without action
   */
  export type Transaction_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction_categoriesCountOutputType
     */
    select?: Transaction_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Transaction_categoriesCountOutputType without action
   */
  export type Transaction_categoriesCountOutputTypeCountOther_transaction_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaction_categoriesWhereInput
  }

  /**
   * Transaction_categoriesCountOutputType without action
   */
  export type Transaction_categoriesCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type TransactionsCountOutputType
   */

  export type TransactionsCountOutputType = {
    payments: number
  }

  export type TransactionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | TransactionsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsCountOutputType
     */
    select?: TransactionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type Transaction_typesCountOutputType
   */

  export type Transaction_typesCountOutputType = {
    transactions: number
  }

  export type Transaction_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Transaction_typesCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * Transaction_typesCountOutputType without action
   */
  export type Transaction_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction_typesCountOutputType
     */
    select?: Transaction_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Transaction_typesCountOutputType without action
   */
  export type Transaction_typesCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type Referral_sourcesCountOutputType
   */

  export type Referral_sourcesCountOutputType = {
    users: number
  }

  export type Referral_sourcesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Referral_sourcesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * Referral_sourcesCountOutputType without action
   */
  export type Referral_sourcesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral_sourcesCountOutputType
     */
    select?: Referral_sourcesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Referral_sourcesCountOutputType without action
   */
  export type Referral_sourcesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Models
   */

  /**
   * Model activities
   */

  export type AggregateActivities = {
    _count: ActivitiesCountAggregateOutputType | null
    _min: ActivitiesMinAggregateOutputType | null
    _max: ActivitiesMaxAggregateOutputType | null
  }

  export type ActivitiesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    action: string | null
    type: $Enums.activity_type_enum | null
    description: string | null
    ip_address: string | null
    user_agent: string | null
    status: $Enums.activity_status_enum | null
    operator_id: string | null
    branch_id: string | null
    entity_type: string | null
    entity_id: string | null
  }

  export type ActivitiesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    action: string | null
    type: $Enums.activity_type_enum | null
    description: string | null
    ip_address: string | null
    user_agent: string | null
    status: $Enums.activity_status_enum | null
    operator_id: string | null
    branch_id: string | null
    entity_type: string | null
    entity_id: string | null
  }

  export type ActivitiesCountAggregateOutputType = {
    id: number
    created_at: number
    action: number
    type: number
    description: number
    ip_address: number
    user_agent: number
    status: number
    operator_id: number
    branch_id: number
    entity_type: number
    entity_id: number
    old_values: number
    new_values: number
    metadata: number
    _all: number
  }


  export type ActivitiesMinAggregateInputType = {
    id?: true
    created_at?: true
    action?: true
    type?: true
    description?: true
    ip_address?: true
    user_agent?: true
    status?: true
    operator_id?: true
    branch_id?: true
    entity_type?: true
    entity_id?: true
  }

  export type ActivitiesMaxAggregateInputType = {
    id?: true
    created_at?: true
    action?: true
    type?: true
    description?: true
    ip_address?: true
    user_agent?: true
    status?: true
    operator_id?: true
    branch_id?: true
    entity_type?: true
    entity_id?: true
  }

  export type ActivitiesCountAggregateInputType = {
    id?: true
    created_at?: true
    action?: true
    type?: true
    description?: true
    ip_address?: true
    user_agent?: true
    status?: true
    operator_id?: true
    branch_id?: true
    entity_type?: true
    entity_id?: true
    old_values?: true
    new_values?: true
    metadata?: true
    _all?: true
  }

  export type ActivitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activities to aggregate.
     */
    where?: activitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activitiesOrderByWithRelationInput | activitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activities
    **/
    _count?: true | ActivitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivitiesMaxAggregateInputType
  }

  export type GetActivitiesAggregateType<T extends ActivitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateActivities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivities[P]>
      : GetScalarType<T[P], AggregateActivities[P]>
  }




  export type activitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitiesWhereInput
    orderBy?: activitiesOrderByWithAggregationInput | activitiesOrderByWithAggregationInput[]
    by: ActivitiesScalarFieldEnum[] | ActivitiesScalarFieldEnum
    having?: activitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivitiesCountAggregateInputType | true
    _min?: ActivitiesMinAggregateInputType
    _max?: ActivitiesMaxAggregateInputType
  }

  export type ActivitiesGroupByOutputType = {
    id: string
    created_at: Date
    action: string
    type: $Enums.activity_type_enum
    description: string | null
    ip_address: string | null
    user_agent: string | null
    status: $Enums.activity_status_enum | null
    operator_id: string | null
    branch_id: string | null
    entity_type: string | null
    entity_id: string | null
    old_values: JsonValue | null
    new_values: JsonValue | null
    metadata: JsonValue | null
    _count: ActivitiesCountAggregateOutputType | null
    _min: ActivitiesMinAggregateOutputType | null
    _max: ActivitiesMaxAggregateOutputType | null
  }

  type GetActivitiesGroupByPayload<T extends activitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivitiesGroupByOutputType[P]>
            : GetScalarType<T[P], ActivitiesGroupByOutputType[P]>
        }
      >
    >


  export type activitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    action?: boolean
    type?: boolean
    description?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    operator_id?: boolean
    branch_id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    old_values?: boolean
    new_values?: boolean
    metadata?: boolean
    branches?: boolean | activities$branchesArgs<ExtArgs>
    operators?: boolean | activities$operatorsArgs<ExtArgs>
  }, ExtArgs["result"]["activities"]>

  export type activitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    action?: boolean
    type?: boolean
    description?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    operator_id?: boolean
    branch_id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    old_values?: boolean
    new_values?: boolean
    metadata?: boolean
    branches?: boolean | activities$branchesArgs<ExtArgs>
    operators?: boolean | activities$operatorsArgs<ExtArgs>
  }, ExtArgs["result"]["activities"]>

  export type activitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    action?: boolean
    type?: boolean
    description?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    operator_id?: boolean
    branch_id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    old_values?: boolean
    new_values?: boolean
    metadata?: boolean
    branches?: boolean | activities$branchesArgs<ExtArgs>
    operators?: boolean | activities$operatorsArgs<ExtArgs>
  }, ExtArgs["result"]["activities"]>

  export type activitiesSelectScalar = {
    id?: boolean
    created_at?: boolean
    action?: boolean
    type?: boolean
    description?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    operator_id?: boolean
    branch_id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    old_values?: boolean
    new_values?: boolean
    metadata?: boolean
  }

  export type activitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "action" | "type" | "description" | "ip_address" | "user_agent" | "status" | "operator_id" | "branch_id" | "entity_type" | "entity_id" | "old_values" | "new_values" | "metadata", ExtArgs["result"]["activities"]>
  export type activitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | activities$branchesArgs<ExtArgs>
    operators?: boolean | activities$operatorsArgs<ExtArgs>
  }
  export type activitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | activities$branchesArgs<ExtArgs>
    operators?: boolean | activities$operatorsArgs<ExtArgs>
  }
  export type activitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | activities$branchesArgs<ExtArgs>
    operators?: boolean | activities$operatorsArgs<ExtArgs>
  }

  export type $activitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activities"
    objects: {
      branches: Prisma.$branchesPayload<ExtArgs> | null
      operators: Prisma.$operatorsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      action: string
      type: $Enums.activity_type_enum
      description: string | null
      ip_address: string | null
      user_agent: string | null
      status: $Enums.activity_status_enum | null
      operator_id: string | null
      branch_id: string | null
      entity_type: string | null
      entity_id: string | null
      old_values: Prisma.JsonValue | null
      new_values: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["activities"]>
    composites: {}
  }

  type activitiesGetPayload<S extends boolean | null | undefined | activitiesDefaultArgs> = $Result.GetResult<Prisma.$activitiesPayload, S>

  type activitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<activitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivitiesCountAggregateInputType | true
    }

  export interface activitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activities'], meta: { name: 'activities' } }
    /**
     * Find zero or one Activities that matches the filter.
     * @param {activitiesFindUniqueArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activitiesFindUniqueArgs>(args: SelectSubset<T, activitiesFindUniqueArgs<ExtArgs>>): Prisma__activitiesClient<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {activitiesFindUniqueOrThrowArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, activitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activitiesClient<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitiesFindFirstArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activitiesFindFirstArgs>(args?: SelectSubset<T, activitiesFindFirstArgs<ExtArgs>>): Prisma__activitiesClient<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitiesFindFirstOrThrowArgs} args - Arguments to find a Activities
     * @example
     * // Get one Activities
     * const activities = await prisma.activities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, activitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__activitiesClient<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activities.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activitiesWithIdOnly = await prisma.activities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activitiesFindManyArgs>(args?: SelectSubset<T, activitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activities.
     * @param {activitiesCreateArgs} args - Arguments to create a Activities.
     * @example
     * // Create one Activities
     * const Activities = await prisma.activities.create({
     *   data: {
     *     // ... data to create a Activities
     *   }
     * })
     * 
     */
    create<T extends activitiesCreateArgs>(args: SelectSubset<T, activitiesCreateArgs<ExtArgs>>): Prisma__activitiesClient<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {activitiesCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activities = await prisma.activities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activitiesCreateManyArgs>(args?: SelectSubset<T, activitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {activitiesCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activities = await prisma.activities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activitiesWithIdOnly = await prisma.activities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends activitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, activitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activities.
     * @param {activitiesDeleteArgs} args - Arguments to delete one Activities.
     * @example
     * // Delete one Activities
     * const Activities = await prisma.activities.delete({
     *   where: {
     *     // ... filter to delete one Activities
     *   }
     * })
     * 
     */
    delete<T extends activitiesDeleteArgs>(args: SelectSubset<T, activitiesDeleteArgs<ExtArgs>>): Prisma__activitiesClient<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activities.
     * @param {activitiesUpdateArgs} args - Arguments to update one Activities.
     * @example
     * // Update one Activities
     * const activities = await prisma.activities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activitiesUpdateArgs>(args: SelectSubset<T, activitiesUpdateArgs<ExtArgs>>): Prisma__activitiesClient<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {activitiesDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activitiesDeleteManyArgs>(args?: SelectSubset<T, activitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activities = await prisma.activities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activitiesUpdateManyArgs>(args: SelectSubset<T, activitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {activitiesUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activities = await prisma.activities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activitiesWithIdOnly = await prisma.activities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends activitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, activitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activities.
     * @param {activitiesUpsertArgs} args - Arguments to update or create a Activities.
     * @example
     * // Update or create a Activities
     * const activities = await prisma.activities.upsert({
     *   create: {
     *     // ... data to create a Activities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activities we want to update
     *   }
     * })
     */
    upsert<T extends activitiesUpsertArgs>(args: SelectSubset<T, activitiesUpsertArgs<ExtArgs>>): Prisma__activitiesClient<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitiesCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activities.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends activitiesCountArgs>(
      args?: Subset<T, activitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivitiesAggregateArgs>(args: Subset<T, ActivitiesAggregateArgs>): Prisma.PrismaPromise<GetActivitiesAggregateType<T>>

    /**
     * Group by Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activitiesGroupByArgs['orderBy'] }
        : { orderBy?: activitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activities model
   */
  readonly fields: activitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends activities$branchesArgs<ExtArgs> = {}>(args?: Subset<T, activities$branchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    operators<T extends activities$operatorsArgs<ExtArgs> = {}>(args?: Subset<T, activities$operatorsArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activities model
   */ 
  interface activitiesFieldRefs {
    readonly id: FieldRef<"activities", 'String'>
    readonly created_at: FieldRef<"activities", 'DateTime'>
    readonly action: FieldRef<"activities", 'String'>
    readonly type: FieldRef<"activities", 'activity_type_enum'>
    readonly description: FieldRef<"activities", 'String'>
    readonly ip_address: FieldRef<"activities", 'String'>
    readonly user_agent: FieldRef<"activities", 'String'>
    readonly status: FieldRef<"activities", 'activity_status_enum'>
    readonly operator_id: FieldRef<"activities", 'String'>
    readonly branch_id: FieldRef<"activities", 'String'>
    readonly entity_type: FieldRef<"activities", 'String'>
    readonly entity_id: FieldRef<"activities", 'String'>
    readonly old_values: FieldRef<"activities", 'Json'>
    readonly new_values: FieldRef<"activities", 'Json'>
    readonly metadata: FieldRef<"activities", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * activities findUnique
   */
  export type activitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * Filter, which activities to fetch.
     */
    where: activitiesWhereUniqueInput
  }

  /**
   * activities findUniqueOrThrow
   */
  export type activitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * Filter, which activities to fetch.
     */
    where: activitiesWhereUniqueInput
  }

  /**
   * activities findFirst
   */
  export type activitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * Filter, which activities to fetch.
     */
    where?: activitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activitiesOrderByWithRelationInput | activitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activities.
     */
    cursor?: activitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activities.
     */
    distinct?: ActivitiesScalarFieldEnum | ActivitiesScalarFieldEnum[]
  }

  /**
   * activities findFirstOrThrow
   */
  export type activitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * Filter, which activities to fetch.
     */
    where?: activitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activitiesOrderByWithRelationInput | activitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activities.
     */
    cursor?: activitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activities.
     */
    distinct?: ActivitiesScalarFieldEnum | ActivitiesScalarFieldEnum[]
  }

  /**
   * activities findMany
   */
  export type activitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * Filter, which activities to fetch.
     */
    where?: activitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activitiesOrderByWithRelationInput | activitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activities.
     */
    cursor?: activitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    distinct?: ActivitiesScalarFieldEnum | ActivitiesScalarFieldEnum[]
  }

  /**
   * activities create
   */
  export type activitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a activities.
     */
    data: XOR<activitiesCreateInput, activitiesUncheckedCreateInput>
  }

  /**
   * activities createMany
   */
  export type activitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activities.
     */
    data: activitiesCreateManyInput | activitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activities createManyAndReturn
   */
  export type activitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * The data used to create many activities.
     */
    data: activitiesCreateManyInput | activitiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * activities update
   */
  export type activitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a activities.
     */
    data: XOR<activitiesUpdateInput, activitiesUncheckedUpdateInput>
    /**
     * Choose, which activities to update.
     */
    where: activitiesWhereUniqueInput
  }

  /**
   * activities updateMany
   */
  export type activitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activities.
     */
    data: XOR<activitiesUpdateManyMutationInput, activitiesUncheckedUpdateManyInput>
    /**
     * Filter which activities to update
     */
    where?: activitiesWhereInput
    /**
     * Limit how many activities to update.
     */
    limit?: number
  }

  /**
   * activities updateManyAndReturn
   */
  export type activitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * The data used to update activities.
     */
    data: XOR<activitiesUpdateManyMutationInput, activitiesUncheckedUpdateManyInput>
    /**
     * Filter which activities to update
     */
    where?: activitiesWhereInput
    /**
     * Limit how many activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * activities upsert
   */
  export type activitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the activities to update in case it exists.
     */
    where: activitiesWhereUniqueInput
    /**
     * In case the activities found by the `where` argument doesn't exist, create a new activities with this data.
     */
    create: XOR<activitiesCreateInput, activitiesUncheckedCreateInput>
    /**
     * In case the activities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activitiesUpdateInput, activitiesUncheckedUpdateInput>
  }

  /**
   * activities delete
   */
  export type activitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    /**
     * Filter which activities to delete.
     */
    where: activitiesWhereUniqueInput
  }

  /**
   * activities deleteMany
   */
  export type activitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activities to delete
     */
    where?: activitiesWhereInput
    /**
     * Limit how many activities to delete.
     */
    limit?: number
  }

  /**
   * activities.branches
   */
  export type activities$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * activities.operators
   */
  export type activities$operatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    where?: operatorsWhereInput
  }

  /**
   * activities without action
   */
  export type activitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
  }


  /**
   * Model branches
   */

  export type AggregateBranches = {
    _count: BranchesCountAggregateOutputType | null
    _min: BranchesMinAggregateOutputType | null
    _max: BranchesMaxAggregateOutputType | null
  }

  export type BranchesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    address: string | null
    province: string | null
    city: string | null
    postal_code: string | null
    phone: string | null
    email: string | null
    is_active: boolean | null
    prefix: string | null
    company_id: string | null
    manager_name: string | null
    timezone: string | null
  }

  export type BranchesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    address: string | null
    province: string | null
    city: string | null
    postal_code: string | null
    phone: string | null
    email: string | null
    is_active: boolean | null
    prefix: string | null
    company_id: string | null
    manager_name: string | null
    timezone: string | null
  }

  export type BranchesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    address: number
    province: number
    city: number
    postal_code: number
    phone: number
    email: number
    is_active: number
    prefix: number
    company_id: number
    manager_name: number
    opening_hours: number
    timezone: number
    _all: number
  }


  export type BranchesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    address?: true
    province?: true
    city?: true
    postal_code?: true
    phone?: true
    email?: true
    is_active?: true
    prefix?: true
    company_id?: true
    manager_name?: true
    timezone?: true
  }

  export type BranchesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    address?: true
    province?: true
    city?: true
    postal_code?: true
    phone?: true
    email?: true
    is_active?: true
    prefix?: true
    company_id?: true
    manager_name?: true
    timezone?: true
  }

  export type BranchesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    address?: true
    province?: true
    city?: true
    postal_code?: true
    phone?: true
    email?: true
    is_active?: true
    prefix?: true
    company_id?: true
    manager_name?: true
    opening_hours?: true
    timezone?: true
    _all?: true
  }

  export type BranchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branches to aggregate.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned branches
    **/
    _count?: true | BranchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchesMaxAggregateInputType
  }

  export type GetBranchesAggregateType<T extends BranchesAggregateArgs> = {
        [P in keyof T & keyof AggregateBranches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranches[P]>
      : GetScalarType<T[P], AggregateBranches[P]>
  }




  export type branchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchesWhereInput
    orderBy?: branchesOrderByWithAggregationInput | branchesOrderByWithAggregationInput[]
    by: BranchesScalarFieldEnum[] | BranchesScalarFieldEnum
    having?: branchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchesCountAggregateInputType | true
    _min?: BranchesMinAggregateInputType
    _max?: BranchesMaxAggregateInputType
  }

  export type BranchesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    name: string
    address: string | null
    province: string | null
    city: string | null
    postal_code: string | null
    phone: string | null
    email: string | null
    is_active: boolean | null
    prefix: string | null
    company_id: string
    manager_name: string | null
    opening_hours: JsonValue | null
    timezone: string | null
    _count: BranchesCountAggregateOutputType | null
    _min: BranchesMinAggregateOutputType | null
    _max: BranchesMaxAggregateOutputType | null
  }

  type GetBranchesGroupByPayload<T extends branchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchesGroupByOutputType[P]>
            : GetScalarType<T[P], BranchesGroupByOutputType[P]>
        }
      >
    >


  export type branchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    postal_code?: boolean
    phone?: boolean
    email?: boolean
    is_active?: boolean
    prefix?: boolean
    company_id?: boolean
    manager_name?: boolean
    opening_hours?: boolean
    timezone?: boolean
    activities?: boolean | branches$activitiesArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    gift_cards?: boolean | branches$gift_cardsArgs<ExtArgs>
    invoices?: boolean | branches$invoicesArgs<ExtArgs>
    operators?: boolean | branches$operatorsArgs<ExtArgs>
    packages?: boolean | branches$packagesArgs<ExtArgs>
    plans?: boolean | branches$plansArgs<ExtArgs>
    products?: boolean | branches$productsArgs<ExtArgs>
    users?: boolean | branches$usersArgs<ExtArgs>
    vehicles?: boolean | branches$vehiclesArgs<ExtArgs>
    _count?: boolean | BranchesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branches"]>

  export type branchesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    postal_code?: boolean
    phone?: boolean
    email?: boolean
    is_active?: boolean
    prefix?: boolean
    company_id?: boolean
    manager_name?: boolean
    opening_hours?: boolean
    timezone?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branches"]>

  export type branchesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    postal_code?: boolean
    phone?: boolean
    email?: boolean
    is_active?: boolean
    prefix?: boolean
    company_id?: boolean
    manager_name?: boolean
    opening_hours?: boolean
    timezone?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branches"]>

  export type branchesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    postal_code?: boolean
    phone?: boolean
    email?: boolean
    is_active?: boolean
    prefix?: boolean
    company_id?: boolean
    manager_name?: boolean
    opening_hours?: boolean
    timezone?: boolean
  }

  export type branchesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "address" | "province" | "city" | "postal_code" | "phone" | "email" | "is_active" | "prefix" | "company_id" | "manager_name" | "opening_hours" | "timezone", ExtArgs["result"]["branches"]>
  export type branchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | branches$activitiesArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    gift_cards?: boolean | branches$gift_cardsArgs<ExtArgs>
    invoices?: boolean | branches$invoicesArgs<ExtArgs>
    operators?: boolean | branches$operatorsArgs<ExtArgs>
    packages?: boolean | branches$packagesArgs<ExtArgs>
    plans?: boolean | branches$plansArgs<ExtArgs>
    products?: boolean | branches$productsArgs<ExtArgs>
    users?: boolean | branches$usersArgs<ExtArgs>
    vehicles?: boolean | branches$vehiclesArgs<ExtArgs>
    _count?: boolean | BranchesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type branchesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type branchesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $branchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "branches"
    objects: {
      activities: Prisma.$activitiesPayload<ExtArgs>[]
      companies: Prisma.$companiesPayload<ExtArgs>
      gift_cards: Prisma.$gift_cardsPayload<ExtArgs>[]
      invoices: Prisma.$invoicesPayload<ExtArgs>[]
      operators: Prisma.$operatorsPayload<ExtArgs>[]
      packages: Prisma.$packagesPayload<ExtArgs>[]
      plans: Prisma.$plansPayload<ExtArgs>[]
      products: Prisma.$productsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
      vehicles: Prisma.$vehiclesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      name: string
      address: string | null
      province: string | null
      city: string | null
      postal_code: string | null
      phone: string | null
      email: string | null
      is_active: boolean | null
      prefix: string | null
      company_id: string
      manager_name: string | null
      opening_hours: Prisma.JsonValue | null
      timezone: string | null
    }, ExtArgs["result"]["branches"]>
    composites: {}
  }

  type branchesGetPayload<S extends boolean | null | undefined | branchesDefaultArgs> = $Result.GetResult<Prisma.$branchesPayload, S>

  type branchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<branchesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchesCountAggregateInputType | true
    }

  export interface branchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['branches'], meta: { name: 'branches' } }
    /**
     * Find zero or one Branches that matches the filter.
     * @param {branchesFindUniqueArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends branchesFindUniqueArgs>(args: SelectSubset<T, branchesFindUniqueArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branches that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {branchesFindUniqueOrThrowArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends branchesFindUniqueOrThrowArgs>(args: SelectSubset<T, branchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindFirstArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends branchesFindFirstArgs>(args?: SelectSubset<T, branchesFindFirstArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindFirstOrThrowArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends branchesFindFirstOrThrowArgs>(args?: SelectSubset<T, branchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branches.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchesWithIdOnly = await prisma.branches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends branchesFindManyArgs>(args?: SelectSubset<T, branchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branches.
     * @param {branchesCreateArgs} args - Arguments to create a Branches.
     * @example
     * // Create one Branches
     * const Branches = await prisma.branches.create({
     *   data: {
     *     // ... data to create a Branches
     *   }
     * })
     * 
     */
    create<T extends branchesCreateArgs>(args: SelectSubset<T, branchesCreateArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {branchesCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branches = await prisma.branches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends branchesCreateManyArgs>(args?: SelectSubset<T, branchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {branchesCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branches = await prisma.branches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchesWithIdOnly = await prisma.branches.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends branchesCreateManyAndReturnArgs>(args?: SelectSubset<T, branchesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branches.
     * @param {branchesDeleteArgs} args - Arguments to delete one Branches.
     * @example
     * // Delete one Branches
     * const Branches = await prisma.branches.delete({
     *   where: {
     *     // ... filter to delete one Branches
     *   }
     * })
     * 
     */
    delete<T extends branchesDeleteArgs>(args: SelectSubset<T, branchesDeleteArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branches.
     * @param {branchesUpdateArgs} args - Arguments to update one Branches.
     * @example
     * // Update one Branches
     * const branches = await prisma.branches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends branchesUpdateArgs>(args: SelectSubset<T, branchesUpdateArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {branchesDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends branchesDeleteManyArgs>(args?: SelectSubset<T, branchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branches = await prisma.branches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends branchesUpdateManyArgs>(args: SelectSubset<T, branchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {branchesUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branches = await prisma.branches.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchesWithIdOnly = await prisma.branches.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends branchesUpdateManyAndReturnArgs>(args: SelectSubset<T, branchesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branches.
     * @param {branchesUpsertArgs} args - Arguments to update or create a Branches.
     * @example
     * // Update or create a Branches
     * const branches = await prisma.branches.upsert({
     *   create: {
     *     // ... data to create a Branches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branches we want to update
     *   }
     * })
     */
    upsert<T extends branchesUpsertArgs>(args: SelectSubset<T, branchesUpsertArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branches.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends branchesCountArgs>(
      args?: Subset<T, branchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchesAggregateArgs>(args: Subset<T, BranchesAggregateArgs>): Prisma.PrismaPromise<GetBranchesAggregateType<T>>

    /**
     * Group by Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends branchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: branchesGroupByArgs['orderBy'] }
        : { orderBy?: branchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, branchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the branches model
   */
  readonly fields: branchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for branches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__branchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends branches$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, branches$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gift_cards<T extends branches$gift_cardsArgs<ExtArgs> = {}>(args?: Subset<T, branches$gift_cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends branches$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, branches$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operators<T extends branches$operatorsArgs<ExtArgs> = {}>(args?: Subset<T, branches$operatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packages<T extends branches$packagesArgs<ExtArgs> = {}>(args?: Subset<T, branches$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plans<T extends branches$plansArgs<ExtArgs> = {}>(args?: Subset<T, branches$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends branches$productsArgs<ExtArgs> = {}>(args?: Subset<T, branches$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends branches$usersArgs<ExtArgs> = {}>(args?: Subset<T, branches$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicles<T extends branches$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, branches$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the branches model
   */ 
  interface branchesFieldRefs {
    readonly id: FieldRef<"branches", 'String'>
    readonly created_at: FieldRef<"branches", 'DateTime'>
    readonly updated_at: FieldRef<"branches", 'DateTime'>
    readonly name: FieldRef<"branches", 'String'>
    readonly address: FieldRef<"branches", 'String'>
    readonly province: FieldRef<"branches", 'String'>
    readonly city: FieldRef<"branches", 'String'>
    readonly postal_code: FieldRef<"branches", 'String'>
    readonly phone: FieldRef<"branches", 'String'>
    readonly email: FieldRef<"branches", 'String'>
    readonly is_active: FieldRef<"branches", 'Boolean'>
    readonly prefix: FieldRef<"branches", 'String'>
    readonly company_id: FieldRef<"branches", 'String'>
    readonly manager_name: FieldRef<"branches", 'String'>
    readonly opening_hours: FieldRef<"branches", 'Json'>
    readonly timezone: FieldRef<"branches", 'String'>
  }
    

  // Custom InputTypes
  /**
   * branches findUnique
   */
  export type branchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches findUniqueOrThrow
   */
  export type branchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches findFirst
   */
  export type branchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branches.
     */
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches findFirstOrThrow
   */
  export type branchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branches.
     */
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches findMany
   */
  export type branchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches create
   */
  export type branchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The data needed to create a branches.
     */
    data: XOR<branchesCreateInput, branchesUncheckedCreateInput>
  }

  /**
   * branches createMany
   */
  export type branchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many branches.
     */
    data: branchesCreateManyInput | branchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * branches createManyAndReturn
   */
  export type branchesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * The data used to create many branches.
     */
    data: branchesCreateManyInput | branchesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * branches update
   */
  export type branchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The data needed to update a branches.
     */
    data: XOR<branchesUpdateInput, branchesUncheckedUpdateInput>
    /**
     * Choose, which branches to update.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches updateMany
   */
  export type branchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update branches.
     */
    data: XOR<branchesUpdateManyMutationInput, branchesUncheckedUpdateManyInput>
    /**
     * Filter which branches to update
     */
    where?: branchesWhereInput
    /**
     * Limit how many branches to update.
     */
    limit?: number
  }

  /**
   * branches updateManyAndReturn
   */
  export type branchesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * The data used to update branches.
     */
    data: XOR<branchesUpdateManyMutationInput, branchesUncheckedUpdateManyInput>
    /**
     * Filter which branches to update
     */
    where?: branchesWhereInput
    /**
     * Limit how many branches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * branches upsert
   */
  export type branchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The filter to search for the branches to update in case it exists.
     */
    where: branchesWhereUniqueInput
    /**
     * In case the branches found by the `where` argument doesn't exist, create a new branches with this data.
     */
    create: XOR<branchesCreateInput, branchesUncheckedCreateInput>
    /**
     * In case the branches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<branchesUpdateInput, branchesUncheckedUpdateInput>
  }

  /**
   * branches delete
   */
  export type branchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter which branches to delete.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches deleteMany
   */
  export type branchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branches to delete
     */
    where?: branchesWhereInput
    /**
     * Limit how many branches to delete.
     */
    limit?: number
  }

  /**
   * branches.activities
   */
  export type branches$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    where?: activitiesWhereInput
    orderBy?: activitiesOrderByWithRelationInput | activitiesOrderByWithRelationInput[]
    cursor?: activitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivitiesScalarFieldEnum | ActivitiesScalarFieldEnum[]
  }

  /**
   * branches.gift_cards
   */
  export type branches$gift_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    where?: gift_cardsWhereInput
    orderBy?: gift_cardsOrderByWithRelationInput | gift_cardsOrderByWithRelationInput[]
    cursor?: gift_cardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Gift_cardsScalarFieldEnum | Gift_cardsScalarFieldEnum[]
  }

  /**
   * branches.invoices
   */
  export type branches$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    cursor?: invoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * branches.operators
   */
  export type branches$operatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    where?: operatorsWhereInput
    orderBy?: operatorsOrderByWithRelationInput | operatorsOrderByWithRelationInput[]
    cursor?: operatorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorsScalarFieldEnum | OperatorsScalarFieldEnum[]
  }

  /**
   * branches.packages
   */
  export type branches$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    where?: packagesWhereInput
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    cursor?: packagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * branches.plans
   */
  export type branches$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    where?: plansWhereInput
    orderBy?: plansOrderByWithRelationInput | plansOrderByWithRelationInput[]
    cursor?: plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlansScalarFieldEnum | PlansScalarFieldEnum[]
  }

  /**
   * branches.products
   */
  export type branches$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * branches.users
   */
  export type branches$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * branches.vehicles
   */
  export type branches$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    where?: vehiclesWhereInput
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    cursor?: vehiclesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * branches without action
   */
  export type branchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    order_position: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    order_position: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    icon: string | null
    is_active: boolean | null
    order_position: number | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    icon: string | null
    is_active: boolean | null
    order_position: number | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    description: number
    icon: number
    is_active: number
    order_position: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    order_position?: true
  }

  export type CategoriesSumAggregateInputType = {
    order_position?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    icon?: true
    is_active?: true
    order_position?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    icon?: true
    is_active?: true
    order_position?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    icon?: true
    is_active?: true
    order_position?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    name: string
    description: string | null
    icon: string | null
    is_active: boolean | null
    order_position: number | null
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_active?: boolean
    order_position?: boolean
    products?: boolean | categories$productsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_active?: boolean
    order_position?: boolean
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_active?: boolean
    order_position?: boolean
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_active?: boolean
    order_position?: boolean
  }

  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "description" | "icon" | "is_active" | "order_position", ExtArgs["result"]["categories"]>
  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | categories$productsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      products: Prisma.$productsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      name: string
      description: string | null
      icon: string | null
      is_active: boolean | null
      order_position: number | null
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends categories$productsArgs<ExtArgs> = {}>(args?: Subset<T, categories$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */ 
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'String'>
    readonly created_at: FieldRef<"categories", 'DateTime'>
    readonly updated_at: FieldRef<"categories", 'DateTime'>
    readonly name: FieldRef<"categories", 'String'>
    readonly description: FieldRef<"categories", 'String'>
    readonly icon: FieldRef<"categories", 'String'>
    readonly is_active: FieldRef<"categories", 'Boolean'>
    readonly order_position: FieldRef<"categories", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories createManyAndReturn
   */
  export type categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories updateManyAndReturn
   */
  export type categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * categories.products
   */
  export type categories$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    email: string | null
    phone: string | null
    ruc: string | null
    logo_url: string | null
    website: string | null
    tax_id: string | null
    business_type: string | null
    industry: string | null
    founded_date: Date | null
    is_active: boolean | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    email: string | null
    phone: string | null
    ruc: string | null
    logo_url: string | null
    website: string | null
    tax_id: string | null
    business_type: string | null
    industry: string | null
    founded_date: Date | null
    is_active: boolean | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    email: number
    phone: number
    ruc: number
    logo_url: number
    website: number
    tax_id: number
    business_type: number
    industry: number
    founded_date: number
    is_active: number
    _all: number
  }


  export type CompaniesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    email?: true
    phone?: true
    ruc?: true
    logo_url?: true
    website?: true
    tax_id?: true
    business_type?: true
    industry?: true
    founded_date?: true
    is_active?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    email?: true
    phone?: true
    ruc?: true
    logo_url?: true
    website?: true
    tax_id?: true
    business_type?: true
    industry?: true
    founded_date?: true
    is_active?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    email?: true
    phone?: true
    ruc?: true
    logo_url?: true
    website?: true
    tax_id?: true
    business_type?: true
    industry?: true
    founded_date?: true
    is_active?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    name: string
    email: string | null
    phone: string | null
    ruc: string | null
    logo_url: string | null
    website: string | null
    tax_id: string | null
    business_type: string | null
    industry: string | null
    founded_date: Date | null
    is_active: boolean | null
    _count: CompaniesCountAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    ruc?: boolean
    logo_url?: boolean
    website?: boolean
    tax_id?: boolean
    business_type?: boolean
    industry?: boolean
    founded_date?: boolean
    is_active?: boolean
    branches?: boolean | companies$branchesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    ruc?: boolean
    logo_url?: boolean
    website?: boolean
    tax_id?: boolean
    business_type?: boolean
    industry?: boolean
    founded_date?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    ruc?: boolean
    logo_url?: boolean
    website?: boolean
    tax_id?: boolean
    business_type?: boolean
    industry?: boolean
    founded_date?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    ruc?: boolean
    logo_url?: boolean
    website?: boolean
    tax_id?: boolean
    business_type?: boolean
    industry?: boolean
    founded_date?: boolean
    is_active?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "email" | "phone" | "ruc" | "logo_url" | "website" | "tax_id" | "business_type" | "industry" | "founded_date" | "is_active", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | companies$branchesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type companiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      branches: Prisma.$branchesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      name: string
      email: string | null
      phone: string | null
      ruc: string | null
      logo_url: string | null
      website: string | null
      tax_id: string | null
      business_type: string | null
      industry: string | null
      founded_date: Date | null
      is_active: boolean | null
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companiesCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companiesCreateManyAndReturnArgs>(args?: SelectSubset<T, companiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companiesUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companiesUpdateManyAndReturnArgs>(args: SelectSubset<T, companiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends companies$branchesArgs<ExtArgs> = {}>(args?: Subset<T, companies$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */ 
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'String'>
    readonly created_at: FieldRef<"companies", 'DateTime'>
    readonly updated_at: FieldRef<"companies", 'DateTime'>
    readonly name: FieldRef<"companies", 'String'>
    readonly email: FieldRef<"companies", 'String'>
    readonly phone: FieldRef<"companies", 'String'>
    readonly ruc: FieldRef<"companies", 'String'>
    readonly logo_url: FieldRef<"companies", 'String'>
    readonly website: FieldRef<"companies", 'String'>
    readonly tax_id: FieldRef<"companies", 'String'>
    readonly business_type: FieldRef<"companies", 'String'>
    readonly industry: FieldRef<"companies", 'String'>
    readonly founded_date: FieldRef<"companies", 'DateTime'>
    readonly is_active: FieldRef<"companies", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies createManyAndReturn
   */
  export type companiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies updateManyAndReturn
   */
  export type companiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.branches
   */
  export type companies$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    cursor?: branchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model email_campaigns
   */

  export type AggregateEmail_campaigns = {
    _count: Email_campaignsCountAggregateOutputType | null
    _min: Email_campaignsMinAggregateOutputType | null
    _max: Email_campaignsMaxAggregateOutputType | null
  }

  export type Email_campaignsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    subject: string | null
    status: string | null
    send_to_all: boolean | null
    tracking: boolean | null
    tracking_id: string | null
    user_id: string | null
    template_id: string | null
    scheduled_for: Date | null
    sender_name: string | null
    sender_email: string | null
    reply_to: string | null
    is_recurring: boolean | null
  }

  export type Email_campaignsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    subject: string | null
    status: string | null
    send_to_all: boolean | null
    tracking: boolean | null
    tracking_id: string | null
    user_id: string | null
    template_id: string | null
    scheduled_for: Date | null
    sender_name: string | null
    sender_email: string | null
    reply_to: string | null
    is_recurring: boolean | null
  }

  export type Email_campaignsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    subject: number
    status: number
    recipients: number
    send_to_all: number
    tracking: number
    tracking_id: number
    stats: number
    user_id: number
    template_id: number
    scheduled_for: number
    sender_name: number
    sender_email: number
    reply_to: number
    segment_criteria: number
    test_recipients: number
    is_recurring: number
    recurrence_pattern: number
    _all: number
  }


  export type Email_campaignsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    subject?: true
    status?: true
    send_to_all?: true
    tracking?: true
    tracking_id?: true
    user_id?: true
    template_id?: true
    scheduled_for?: true
    sender_name?: true
    sender_email?: true
    reply_to?: true
    is_recurring?: true
  }

  export type Email_campaignsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    subject?: true
    status?: true
    send_to_all?: true
    tracking?: true
    tracking_id?: true
    user_id?: true
    template_id?: true
    scheduled_for?: true
    sender_name?: true
    sender_email?: true
    reply_to?: true
    is_recurring?: true
  }

  export type Email_campaignsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    subject?: true
    status?: true
    recipients?: true
    send_to_all?: true
    tracking?: true
    tracking_id?: true
    stats?: true
    user_id?: true
    template_id?: true
    scheduled_for?: true
    sender_name?: true
    sender_email?: true
    reply_to?: true
    segment_criteria?: true
    test_recipients?: true
    is_recurring?: true
    recurrence_pattern?: true
    _all?: true
  }

  export type Email_campaignsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_campaigns to aggregate.
     */
    where?: email_campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_campaigns to fetch.
     */
    orderBy?: email_campaignsOrderByWithRelationInput | email_campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: email_campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_campaigns
    **/
    _count?: true | Email_campaignsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Email_campaignsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Email_campaignsMaxAggregateInputType
  }

  export type GetEmail_campaignsAggregateType<T extends Email_campaignsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail_campaigns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_campaigns[P]>
      : GetScalarType<T[P], AggregateEmail_campaigns[P]>
  }




  export type email_campaignsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_campaignsWhereInput
    orderBy?: email_campaignsOrderByWithAggregationInput | email_campaignsOrderByWithAggregationInput[]
    by: Email_campaignsScalarFieldEnum[] | Email_campaignsScalarFieldEnum
    having?: email_campaignsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Email_campaignsCountAggregateInputType | true
    _min?: Email_campaignsMinAggregateInputType
    _max?: Email_campaignsMaxAggregateInputType
  }

  export type Email_campaignsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    name: string
    subject: string
    status: string
    recipients: JsonValue | null
    send_to_all: boolean | null
    tracking: boolean | null
    tracking_id: string | null
    stats: JsonValue | null
    user_id: string | null
    template_id: string | null
    scheduled_for: Date | null
    sender_name: string | null
    sender_email: string | null
    reply_to: string | null
    segment_criteria: JsonValue | null
    test_recipients: string[]
    is_recurring: boolean | null
    recurrence_pattern: JsonValue | null
    _count: Email_campaignsCountAggregateOutputType | null
    _min: Email_campaignsMinAggregateOutputType | null
    _max: Email_campaignsMaxAggregateOutputType | null
  }

  type GetEmail_campaignsGroupByPayload<T extends email_campaignsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Email_campaignsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Email_campaignsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Email_campaignsGroupByOutputType[P]>
            : GetScalarType<T[P], Email_campaignsGroupByOutputType[P]>
        }
      >
    >


  export type email_campaignsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    subject?: boolean
    status?: boolean
    recipients?: boolean
    send_to_all?: boolean
    tracking?: boolean
    tracking_id?: boolean
    stats?: boolean
    user_id?: boolean
    template_id?: boolean
    scheduled_for?: boolean
    sender_name?: boolean
    sender_email?: boolean
    reply_to?: boolean
    segment_criteria?: boolean
    test_recipients?: boolean
    is_recurring?: boolean
    recurrence_pattern?: boolean
    email_templates?: boolean | email_campaigns$email_templatesArgs<ExtArgs>
    users?: boolean | email_campaigns$usersArgs<ExtArgs>
  }, ExtArgs["result"]["email_campaigns"]>

  export type email_campaignsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    subject?: boolean
    status?: boolean
    recipients?: boolean
    send_to_all?: boolean
    tracking?: boolean
    tracking_id?: boolean
    stats?: boolean
    user_id?: boolean
    template_id?: boolean
    scheduled_for?: boolean
    sender_name?: boolean
    sender_email?: boolean
    reply_to?: boolean
    segment_criteria?: boolean
    test_recipients?: boolean
    is_recurring?: boolean
    recurrence_pattern?: boolean
    email_templates?: boolean | email_campaigns$email_templatesArgs<ExtArgs>
    users?: boolean | email_campaigns$usersArgs<ExtArgs>
  }, ExtArgs["result"]["email_campaigns"]>

  export type email_campaignsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    subject?: boolean
    status?: boolean
    recipients?: boolean
    send_to_all?: boolean
    tracking?: boolean
    tracking_id?: boolean
    stats?: boolean
    user_id?: boolean
    template_id?: boolean
    scheduled_for?: boolean
    sender_name?: boolean
    sender_email?: boolean
    reply_to?: boolean
    segment_criteria?: boolean
    test_recipients?: boolean
    is_recurring?: boolean
    recurrence_pattern?: boolean
    email_templates?: boolean | email_campaigns$email_templatesArgs<ExtArgs>
    users?: boolean | email_campaigns$usersArgs<ExtArgs>
  }, ExtArgs["result"]["email_campaigns"]>

  export type email_campaignsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    subject?: boolean
    status?: boolean
    recipients?: boolean
    send_to_all?: boolean
    tracking?: boolean
    tracking_id?: boolean
    stats?: boolean
    user_id?: boolean
    template_id?: boolean
    scheduled_for?: boolean
    sender_name?: boolean
    sender_email?: boolean
    reply_to?: boolean
    segment_criteria?: boolean
    test_recipients?: boolean
    is_recurring?: boolean
    recurrence_pattern?: boolean
  }

  export type email_campaignsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "subject" | "status" | "recipients" | "send_to_all" | "tracking" | "tracking_id" | "stats" | "user_id" | "template_id" | "scheduled_for" | "sender_name" | "sender_email" | "reply_to" | "segment_criteria" | "test_recipients" | "is_recurring" | "recurrence_pattern", ExtArgs["result"]["email_campaigns"]>
  export type email_campaignsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email_templates?: boolean | email_campaigns$email_templatesArgs<ExtArgs>
    users?: boolean | email_campaigns$usersArgs<ExtArgs>
  }
  export type email_campaignsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email_templates?: boolean | email_campaigns$email_templatesArgs<ExtArgs>
    users?: boolean | email_campaigns$usersArgs<ExtArgs>
  }
  export type email_campaignsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email_templates?: boolean | email_campaigns$email_templatesArgs<ExtArgs>
    users?: boolean | email_campaigns$usersArgs<ExtArgs>
  }

  export type $email_campaignsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email_campaigns"
    objects: {
      email_templates: Prisma.$email_templatesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      name: string
      subject: string
      status: string
      recipients: Prisma.JsonValue | null
      send_to_all: boolean | null
      tracking: boolean | null
      tracking_id: string | null
      stats: Prisma.JsonValue | null
      user_id: string | null
      template_id: string | null
      scheduled_for: Date | null
      sender_name: string | null
      sender_email: string | null
      reply_to: string | null
      segment_criteria: Prisma.JsonValue | null
      test_recipients: string[]
      is_recurring: boolean | null
      recurrence_pattern: Prisma.JsonValue | null
    }, ExtArgs["result"]["email_campaigns"]>
    composites: {}
  }

  type email_campaignsGetPayload<S extends boolean | null | undefined | email_campaignsDefaultArgs> = $Result.GetResult<Prisma.$email_campaignsPayload, S>

  type email_campaignsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<email_campaignsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Email_campaignsCountAggregateInputType | true
    }

  export interface email_campaignsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email_campaigns'], meta: { name: 'email_campaigns' } }
    /**
     * Find zero or one Email_campaigns that matches the filter.
     * @param {email_campaignsFindUniqueArgs} args - Arguments to find a Email_campaigns
     * @example
     * // Get one Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends email_campaignsFindUniqueArgs>(args: SelectSubset<T, email_campaignsFindUniqueArgs<ExtArgs>>): Prisma__email_campaignsClient<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email_campaigns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {email_campaignsFindUniqueOrThrowArgs} args - Arguments to find a Email_campaigns
     * @example
     * // Get one Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends email_campaignsFindUniqueOrThrowArgs>(args: SelectSubset<T, email_campaignsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__email_campaignsClient<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_campaignsFindFirstArgs} args - Arguments to find a Email_campaigns
     * @example
     * // Get one Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends email_campaignsFindFirstArgs>(args?: SelectSubset<T, email_campaignsFindFirstArgs<ExtArgs>>): Prisma__email_campaignsClient<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_campaigns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_campaignsFindFirstOrThrowArgs} args - Arguments to find a Email_campaigns
     * @example
     * // Get one Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends email_campaignsFindFirstOrThrowArgs>(args?: SelectSubset<T, email_campaignsFindFirstOrThrowArgs<ExtArgs>>): Prisma__email_campaignsClient<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Email_campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_campaignsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.findMany()
     * 
     * // Get first 10 Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const email_campaignsWithIdOnly = await prisma.email_campaigns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends email_campaignsFindManyArgs>(args?: SelectSubset<T, email_campaignsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email_campaigns.
     * @param {email_campaignsCreateArgs} args - Arguments to create a Email_campaigns.
     * @example
     * // Create one Email_campaigns
     * const Email_campaigns = await prisma.email_campaigns.create({
     *   data: {
     *     // ... data to create a Email_campaigns
     *   }
     * })
     * 
     */
    create<T extends email_campaignsCreateArgs>(args: SelectSubset<T, email_campaignsCreateArgs<ExtArgs>>): Prisma__email_campaignsClient<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Email_campaigns.
     * @param {email_campaignsCreateManyArgs} args - Arguments to create many Email_campaigns.
     * @example
     * // Create many Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends email_campaignsCreateManyArgs>(args?: SelectSubset<T, email_campaignsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Email_campaigns and returns the data saved in the database.
     * @param {email_campaignsCreateManyAndReturnArgs} args - Arguments to create many Email_campaigns.
     * @example
     * // Create many Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Email_campaigns and only return the `id`
     * const email_campaignsWithIdOnly = await prisma.email_campaigns.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends email_campaignsCreateManyAndReturnArgs>(args?: SelectSubset<T, email_campaignsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email_campaigns.
     * @param {email_campaignsDeleteArgs} args - Arguments to delete one Email_campaigns.
     * @example
     * // Delete one Email_campaigns
     * const Email_campaigns = await prisma.email_campaigns.delete({
     *   where: {
     *     // ... filter to delete one Email_campaigns
     *   }
     * })
     * 
     */
    delete<T extends email_campaignsDeleteArgs>(args: SelectSubset<T, email_campaignsDeleteArgs<ExtArgs>>): Prisma__email_campaignsClient<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email_campaigns.
     * @param {email_campaignsUpdateArgs} args - Arguments to update one Email_campaigns.
     * @example
     * // Update one Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends email_campaignsUpdateArgs>(args: SelectSubset<T, email_campaignsUpdateArgs<ExtArgs>>): Prisma__email_campaignsClient<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Email_campaigns.
     * @param {email_campaignsDeleteManyArgs} args - Arguments to filter Email_campaigns to delete.
     * @example
     * // Delete a few Email_campaigns
     * const { count } = await prisma.email_campaigns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends email_campaignsDeleteManyArgs>(args?: SelectSubset<T, email_campaignsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_campaignsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends email_campaignsUpdateManyArgs>(args: SelectSubset<T, email_campaignsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_campaigns and returns the data updated in the database.
     * @param {email_campaignsUpdateManyAndReturnArgs} args - Arguments to update many Email_campaigns.
     * @example
     * // Update many Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Email_campaigns and only return the `id`
     * const email_campaignsWithIdOnly = await prisma.email_campaigns.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends email_campaignsUpdateManyAndReturnArgs>(args: SelectSubset<T, email_campaignsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email_campaigns.
     * @param {email_campaignsUpsertArgs} args - Arguments to update or create a Email_campaigns.
     * @example
     * // Update or create a Email_campaigns
     * const email_campaigns = await prisma.email_campaigns.upsert({
     *   create: {
     *     // ... data to create a Email_campaigns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_campaigns we want to update
     *   }
     * })
     */
    upsert<T extends email_campaignsUpsertArgs>(args: SelectSubset<T, email_campaignsUpsertArgs<ExtArgs>>): Prisma__email_campaignsClient<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Email_campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_campaignsCountArgs} args - Arguments to filter Email_campaigns to count.
     * @example
     * // Count the number of Email_campaigns
     * const count = await prisma.email_campaigns.count({
     *   where: {
     *     // ... the filter for the Email_campaigns we want to count
     *   }
     * })
    **/
    count<T extends email_campaignsCountArgs>(
      args?: Subset<T, email_campaignsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_campaignsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Email_campaignsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_campaignsAggregateArgs>(args: Subset<T, Email_campaignsAggregateArgs>): Prisma.PrismaPromise<GetEmail_campaignsAggregateType<T>>

    /**
     * Group by Email_campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_campaignsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends email_campaignsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: email_campaignsGroupByArgs['orderBy'] }
        : { orderBy?: email_campaignsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, email_campaignsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmail_campaignsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email_campaigns model
   */
  readonly fields: email_campaignsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email_campaigns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__email_campaignsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email_templates<T extends email_campaigns$email_templatesArgs<ExtArgs> = {}>(args?: Subset<T, email_campaigns$email_templatesArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends email_campaigns$usersArgs<ExtArgs> = {}>(args?: Subset<T, email_campaigns$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email_campaigns model
   */ 
  interface email_campaignsFieldRefs {
    readonly id: FieldRef<"email_campaigns", 'String'>
    readonly created_at: FieldRef<"email_campaigns", 'DateTime'>
    readonly updated_at: FieldRef<"email_campaigns", 'DateTime'>
    readonly name: FieldRef<"email_campaigns", 'String'>
    readonly subject: FieldRef<"email_campaigns", 'String'>
    readonly status: FieldRef<"email_campaigns", 'String'>
    readonly recipients: FieldRef<"email_campaigns", 'Json'>
    readonly send_to_all: FieldRef<"email_campaigns", 'Boolean'>
    readonly tracking: FieldRef<"email_campaigns", 'Boolean'>
    readonly tracking_id: FieldRef<"email_campaigns", 'String'>
    readonly stats: FieldRef<"email_campaigns", 'Json'>
    readonly user_id: FieldRef<"email_campaigns", 'String'>
    readonly template_id: FieldRef<"email_campaigns", 'String'>
    readonly scheduled_for: FieldRef<"email_campaigns", 'DateTime'>
    readonly sender_name: FieldRef<"email_campaigns", 'String'>
    readonly sender_email: FieldRef<"email_campaigns", 'String'>
    readonly reply_to: FieldRef<"email_campaigns", 'String'>
    readonly segment_criteria: FieldRef<"email_campaigns", 'Json'>
    readonly test_recipients: FieldRef<"email_campaigns", 'String[]'>
    readonly is_recurring: FieldRef<"email_campaigns", 'Boolean'>
    readonly recurrence_pattern: FieldRef<"email_campaigns", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * email_campaigns findUnique
   */
  export type email_campaignsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * Filter, which email_campaigns to fetch.
     */
    where: email_campaignsWhereUniqueInput
  }

  /**
   * email_campaigns findUniqueOrThrow
   */
  export type email_campaignsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * Filter, which email_campaigns to fetch.
     */
    where: email_campaignsWhereUniqueInput
  }

  /**
   * email_campaigns findFirst
   */
  export type email_campaignsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * Filter, which email_campaigns to fetch.
     */
    where?: email_campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_campaigns to fetch.
     */
    orderBy?: email_campaignsOrderByWithRelationInput | email_campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_campaigns.
     */
    cursor?: email_campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_campaigns.
     */
    distinct?: Email_campaignsScalarFieldEnum | Email_campaignsScalarFieldEnum[]
  }

  /**
   * email_campaigns findFirstOrThrow
   */
  export type email_campaignsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * Filter, which email_campaigns to fetch.
     */
    where?: email_campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_campaigns to fetch.
     */
    orderBy?: email_campaignsOrderByWithRelationInput | email_campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_campaigns.
     */
    cursor?: email_campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_campaigns.
     */
    distinct?: Email_campaignsScalarFieldEnum | Email_campaignsScalarFieldEnum[]
  }

  /**
   * email_campaigns findMany
   */
  export type email_campaignsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * Filter, which email_campaigns to fetch.
     */
    where?: email_campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_campaigns to fetch.
     */
    orderBy?: email_campaignsOrderByWithRelationInput | email_campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_campaigns.
     */
    cursor?: email_campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_campaigns.
     */
    skip?: number
    distinct?: Email_campaignsScalarFieldEnum | Email_campaignsScalarFieldEnum[]
  }

  /**
   * email_campaigns create
   */
  export type email_campaignsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * The data needed to create a email_campaigns.
     */
    data: XOR<email_campaignsCreateInput, email_campaignsUncheckedCreateInput>
  }

  /**
   * email_campaigns createMany
   */
  export type email_campaignsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many email_campaigns.
     */
    data: email_campaignsCreateManyInput | email_campaignsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_campaigns createManyAndReturn
   */
  export type email_campaignsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * The data used to create many email_campaigns.
     */
    data: email_campaignsCreateManyInput | email_campaignsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * email_campaigns update
   */
  export type email_campaignsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * The data needed to update a email_campaigns.
     */
    data: XOR<email_campaignsUpdateInput, email_campaignsUncheckedUpdateInput>
    /**
     * Choose, which email_campaigns to update.
     */
    where: email_campaignsWhereUniqueInput
  }

  /**
   * email_campaigns updateMany
   */
  export type email_campaignsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update email_campaigns.
     */
    data: XOR<email_campaignsUpdateManyMutationInput, email_campaignsUncheckedUpdateManyInput>
    /**
     * Filter which email_campaigns to update
     */
    where?: email_campaignsWhereInput
    /**
     * Limit how many email_campaigns to update.
     */
    limit?: number
  }

  /**
   * email_campaigns updateManyAndReturn
   */
  export type email_campaignsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * The data used to update email_campaigns.
     */
    data: XOR<email_campaignsUpdateManyMutationInput, email_campaignsUncheckedUpdateManyInput>
    /**
     * Filter which email_campaigns to update
     */
    where?: email_campaignsWhereInput
    /**
     * Limit how many email_campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * email_campaigns upsert
   */
  export type email_campaignsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * The filter to search for the email_campaigns to update in case it exists.
     */
    where: email_campaignsWhereUniqueInput
    /**
     * In case the email_campaigns found by the `where` argument doesn't exist, create a new email_campaigns with this data.
     */
    create: XOR<email_campaignsCreateInput, email_campaignsUncheckedCreateInput>
    /**
     * In case the email_campaigns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<email_campaignsUpdateInput, email_campaignsUncheckedUpdateInput>
  }

  /**
   * email_campaigns delete
   */
  export type email_campaignsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    /**
     * Filter which email_campaigns to delete.
     */
    where: email_campaignsWhereUniqueInput
  }

  /**
   * email_campaigns deleteMany
   */
  export type email_campaignsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_campaigns to delete
     */
    where?: email_campaignsWhereInput
    /**
     * Limit how many email_campaigns to delete.
     */
    limit?: number
  }

  /**
   * email_campaigns.email_templates
   */
  export type email_campaigns$email_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    where?: email_templatesWhereInput
  }

  /**
   * email_campaigns.users
   */
  export type email_campaigns$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * email_campaigns without action
   */
  export type email_campaignsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
  }


  /**
   * Model email_templates
   */

  export type AggregateEmail_templates = {
    _count: Email_templatesCountAggregateOutputType | null
    _avg: Email_templatesAvgAggregateOutputType | null
    _sum: Email_templatesSumAggregateOutputType | null
    _min: Email_templatesMinAggregateOutputType | null
    _max: Email_templatesMaxAggregateOutputType | null
  }

  export type Email_templatesAvgAggregateOutputType = {
    version: number | null
  }

  export type Email_templatesSumAggregateOutputType = {
    version: number | null
  }

  export type Email_templatesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    subject: string | null
    body: string | null
    html_body: string | null
    thumbnail: string | null
    operator_id: string | null
    category: string | null
    is_default: boolean | null
    version: number | null
  }

  export type Email_templatesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    subject: string | null
    body: string | null
    html_body: string | null
    thumbnail: string | null
    operator_id: string | null
    category: string | null
    is_default: boolean | null
    version: number | null
  }

  export type Email_templatesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    subject: number
    body: number
    html_body: number
    elements: number
    editor_settings: number
    thumbnail: number
    operator_id: number
    category: number
    variables: number
    is_default: number
    version: number
    _all: number
  }


  export type Email_templatesAvgAggregateInputType = {
    version?: true
  }

  export type Email_templatesSumAggregateInputType = {
    version?: true
  }

  export type Email_templatesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    subject?: true
    body?: true
    html_body?: true
    thumbnail?: true
    operator_id?: true
    category?: true
    is_default?: true
    version?: true
  }

  export type Email_templatesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    subject?: true
    body?: true
    html_body?: true
    thumbnail?: true
    operator_id?: true
    category?: true
    is_default?: true
    version?: true
  }

  export type Email_templatesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    subject?: true
    body?: true
    html_body?: true
    elements?: true
    editor_settings?: true
    thumbnail?: true
    operator_id?: true
    category?: true
    variables?: true
    is_default?: true
    version?: true
    _all?: true
  }

  export type Email_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_templates to aggregate.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_templates
    **/
    _count?: true | Email_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Email_templatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Email_templatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Email_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Email_templatesMaxAggregateInputType
  }

  export type GetEmail_templatesAggregateType<T extends Email_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_templates[P]>
      : GetScalarType<T[P], AggregateEmail_templates[P]>
  }




  export type email_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_templatesWhereInput
    orderBy?: email_templatesOrderByWithAggregationInput | email_templatesOrderByWithAggregationInput[]
    by: Email_templatesScalarFieldEnum[] | Email_templatesScalarFieldEnum
    having?: email_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Email_templatesCountAggregateInputType | true
    _avg?: Email_templatesAvgAggregateInputType
    _sum?: Email_templatesSumAggregateInputType
    _min?: Email_templatesMinAggregateInputType
    _max?: Email_templatesMaxAggregateInputType
  }

  export type Email_templatesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    name: string
    subject: string | null
    body: string | null
    html_body: string | null
    elements: JsonValue | null
    editor_settings: JsonValue | null
    thumbnail: string | null
    operator_id: string | null
    category: string | null
    variables: JsonValue | null
    is_default: boolean | null
    version: number | null
    _count: Email_templatesCountAggregateOutputType | null
    _avg: Email_templatesAvgAggregateOutputType | null
    _sum: Email_templatesSumAggregateOutputType | null
    _min: Email_templatesMinAggregateOutputType | null
    _max: Email_templatesMaxAggregateOutputType | null
  }

  type GetEmail_templatesGroupByPayload<T extends email_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Email_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Email_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Email_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Email_templatesGroupByOutputType[P]>
        }
      >
    >


  export type email_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    html_body?: boolean
    elements?: boolean
    editor_settings?: boolean
    thumbnail?: boolean
    operator_id?: boolean
    category?: boolean
    variables?: boolean
    is_default?: boolean
    version?: boolean
    email_campaigns?: boolean | email_templates$email_campaignsArgs<ExtArgs>
    operators?: boolean | email_templates$operatorsArgs<ExtArgs>
    _count?: boolean | Email_templatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    html_body?: boolean
    elements?: boolean
    editor_settings?: boolean
    thumbnail?: boolean
    operator_id?: boolean
    category?: boolean
    variables?: boolean
    is_default?: boolean
    version?: boolean
    operators?: boolean | email_templates$operatorsArgs<ExtArgs>
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    html_body?: boolean
    elements?: boolean
    editor_settings?: boolean
    thumbnail?: boolean
    operator_id?: boolean
    category?: boolean
    variables?: boolean
    is_default?: boolean
    version?: boolean
    operators?: boolean | email_templates$operatorsArgs<ExtArgs>
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    html_body?: boolean
    elements?: boolean
    editor_settings?: boolean
    thumbnail?: boolean
    operator_id?: boolean
    category?: boolean
    variables?: boolean
    is_default?: boolean
    version?: boolean
  }

  export type email_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "subject" | "body" | "html_body" | "elements" | "editor_settings" | "thumbnail" | "operator_id" | "category" | "variables" | "is_default" | "version", ExtArgs["result"]["email_templates"]>
  export type email_templatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email_campaigns?: boolean | email_templates$email_campaignsArgs<ExtArgs>
    operators?: boolean | email_templates$operatorsArgs<ExtArgs>
    _count?: boolean | Email_templatesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type email_templatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operators?: boolean | email_templates$operatorsArgs<ExtArgs>
  }
  export type email_templatesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operators?: boolean | email_templates$operatorsArgs<ExtArgs>
  }

  export type $email_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email_templates"
    objects: {
      email_campaigns: Prisma.$email_campaignsPayload<ExtArgs>[]
      operators: Prisma.$operatorsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      name: string
      subject: string | null
      body: string | null
      html_body: string | null
      elements: Prisma.JsonValue | null
      editor_settings: Prisma.JsonValue | null
      thumbnail: string | null
      operator_id: string | null
      category: string | null
      variables: Prisma.JsonValue | null
      is_default: boolean | null
      version: number | null
    }, ExtArgs["result"]["email_templates"]>
    composites: {}
  }

  type email_templatesGetPayload<S extends boolean | null | undefined | email_templatesDefaultArgs> = $Result.GetResult<Prisma.$email_templatesPayload, S>

  type email_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<email_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Email_templatesCountAggregateInputType | true
    }

  export interface email_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email_templates'], meta: { name: 'email_templates' } }
    /**
     * Find zero or one Email_templates that matches the filter.
     * @param {email_templatesFindUniqueArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends email_templatesFindUniqueArgs>(args: SelectSubset<T, email_templatesFindUniqueArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {email_templatesFindUniqueOrThrowArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends email_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, email_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindFirstArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends email_templatesFindFirstArgs>(args?: SelectSubset<T, email_templatesFindFirstArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindFirstOrThrowArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends email_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, email_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Email_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_templates
     * const email_templates = await prisma.email_templates.findMany()
     * 
     * // Get first 10 Email_templates
     * const email_templates = await prisma.email_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends email_templatesFindManyArgs>(args?: SelectSubset<T, email_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email_templates.
     * @param {email_templatesCreateArgs} args - Arguments to create a Email_templates.
     * @example
     * // Create one Email_templates
     * const Email_templates = await prisma.email_templates.create({
     *   data: {
     *     // ... data to create a Email_templates
     *   }
     * })
     * 
     */
    create<T extends email_templatesCreateArgs>(args: SelectSubset<T, email_templatesCreateArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Email_templates.
     * @param {email_templatesCreateManyArgs} args - Arguments to create many Email_templates.
     * @example
     * // Create many Email_templates
     * const email_templates = await prisma.email_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends email_templatesCreateManyArgs>(args?: SelectSubset<T, email_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Email_templates and returns the data saved in the database.
     * @param {email_templatesCreateManyAndReturnArgs} args - Arguments to create many Email_templates.
     * @example
     * // Create many Email_templates
     * const email_templates = await prisma.email_templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Email_templates and only return the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends email_templatesCreateManyAndReturnArgs>(args?: SelectSubset<T, email_templatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email_templates.
     * @param {email_templatesDeleteArgs} args - Arguments to delete one Email_templates.
     * @example
     * // Delete one Email_templates
     * const Email_templates = await prisma.email_templates.delete({
     *   where: {
     *     // ... filter to delete one Email_templates
     *   }
     * })
     * 
     */
    delete<T extends email_templatesDeleteArgs>(args: SelectSubset<T, email_templatesDeleteArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email_templates.
     * @param {email_templatesUpdateArgs} args - Arguments to update one Email_templates.
     * @example
     * // Update one Email_templates
     * const email_templates = await prisma.email_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends email_templatesUpdateArgs>(args: SelectSubset<T, email_templatesUpdateArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Email_templates.
     * @param {email_templatesDeleteManyArgs} args - Arguments to filter Email_templates to delete.
     * @example
     * // Delete a few Email_templates
     * const { count } = await prisma.email_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends email_templatesDeleteManyArgs>(args?: SelectSubset<T, email_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_templates
     * const email_templates = await prisma.email_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends email_templatesUpdateManyArgs>(args: SelectSubset<T, email_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_templates and returns the data updated in the database.
     * @param {email_templatesUpdateManyAndReturnArgs} args - Arguments to update many Email_templates.
     * @example
     * // Update many Email_templates
     * const email_templates = await prisma.email_templates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Email_templates and only return the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends email_templatesUpdateManyAndReturnArgs>(args: SelectSubset<T, email_templatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email_templates.
     * @param {email_templatesUpsertArgs} args - Arguments to update or create a Email_templates.
     * @example
     * // Update or create a Email_templates
     * const email_templates = await prisma.email_templates.upsert({
     *   create: {
     *     // ... data to create a Email_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_templates we want to update
     *   }
     * })
     */
    upsert<T extends email_templatesUpsertArgs>(args: SelectSubset<T, email_templatesUpsertArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesCountArgs} args - Arguments to filter Email_templates to count.
     * @example
     * // Count the number of Email_templates
     * const count = await prisma.email_templates.count({
     *   where: {
     *     // ... the filter for the Email_templates we want to count
     *   }
     * })
    **/
    count<T extends email_templatesCountArgs>(
      args?: Subset<T, email_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Email_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_templatesAggregateArgs>(args: Subset<T, Email_templatesAggregateArgs>): Prisma.PrismaPromise<GetEmail_templatesAggregateType<T>>

    /**
     * Group by Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends email_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: email_templatesGroupByArgs['orderBy'] }
        : { orderBy?: email_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, email_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmail_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email_templates model
   */
  readonly fields: email_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__email_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email_campaigns<T extends email_templates$email_campaignsArgs<ExtArgs> = {}>(args?: Subset<T, email_templates$email_campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operators<T extends email_templates$operatorsArgs<ExtArgs> = {}>(args?: Subset<T, email_templates$operatorsArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email_templates model
   */ 
  interface email_templatesFieldRefs {
    readonly id: FieldRef<"email_templates", 'String'>
    readonly created_at: FieldRef<"email_templates", 'DateTime'>
    readonly updated_at: FieldRef<"email_templates", 'DateTime'>
    readonly name: FieldRef<"email_templates", 'String'>
    readonly subject: FieldRef<"email_templates", 'String'>
    readonly body: FieldRef<"email_templates", 'String'>
    readonly html_body: FieldRef<"email_templates", 'String'>
    readonly elements: FieldRef<"email_templates", 'Json'>
    readonly editor_settings: FieldRef<"email_templates", 'Json'>
    readonly thumbnail: FieldRef<"email_templates", 'String'>
    readonly operator_id: FieldRef<"email_templates", 'String'>
    readonly category: FieldRef<"email_templates", 'String'>
    readonly variables: FieldRef<"email_templates", 'Json'>
    readonly is_default: FieldRef<"email_templates", 'Boolean'>
    readonly version: FieldRef<"email_templates", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * email_templates findUnique
   */
  export type email_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates findUniqueOrThrow
   */
  export type email_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates findFirst
   */
  export type email_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_templates.
     */
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates findFirstOrThrow
   */
  export type email_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_templates.
     */
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates findMany
   */
  export type email_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates create
   */
  export type email_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * The data needed to create a email_templates.
     */
    data: XOR<email_templatesCreateInput, email_templatesUncheckedCreateInput>
  }

  /**
   * email_templates createMany
   */
  export type email_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many email_templates.
     */
    data: email_templatesCreateManyInput | email_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_templates createManyAndReturn
   */
  export type email_templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data used to create many email_templates.
     */
    data: email_templatesCreateManyInput | email_templatesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * email_templates update
   */
  export type email_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * The data needed to update a email_templates.
     */
    data: XOR<email_templatesUpdateInput, email_templatesUncheckedUpdateInput>
    /**
     * Choose, which email_templates to update.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates updateMany
   */
  export type email_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update email_templates.
     */
    data: XOR<email_templatesUpdateManyMutationInput, email_templatesUncheckedUpdateManyInput>
    /**
     * Filter which email_templates to update
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to update.
     */
    limit?: number
  }

  /**
   * email_templates updateManyAndReturn
   */
  export type email_templatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data used to update email_templates.
     */
    data: XOR<email_templatesUpdateManyMutationInput, email_templatesUncheckedUpdateManyInput>
    /**
     * Filter which email_templates to update
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * email_templates upsert
   */
  export type email_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * The filter to search for the email_templates to update in case it exists.
     */
    where: email_templatesWhereUniqueInput
    /**
     * In case the email_templates found by the `where` argument doesn't exist, create a new email_templates with this data.
     */
    create: XOR<email_templatesCreateInput, email_templatesUncheckedCreateInput>
    /**
     * In case the email_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<email_templatesUpdateInput, email_templatesUncheckedUpdateInput>
  }

  /**
   * email_templates delete
   */
  export type email_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    /**
     * Filter which email_templates to delete.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates deleteMany
   */
  export type email_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_templates to delete
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to delete.
     */
    limit?: number
  }

  /**
   * email_templates.email_campaigns
   */
  export type email_templates$email_campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    where?: email_campaignsWhereInput
    orderBy?: email_campaignsOrderByWithRelationInput | email_campaignsOrderByWithRelationInput[]
    cursor?: email_campaignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Email_campaignsScalarFieldEnum | Email_campaignsScalarFieldEnum[]
  }

  /**
   * email_templates.operators
   */
  export type email_templates$operatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    where?: operatorsWhereInput
  }

  /**
   * email_templates without action
   */
  export type email_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
  }


  /**
   * Model gift_cards
   */

  export type AggregateGift_cards = {
    _count: Gift_cardsCountAggregateOutputType | null
    _avg: Gift_cardsAvgAggregateOutputType | null
    _sum: Gift_cardsSumAggregateOutputType | null
    _min: Gift_cardsMinAggregateOutputType | null
    _max: Gift_cardsMaxAggregateOutputType | null
  }

  export type Gift_cardsAvgAggregateOutputType = {
    amount: Decimal | null
    balance: Decimal | null
  }

  export type Gift_cardsSumAggregateOutputType = {
    amount: Decimal | null
    balance: Decimal | null
  }

  export type Gift_cardsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    code: string | null
    amount: Decimal | null
    balance: Decimal | null
    status: string | null
    issue_date: Date | null
    expiry_date: Date | null
    recipient_name: string | null
    recipient_email: string | null
    sender_id: string | null
    redeemed_at: Date | null
    message: string | null
    payment_method: $Enums.payment_method_enum | null
    send_date: Date | null
    design_template: string | null
    branch_id: string | null
    is_reloadable: boolean | null
    access_pin: string | null
  }

  export type Gift_cardsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    code: string | null
    amount: Decimal | null
    balance: Decimal | null
    status: string | null
    issue_date: Date | null
    expiry_date: Date | null
    recipient_name: string | null
    recipient_email: string | null
    sender_id: string | null
    redeemed_at: Date | null
    message: string | null
    payment_method: $Enums.payment_method_enum | null
    send_date: Date | null
    design_template: string | null
    branch_id: string | null
    is_reloadable: boolean | null
    access_pin: string | null
  }

  export type Gift_cardsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    code: number
    amount: number
    balance: number
    status: number
    issue_date: number
    expiry_date: number
    recipient_name: number
    recipient_email: number
    sender_id: number
    redeemed_at: number
    message: number
    payment_method: number
    send_date: number
    design_template: number
    branch_id: number
    is_reloadable: number
    access_pin: number
    usage_history: number
    _all: number
  }


  export type Gift_cardsAvgAggregateInputType = {
    amount?: true
    balance?: true
  }

  export type Gift_cardsSumAggregateInputType = {
    amount?: true
    balance?: true
  }

  export type Gift_cardsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    amount?: true
    balance?: true
    status?: true
    issue_date?: true
    expiry_date?: true
    recipient_name?: true
    recipient_email?: true
    sender_id?: true
    redeemed_at?: true
    message?: true
    payment_method?: true
    send_date?: true
    design_template?: true
    branch_id?: true
    is_reloadable?: true
    access_pin?: true
  }

  export type Gift_cardsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    amount?: true
    balance?: true
    status?: true
    issue_date?: true
    expiry_date?: true
    recipient_name?: true
    recipient_email?: true
    sender_id?: true
    redeemed_at?: true
    message?: true
    payment_method?: true
    send_date?: true
    design_template?: true
    branch_id?: true
    is_reloadable?: true
    access_pin?: true
  }

  export type Gift_cardsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    amount?: true
    balance?: true
    status?: true
    issue_date?: true
    expiry_date?: true
    recipient_name?: true
    recipient_email?: true
    sender_id?: true
    redeemed_at?: true
    message?: true
    payment_method?: true
    send_date?: true
    design_template?: true
    branch_id?: true
    is_reloadable?: true
    access_pin?: true
    usage_history?: true
    _all?: true
  }

  export type Gift_cardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gift_cards to aggregate.
     */
    where?: gift_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gift_cards to fetch.
     */
    orderBy?: gift_cardsOrderByWithRelationInput | gift_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gift_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gift_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gift_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gift_cards
    **/
    _count?: true | Gift_cardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gift_cardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gift_cardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gift_cardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gift_cardsMaxAggregateInputType
  }

  export type GetGift_cardsAggregateType<T extends Gift_cardsAggregateArgs> = {
        [P in keyof T & keyof AggregateGift_cards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGift_cards[P]>
      : GetScalarType<T[P], AggregateGift_cards[P]>
  }




  export type gift_cardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gift_cardsWhereInput
    orderBy?: gift_cardsOrderByWithAggregationInput | gift_cardsOrderByWithAggregationInput[]
    by: Gift_cardsScalarFieldEnum[] | Gift_cardsScalarFieldEnum
    having?: gift_cardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gift_cardsCountAggregateInputType | true
    _avg?: Gift_cardsAvgAggregateInputType
    _sum?: Gift_cardsSumAggregateInputType
    _min?: Gift_cardsMinAggregateInputType
    _max?: Gift_cardsMaxAggregateInputType
  }

  export type Gift_cardsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    code: string
    amount: Decimal
    balance: Decimal | null
    status: string
    issue_date: Date
    expiry_date: Date | null
    recipient_name: string | null
    recipient_email: string | null
    sender_id: string | null
    redeemed_at: Date | null
    message: string | null
    payment_method: $Enums.payment_method_enum | null
    send_date: Date | null
    design_template: string | null
    branch_id: string | null
    is_reloadable: boolean | null
    access_pin: string | null
    usage_history: JsonValue[]
    _count: Gift_cardsCountAggregateOutputType | null
    _avg: Gift_cardsAvgAggregateOutputType | null
    _sum: Gift_cardsSumAggregateOutputType | null
    _min: Gift_cardsMinAggregateOutputType | null
    _max: Gift_cardsMaxAggregateOutputType | null
  }

  type GetGift_cardsGroupByPayload<T extends gift_cardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gift_cardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gift_cardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gift_cardsGroupByOutputType[P]>
            : GetScalarType<T[P], Gift_cardsGroupByOutputType[P]>
        }
      >
    >


  export type gift_cardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    amount?: boolean
    balance?: boolean
    status?: boolean
    issue_date?: boolean
    expiry_date?: boolean
    recipient_name?: boolean
    recipient_email?: boolean
    sender_id?: boolean
    redeemed_at?: boolean
    message?: boolean
    payment_method?: boolean
    send_date?: boolean
    design_template?: boolean
    branch_id?: boolean
    is_reloadable?: boolean
    access_pin?: boolean
    usage_history?: boolean
    branches?: boolean | gift_cards$branchesArgs<ExtArgs>
  }, ExtArgs["result"]["gift_cards"]>

  export type gift_cardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    amount?: boolean
    balance?: boolean
    status?: boolean
    issue_date?: boolean
    expiry_date?: boolean
    recipient_name?: boolean
    recipient_email?: boolean
    sender_id?: boolean
    redeemed_at?: boolean
    message?: boolean
    payment_method?: boolean
    send_date?: boolean
    design_template?: boolean
    branch_id?: boolean
    is_reloadable?: boolean
    access_pin?: boolean
    usage_history?: boolean
    branches?: boolean | gift_cards$branchesArgs<ExtArgs>
  }, ExtArgs["result"]["gift_cards"]>

  export type gift_cardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    amount?: boolean
    balance?: boolean
    status?: boolean
    issue_date?: boolean
    expiry_date?: boolean
    recipient_name?: boolean
    recipient_email?: boolean
    sender_id?: boolean
    redeemed_at?: boolean
    message?: boolean
    payment_method?: boolean
    send_date?: boolean
    design_template?: boolean
    branch_id?: boolean
    is_reloadable?: boolean
    access_pin?: boolean
    usage_history?: boolean
    branches?: boolean | gift_cards$branchesArgs<ExtArgs>
  }, ExtArgs["result"]["gift_cards"]>

  export type gift_cardsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    amount?: boolean
    balance?: boolean
    status?: boolean
    issue_date?: boolean
    expiry_date?: boolean
    recipient_name?: boolean
    recipient_email?: boolean
    sender_id?: boolean
    redeemed_at?: boolean
    message?: boolean
    payment_method?: boolean
    send_date?: boolean
    design_template?: boolean
    branch_id?: boolean
    is_reloadable?: boolean
    access_pin?: boolean
    usage_history?: boolean
  }

  export type gift_cardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "code" | "amount" | "balance" | "status" | "issue_date" | "expiry_date" | "recipient_name" | "recipient_email" | "sender_id" | "redeemed_at" | "message" | "payment_method" | "send_date" | "design_template" | "branch_id" | "is_reloadable" | "access_pin" | "usage_history", ExtArgs["result"]["gift_cards"]>
  export type gift_cardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | gift_cards$branchesArgs<ExtArgs>
  }
  export type gift_cardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | gift_cards$branchesArgs<ExtArgs>
  }
  export type gift_cardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | gift_cards$branchesArgs<ExtArgs>
  }

  export type $gift_cardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gift_cards"
    objects: {
      branches: Prisma.$branchesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      code: string
      amount: Prisma.Decimal
      balance: Prisma.Decimal | null
      status: string
      issue_date: Date
      expiry_date: Date | null
      recipient_name: string | null
      recipient_email: string | null
      sender_id: string | null
      redeemed_at: Date | null
      message: string | null
      payment_method: $Enums.payment_method_enum | null
      send_date: Date | null
      design_template: string | null
      branch_id: string | null
      is_reloadable: boolean | null
      access_pin: string | null
      usage_history: Prisma.JsonValue[]
    }, ExtArgs["result"]["gift_cards"]>
    composites: {}
  }

  type gift_cardsGetPayload<S extends boolean | null | undefined | gift_cardsDefaultArgs> = $Result.GetResult<Prisma.$gift_cardsPayload, S>

  type gift_cardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gift_cardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Gift_cardsCountAggregateInputType | true
    }

  export interface gift_cardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gift_cards'], meta: { name: 'gift_cards' } }
    /**
     * Find zero or one Gift_cards that matches the filter.
     * @param {gift_cardsFindUniqueArgs} args - Arguments to find a Gift_cards
     * @example
     * // Get one Gift_cards
     * const gift_cards = await prisma.gift_cards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gift_cardsFindUniqueArgs>(args: SelectSubset<T, gift_cardsFindUniqueArgs<ExtArgs>>): Prisma__gift_cardsClient<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gift_cards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gift_cardsFindUniqueOrThrowArgs} args - Arguments to find a Gift_cards
     * @example
     * // Get one Gift_cards
     * const gift_cards = await prisma.gift_cards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gift_cardsFindUniqueOrThrowArgs>(args: SelectSubset<T, gift_cardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gift_cardsClient<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gift_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gift_cardsFindFirstArgs} args - Arguments to find a Gift_cards
     * @example
     * // Get one Gift_cards
     * const gift_cards = await prisma.gift_cards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gift_cardsFindFirstArgs>(args?: SelectSubset<T, gift_cardsFindFirstArgs<ExtArgs>>): Prisma__gift_cardsClient<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gift_cards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gift_cardsFindFirstOrThrowArgs} args - Arguments to find a Gift_cards
     * @example
     * // Get one Gift_cards
     * const gift_cards = await prisma.gift_cards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gift_cardsFindFirstOrThrowArgs>(args?: SelectSubset<T, gift_cardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__gift_cardsClient<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gift_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gift_cardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gift_cards
     * const gift_cards = await prisma.gift_cards.findMany()
     * 
     * // Get first 10 Gift_cards
     * const gift_cards = await prisma.gift_cards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gift_cardsWithIdOnly = await prisma.gift_cards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gift_cardsFindManyArgs>(args?: SelectSubset<T, gift_cardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gift_cards.
     * @param {gift_cardsCreateArgs} args - Arguments to create a Gift_cards.
     * @example
     * // Create one Gift_cards
     * const Gift_cards = await prisma.gift_cards.create({
     *   data: {
     *     // ... data to create a Gift_cards
     *   }
     * })
     * 
     */
    create<T extends gift_cardsCreateArgs>(args: SelectSubset<T, gift_cardsCreateArgs<ExtArgs>>): Prisma__gift_cardsClient<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gift_cards.
     * @param {gift_cardsCreateManyArgs} args - Arguments to create many Gift_cards.
     * @example
     * // Create many Gift_cards
     * const gift_cards = await prisma.gift_cards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gift_cardsCreateManyArgs>(args?: SelectSubset<T, gift_cardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gift_cards and returns the data saved in the database.
     * @param {gift_cardsCreateManyAndReturnArgs} args - Arguments to create many Gift_cards.
     * @example
     * // Create many Gift_cards
     * const gift_cards = await prisma.gift_cards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gift_cards and only return the `id`
     * const gift_cardsWithIdOnly = await prisma.gift_cards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends gift_cardsCreateManyAndReturnArgs>(args?: SelectSubset<T, gift_cardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gift_cards.
     * @param {gift_cardsDeleteArgs} args - Arguments to delete one Gift_cards.
     * @example
     * // Delete one Gift_cards
     * const Gift_cards = await prisma.gift_cards.delete({
     *   where: {
     *     // ... filter to delete one Gift_cards
     *   }
     * })
     * 
     */
    delete<T extends gift_cardsDeleteArgs>(args: SelectSubset<T, gift_cardsDeleteArgs<ExtArgs>>): Prisma__gift_cardsClient<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gift_cards.
     * @param {gift_cardsUpdateArgs} args - Arguments to update one Gift_cards.
     * @example
     * // Update one Gift_cards
     * const gift_cards = await prisma.gift_cards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gift_cardsUpdateArgs>(args: SelectSubset<T, gift_cardsUpdateArgs<ExtArgs>>): Prisma__gift_cardsClient<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gift_cards.
     * @param {gift_cardsDeleteManyArgs} args - Arguments to filter Gift_cards to delete.
     * @example
     * // Delete a few Gift_cards
     * const { count } = await prisma.gift_cards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gift_cardsDeleteManyArgs>(args?: SelectSubset<T, gift_cardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gift_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gift_cardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gift_cards
     * const gift_cards = await prisma.gift_cards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gift_cardsUpdateManyArgs>(args: SelectSubset<T, gift_cardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gift_cards and returns the data updated in the database.
     * @param {gift_cardsUpdateManyAndReturnArgs} args - Arguments to update many Gift_cards.
     * @example
     * // Update many Gift_cards
     * const gift_cards = await prisma.gift_cards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gift_cards and only return the `id`
     * const gift_cardsWithIdOnly = await prisma.gift_cards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends gift_cardsUpdateManyAndReturnArgs>(args: SelectSubset<T, gift_cardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gift_cards.
     * @param {gift_cardsUpsertArgs} args - Arguments to update or create a Gift_cards.
     * @example
     * // Update or create a Gift_cards
     * const gift_cards = await prisma.gift_cards.upsert({
     *   create: {
     *     // ... data to create a Gift_cards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gift_cards we want to update
     *   }
     * })
     */
    upsert<T extends gift_cardsUpsertArgs>(args: SelectSubset<T, gift_cardsUpsertArgs<ExtArgs>>): Prisma__gift_cardsClient<$Result.GetResult<Prisma.$gift_cardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gift_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gift_cardsCountArgs} args - Arguments to filter Gift_cards to count.
     * @example
     * // Count the number of Gift_cards
     * const count = await prisma.gift_cards.count({
     *   where: {
     *     // ... the filter for the Gift_cards we want to count
     *   }
     * })
    **/
    count<T extends gift_cardsCountArgs>(
      args?: Subset<T, gift_cardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gift_cardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gift_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gift_cardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gift_cardsAggregateArgs>(args: Subset<T, Gift_cardsAggregateArgs>): Prisma.PrismaPromise<GetGift_cardsAggregateType<T>>

    /**
     * Group by Gift_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gift_cardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gift_cardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gift_cardsGroupByArgs['orderBy'] }
        : { orderBy?: gift_cardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gift_cardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGift_cardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gift_cards model
   */
  readonly fields: gift_cardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gift_cards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gift_cardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends gift_cards$branchesArgs<ExtArgs> = {}>(args?: Subset<T, gift_cards$branchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gift_cards model
   */ 
  interface gift_cardsFieldRefs {
    readonly id: FieldRef<"gift_cards", 'String'>
    readonly created_at: FieldRef<"gift_cards", 'DateTime'>
    readonly updated_at: FieldRef<"gift_cards", 'DateTime'>
    readonly code: FieldRef<"gift_cards", 'String'>
    readonly amount: FieldRef<"gift_cards", 'Decimal'>
    readonly balance: FieldRef<"gift_cards", 'Decimal'>
    readonly status: FieldRef<"gift_cards", 'String'>
    readonly issue_date: FieldRef<"gift_cards", 'DateTime'>
    readonly expiry_date: FieldRef<"gift_cards", 'DateTime'>
    readonly recipient_name: FieldRef<"gift_cards", 'String'>
    readonly recipient_email: FieldRef<"gift_cards", 'String'>
    readonly sender_id: FieldRef<"gift_cards", 'String'>
    readonly redeemed_at: FieldRef<"gift_cards", 'DateTime'>
    readonly message: FieldRef<"gift_cards", 'String'>
    readonly payment_method: FieldRef<"gift_cards", 'payment_method_enum'>
    readonly send_date: FieldRef<"gift_cards", 'DateTime'>
    readonly design_template: FieldRef<"gift_cards", 'String'>
    readonly branch_id: FieldRef<"gift_cards", 'String'>
    readonly is_reloadable: FieldRef<"gift_cards", 'Boolean'>
    readonly access_pin: FieldRef<"gift_cards", 'String'>
    readonly usage_history: FieldRef<"gift_cards", 'Json[]'>
  }
    

  // Custom InputTypes
  /**
   * gift_cards findUnique
   */
  export type gift_cardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * Filter, which gift_cards to fetch.
     */
    where: gift_cardsWhereUniqueInput
  }

  /**
   * gift_cards findUniqueOrThrow
   */
  export type gift_cardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * Filter, which gift_cards to fetch.
     */
    where: gift_cardsWhereUniqueInput
  }

  /**
   * gift_cards findFirst
   */
  export type gift_cardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * Filter, which gift_cards to fetch.
     */
    where?: gift_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gift_cards to fetch.
     */
    orderBy?: gift_cardsOrderByWithRelationInput | gift_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gift_cards.
     */
    cursor?: gift_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gift_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gift_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gift_cards.
     */
    distinct?: Gift_cardsScalarFieldEnum | Gift_cardsScalarFieldEnum[]
  }

  /**
   * gift_cards findFirstOrThrow
   */
  export type gift_cardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * Filter, which gift_cards to fetch.
     */
    where?: gift_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gift_cards to fetch.
     */
    orderBy?: gift_cardsOrderByWithRelationInput | gift_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gift_cards.
     */
    cursor?: gift_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gift_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gift_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gift_cards.
     */
    distinct?: Gift_cardsScalarFieldEnum | Gift_cardsScalarFieldEnum[]
  }

  /**
   * gift_cards findMany
   */
  export type gift_cardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * Filter, which gift_cards to fetch.
     */
    where?: gift_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gift_cards to fetch.
     */
    orderBy?: gift_cardsOrderByWithRelationInput | gift_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gift_cards.
     */
    cursor?: gift_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gift_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gift_cards.
     */
    skip?: number
    distinct?: Gift_cardsScalarFieldEnum | Gift_cardsScalarFieldEnum[]
  }

  /**
   * gift_cards create
   */
  export type gift_cardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * The data needed to create a gift_cards.
     */
    data: XOR<gift_cardsCreateInput, gift_cardsUncheckedCreateInput>
  }

  /**
   * gift_cards createMany
   */
  export type gift_cardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gift_cards.
     */
    data: gift_cardsCreateManyInput | gift_cardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gift_cards createManyAndReturn
   */
  export type gift_cardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * The data used to create many gift_cards.
     */
    data: gift_cardsCreateManyInput | gift_cardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * gift_cards update
   */
  export type gift_cardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * The data needed to update a gift_cards.
     */
    data: XOR<gift_cardsUpdateInput, gift_cardsUncheckedUpdateInput>
    /**
     * Choose, which gift_cards to update.
     */
    where: gift_cardsWhereUniqueInput
  }

  /**
   * gift_cards updateMany
   */
  export type gift_cardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gift_cards.
     */
    data: XOR<gift_cardsUpdateManyMutationInput, gift_cardsUncheckedUpdateManyInput>
    /**
     * Filter which gift_cards to update
     */
    where?: gift_cardsWhereInput
    /**
     * Limit how many gift_cards to update.
     */
    limit?: number
  }

  /**
   * gift_cards updateManyAndReturn
   */
  export type gift_cardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * The data used to update gift_cards.
     */
    data: XOR<gift_cardsUpdateManyMutationInput, gift_cardsUncheckedUpdateManyInput>
    /**
     * Filter which gift_cards to update
     */
    where?: gift_cardsWhereInput
    /**
     * Limit how many gift_cards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * gift_cards upsert
   */
  export type gift_cardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * The filter to search for the gift_cards to update in case it exists.
     */
    where: gift_cardsWhereUniqueInput
    /**
     * In case the gift_cards found by the `where` argument doesn't exist, create a new gift_cards with this data.
     */
    create: XOR<gift_cardsCreateInput, gift_cardsUncheckedCreateInput>
    /**
     * In case the gift_cards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gift_cardsUpdateInput, gift_cardsUncheckedUpdateInput>
  }

  /**
   * gift_cards delete
   */
  export type gift_cardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
    /**
     * Filter which gift_cards to delete.
     */
    where: gift_cardsWhereUniqueInput
  }

  /**
   * gift_cards deleteMany
   */
  export type gift_cardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gift_cards to delete
     */
    where?: gift_cardsWhereInput
    /**
     * Limit how many gift_cards to delete.
     */
    limit?: number
  }

  /**
   * gift_cards.branches
   */
  export type gift_cards$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * gift_cards without action
   */
  export type gift_cardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gift_cards
     */
    select?: gift_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gift_cards
     */
    omit?: gift_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gift_cardsInclude<ExtArgs> | null
  }


  /**
   * Model invoice_items
   */

  export type AggregateInvoice_items = {
    _count: Invoice_itemsCountAggregateOutputType | null
    _avg: Invoice_itemsAvgAggregateOutputType | null
    _sum: Invoice_itemsSumAggregateOutputType | null
    _min: Invoice_itemsMinAggregateOutputType | null
    _max: Invoice_itemsMaxAggregateOutputType | null
  }

  export type Invoice_itemsAvgAggregateOutputType = {
    quantity: number | null
    unit_price: Decimal | null
    total_price: Decimal | null
    discount_rate: Decimal | null
    tax_rate: Decimal | null
    item_order: number | null
  }

  export type Invoice_itemsSumAggregateOutputType = {
    quantity: number | null
    unit_price: Decimal | null
    total_price: Decimal | null
    discount_rate: Decimal | null
    tax_rate: Decimal | null
    item_order: number | null
  }

  export type Invoice_itemsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    invoice_id: string | null
    product_id: string | null
    plan_id: string | null
    description: string | null
    quantity: number | null
    unit_price: Decimal | null
    total_price: Decimal | null
    discount_rate: Decimal | null
    tax_rate: Decimal | null
    item_order: number | null
    unit_of_measure: string | null
    is_taxable: boolean | null
  }

  export type Invoice_itemsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    invoice_id: string | null
    product_id: string | null
    plan_id: string | null
    description: string | null
    quantity: number | null
    unit_price: Decimal | null
    total_price: Decimal | null
    discount_rate: Decimal | null
    tax_rate: Decimal | null
    item_order: number | null
    unit_of_measure: string | null
    is_taxable: boolean | null
  }

  export type Invoice_itemsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    invoice_id: number
    product_id: number
    plan_id: number
    description: number
    quantity: number
    unit_price: number
    total_price: number
    discount_rate: number
    tax_rate: number
    item_order: number
    unit_of_measure: number
    is_taxable: number
    serial_numbers: number
    _all: number
  }


  export type Invoice_itemsAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    total_price?: true
    discount_rate?: true
    tax_rate?: true
    item_order?: true
  }

  export type Invoice_itemsSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    total_price?: true
    discount_rate?: true
    tax_rate?: true
    item_order?: true
  }

  export type Invoice_itemsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    product_id?: true
    plan_id?: true
    description?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    discount_rate?: true
    tax_rate?: true
    item_order?: true
    unit_of_measure?: true
    is_taxable?: true
  }

  export type Invoice_itemsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    product_id?: true
    plan_id?: true
    description?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    discount_rate?: true
    tax_rate?: true
    item_order?: true
    unit_of_measure?: true
    is_taxable?: true
  }

  export type Invoice_itemsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    product_id?: true
    plan_id?: true
    description?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    discount_rate?: true
    tax_rate?: true
    item_order?: true
    unit_of_measure?: true
    is_taxable?: true
    serial_numbers?: true
    _all?: true
  }

  export type Invoice_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice_items to aggregate.
     */
    where?: invoice_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_items to fetch.
     */
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoice_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoice_items
    **/
    _count?: true | Invoice_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Invoice_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Invoice_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Invoice_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Invoice_itemsMaxAggregateInputType
  }

  export type GetInvoice_itemsAggregateType<T extends Invoice_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice_items[P]>
      : GetScalarType<T[P], AggregateInvoice_items[P]>
  }




  export type invoice_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_itemsWhereInput
    orderBy?: invoice_itemsOrderByWithAggregationInput | invoice_itemsOrderByWithAggregationInput[]
    by: Invoice_itemsScalarFieldEnum[] | Invoice_itemsScalarFieldEnum
    having?: invoice_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Invoice_itemsCountAggregateInputType | true
    _avg?: Invoice_itemsAvgAggregateInputType
    _sum?: Invoice_itemsSumAggregateInputType
    _min?: Invoice_itemsMinAggregateInputType
    _max?: Invoice_itemsMaxAggregateInputType
  }

  export type Invoice_itemsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    invoice_id: string
    product_id: string | null
    plan_id: string | null
    description: string
    quantity: number
    unit_price: Decimal
    total_price: Decimal
    discount_rate: Decimal | null
    tax_rate: Decimal | null
    item_order: number | null
    unit_of_measure: string | null
    is_taxable: boolean | null
    serial_numbers: string[]
    _count: Invoice_itemsCountAggregateOutputType | null
    _avg: Invoice_itemsAvgAggregateOutputType | null
    _sum: Invoice_itemsSumAggregateOutputType | null
    _min: Invoice_itemsMinAggregateOutputType | null
    _max: Invoice_itemsMaxAggregateOutputType | null
  }

  type GetInvoice_itemsGroupByPayload<T extends invoice_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Invoice_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Invoice_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Invoice_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Invoice_itemsGroupByOutputType[P]>
        }
      >
    >


  export type invoice_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    product_id?: boolean
    plan_id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    discount_rate?: boolean
    tax_rate?: boolean
    item_order?: boolean
    unit_of_measure?: boolean
    is_taxable?: boolean
    serial_numbers?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    plans?: boolean | invoice_items$plansArgs<ExtArgs>
    products?: boolean | invoice_items$productsArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_items"]>

  export type invoice_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    product_id?: boolean
    plan_id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    discount_rate?: boolean
    tax_rate?: boolean
    item_order?: boolean
    unit_of_measure?: boolean
    is_taxable?: boolean
    serial_numbers?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    plans?: boolean | invoice_items$plansArgs<ExtArgs>
    products?: boolean | invoice_items$productsArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_items"]>

  export type invoice_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    product_id?: boolean
    plan_id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    discount_rate?: boolean
    tax_rate?: boolean
    item_order?: boolean
    unit_of_measure?: boolean
    is_taxable?: boolean
    serial_numbers?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    plans?: boolean | invoice_items$plansArgs<ExtArgs>
    products?: boolean | invoice_items$productsArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_items"]>

  export type invoice_itemsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    product_id?: boolean
    plan_id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    discount_rate?: boolean
    tax_rate?: boolean
    item_order?: boolean
    unit_of_measure?: boolean
    is_taxable?: boolean
    serial_numbers?: boolean
  }

  export type invoice_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "invoice_id" | "product_id" | "plan_id" | "description" | "quantity" | "unit_price" | "total_price" | "discount_rate" | "tax_rate" | "item_order" | "unit_of_measure" | "is_taxable" | "serial_numbers", ExtArgs["result"]["invoice_items"]>
  export type invoice_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    plans?: boolean | invoice_items$plansArgs<ExtArgs>
    products?: boolean | invoice_items$productsArgs<ExtArgs>
  }
  export type invoice_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    plans?: boolean | invoice_items$plansArgs<ExtArgs>
    products?: boolean | invoice_items$productsArgs<ExtArgs>
  }
  export type invoice_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    plans?: boolean | invoice_items$plansArgs<ExtArgs>
    products?: boolean | invoice_items$productsArgs<ExtArgs>
  }

  export type $invoice_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoice_items"
    objects: {
      invoices: Prisma.$invoicesPayload<ExtArgs>
      plans: Prisma.$plansPayload<ExtArgs> | null
      products: Prisma.$productsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      invoice_id: string
      product_id: string | null
      plan_id: string | null
      description: string
      quantity: number
      unit_price: Prisma.Decimal
      total_price: Prisma.Decimal
      discount_rate: Prisma.Decimal | null
      tax_rate: Prisma.Decimal | null
      item_order: number | null
      unit_of_measure: string | null
      is_taxable: boolean | null
      serial_numbers: string[]
    }, ExtArgs["result"]["invoice_items"]>
    composites: {}
  }

  type invoice_itemsGetPayload<S extends boolean | null | undefined | invoice_itemsDefaultArgs> = $Result.GetResult<Prisma.$invoice_itemsPayload, S>

  type invoice_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoice_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Invoice_itemsCountAggregateInputType | true
    }

  export interface invoice_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoice_items'], meta: { name: 'invoice_items' } }
    /**
     * Find zero or one Invoice_items that matches the filter.
     * @param {invoice_itemsFindUniqueArgs} args - Arguments to find a Invoice_items
     * @example
     * // Get one Invoice_items
     * const invoice_items = await prisma.invoice_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoice_itemsFindUniqueArgs>(args: SelectSubset<T, invoice_itemsFindUniqueArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoice_itemsFindUniqueOrThrowArgs} args - Arguments to find a Invoice_items
     * @example
     * // Get one Invoice_items
     * const invoice_items = await prisma.invoice_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoice_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, invoice_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsFindFirstArgs} args - Arguments to find a Invoice_items
     * @example
     * // Get one Invoice_items
     * const invoice_items = await prisma.invoice_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoice_itemsFindFirstArgs>(args?: SelectSubset<T, invoice_itemsFindFirstArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsFindFirstOrThrowArgs} args - Arguments to find a Invoice_items
     * @example
     * // Get one Invoice_items
     * const invoice_items = await prisma.invoice_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoice_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, invoice_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoice_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoice_items
     * const invoice_items = await prisma.invoice_items.findMany()
     * 
     * // Get first 10 Invoice_items
     * const invoice_items = await prisma.invoice_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoice_itemsWithIdOnly = await prisma.invoice_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoice_itemsFindManyArgs>(args?: SelectSubset<T, invoice_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice_items.
     * @param {invoice_itemsCreateArgs} args - Arguments to create a Invoice_items.
     * @example
     * // Create one Invoice_items
     * const Invoice_items = await prisma.invoice_items.create({
     *   data: {
     *     // ... data to create a Invoice_items
     *   }
     * })
     * 
     */
    create<T extends invoice_itemsCreateArgs>(args: SelectSubset<T, invoice_itemsCreateArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoice_items.
     * @param {invoice_itemsCreateManyArgs} args - Arguments to create many Invoice_items.
     * @example
     * // Create many Invoice_items
     * const invoice_items = await prisma.invoice_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoice_itemsCreateManyArgs>(args?: SelectSubset<T, invoice_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoice_items and returns the data saved in the database.
     * @param {invoice_itemsCreateManyAndReturnArgs} args - Arguments to create many Invoice_items.
     * @example
     * // Create many Invoice_items
     * const invoice_items = await prisma.invoice_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoice_items and only return the `id`
     * const invoice_itemsWithIdOnly = await prisma.invoice_items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invoice_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, invoice_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice_items.
     * @param {invoice_itemsDeleteArgs} args - Arguments to delete one Invoice_items.
     * @example
     * // Delete one Invoice_items
     * const Invoice_items = await prisma.invoice_items.delete({
     *   where: {
     *     // ... filter to delete one Invoice_items
     *   }
     * })
     * 
     */
    delete<T extends invoice_itemsDeleteArgs>(args: SelectSubset<T, invoice_itemsDeleteArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice_items.
     * @param {invoice_itemsUpdateArgs} args - Arguments to update one Invoice_items.
     * @example
     * // Update one Invoice_items
     * const invoice_items = await prisma.invoice_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoice_itemsUpdateArgs>(args: SelectSubset<T, invoice_itemsUpdateArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoice_items.
     * @param {invoice_itemsDeleteManyArgs} args - Arguments to filter Invoice_items to delete.
     * @example
     * // Delete a few Invoice_items
     * const { count } = await prisma.invoice_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoice_itemsDeleteManyArgs>(args?: SelectSubset<T, invoice_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoice_items
     * const invoice_items = await prisma.invoice_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoice_itemsUpdateManyArgs>(args: SelectSubset<T, invoice_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_items and returns the data updated in the database.
     * @param {invoice_itemsUpdateManyAndReturnArgs} args - Arguments to update many Invoice_items.
     * @example
     * // Update many Invoice_items
     * const invoice_items = await prisma.invoice_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoice_items and only return the `id`
     * const invoice_itemsWithIdOnly = await prisma.invoice_items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invoice_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, invoice_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice_items.
     * @param {invoice_itemsUpsertArgs} args - Arguments to update or create a Invoice_items.
     * @example
     * // Update or create a Invoice_items
     * const invoice_items = await prisma.invoice_items.upsert({
     *   create: {
     *     // ... data to create a Invoice_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice_items we want to update
     *   }
     * })
     */
    upsert<T extends invoice_itemsUpsertArgs>(args: SelectSubset<T, invoice_itemsUpsertArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoice_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsCountArgs} args - Arguments to filter Invoice_items to count.
     * @example
     * // Count the number of Invoice_items
     * const count = await prisma.invoice_items.count({
     *   where: {
     *     // ... the filter for the Invoice_items we want to count
     *   }
     * })
    **/
    count<T extends invoice_itemsCountArgs>(
      args?: Subset<T, invoice_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invoice_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invoice_itemsAggregateArgs>(args: Subset<T, Invoice_itemsAggregateArgs>): Prisma.PrismaPromise<GetInvoice_itemsAggregateType<T>>

    /**
     * Group by Invoice_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoice_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoice_itemsGroupByArgs['orderBy'] }
        : { orderBy?: invoice_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoice_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoice_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoice_items model
   */
  readonly fields: invoice_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoice_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoice_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends invoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, invoicesDefaultArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plans<T extends invoice_items$plansArgs<ExtArgs> = {}>(args?: Subset<T, invoice_items$plansArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends invoice_items$productsArgs<ExtArgs> = {}>(args?: Subset<T, invoice_items$productsArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoice_items model
   */ 
  interface invoice_itemsFieldRefs {
    readonly id: FieldRef<"invoice_items", 'String'>
    readonly created_at: FieldRef<"invoice_items", 'DateTime'>
    readonly updated_at: FieldRef<"invoice_items", 'DateTime'>
    readonly invoice_id: FieldRef<"invoice_items", 'String'>
    readonly product_id: FieldRef<"invoice_items", 'String'>
    readonly plan_id: FieldRef<"invoice_items", 'String'>
    readonly description: FieldRef<"invoice_items", 'String'>
    readonly quantity: FieldRef<"invoice_items", 'Int'>
    readonly unit_price: FieldRef<"invoice_items", 'Decimal'>
    readonly total_price: FieldRef<"invoice_items", 'Decimal'>
    readonly discount_rate: FieldRef<"invoice_items", 'Decimal'>
    readonly tax_rate: FieldRef<"invoice_items", 'Decimal'>
    readonly item_order: FieldRef<"invoice_items", 'Int'>
    readonly unit_of_measure: FieldRef<"invoice_items", 'String'>
    readonly is_taxable: FieldRef<"invoice_items", 'Boolean'>
    readonly serial_numbers: FieldRef<"invoice_items", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * invoice_items findUnique
   */
  export type invoice_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where: invoice_itemsWhereUniqueInput
  }

  /**
   * invoice_items findUniqueOrThrow
   */
  export type invoice_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where: invoice_itemsWhereUniqueInput
  }

  /**
   * invoice_items findFirst
   */
  export type invoice_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where?: invoice_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_items to fetch.
     */
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoice_items.
     */
    cursor?: invoice_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoice_items.
     */
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * invoice_items findFirstOrThrow
   */
  export type invoice_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where?: invoice_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_items to fetch.
     */
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoice_items.
     */
    cursor?: invoice_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoice_items.
     */
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * invoice_items findMany
   */
  export type invoice_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where?: invoice_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_items to fetch.
     */
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoice_items.
     */
    cursor?: invoice_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_items.
     */
    skip?: number
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * invoice_items create
   */
  export type invoice_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a invoice_items.
     */
    data: XOR<invoice_itemsCreateInput, invoice_itemsUncheckedCreateInput>
  }

  /**
   * invoice_items createMany
   */
  export type invoice_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoice_items.
     */
    data: invoice_itemsCreateManyInput | invoice_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoice_items createManyAndReturn
   */
  export type invoice_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * The data used to create many invoice_items.
     */
    data: invoice_itemsCreateManyInput | invoice_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice_items update
   */
  export type invoice_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a invoice_items.
     */
    data: XOR<invoice_itemsUpdateInput, invoice_itemsUncheckedUpdateInput>
    /**
     * Choose, which invoice_items to update.
     */
    where: invoice_itemsWhereUniqueInput
  }

  /**
   * invoice_items updateMany
   */
  export type invoice_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoice_items.
     */
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyInput>
    /**
     * Filter which invoice_items to update
     */
    where?: invoice_itemsWhereInput
    /**
     * Limit how many invoice_items to update.
     */
    limit?: number
  }

  /**
   * invoice_items updateManyAndReturn
   */
  export type invoice_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * The data used to update invoice_items.
     */
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyInput>
    /**
     * Filter which invoice_items to update
     */
    where?: invoice_itemsWhereInput
    /**
     * Limit how many invoice_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice_items upsert
   */
  export type invoice_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the invoice_items to update in case it exists.
     */
    where: invoice_itemsWhereUniqueInput
    /**
     * In case the invoice_items found by the `where` argument doesn't exist, create a new invoice_items with this data.
     */
    create: XOR<invoice_itemsCreateInput, invoice_itemsUncheckedCreateInput>
    /**
     * In case the invoice_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoice_itemsUpdateInput, invoice_itemsUncheckedUpdateInput>
  }

  /**
   * invoice_items delete
   */
  export type invoice_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter which invoice_items to delete.
     */
    where: invoice_itemsWhereUniqueInput
  }

  /**
   * invoice_items deleteMany
   */
  export type invoice_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice_items to delete
     */
    where?: invoice_itemsWhereInput
    /**
     * Limit how many invoice_items to delete.
     */
    limit?: number
  }

  /**
   * invoice_items.plans
   */
  export type invoice_items$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    where?: plansWhereInput
  }

  /**
   * invoice_items.products
   */
  export type invoice_items$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * invoice_items without action
   */
  export type invoice_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
  }


  /**
   * Model invoice_packages
   */

  export type AggregateInvoice_packages = {
    _count: Invoice_packagesCountAggregateOutputType | null
    _min: Invoice_packagesMinAggregateOutputType | null
    _max: Invoice_packagesMaxAggregateOutputType | null
  }

  export type Invoice_packagesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    invoice_id: string | null
    package_id: string | null
  }

  export type Invoice_packagesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    invoice_id: string | null
    package_id: string | null
  }

  export type Invoice_packagesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    invoice_id: number
    package_id: number
    _all: number
  }


  export type Invoice_packagesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    package_id?: true
  }

  export type Invoice_packagesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    package_id?: true
  }

  export type Invoice_packagesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    package_id?: true
    _all?: true
  }

  export type Invoice_packagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice_packages to aggregate.
     */
    where?: invoice_packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_packages to fetch.
     */
    orderBy?: invoice_packagesOrderByWithRelationInput | invoice_packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoice_packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoice_packages
    **/
    _count?: true | Invoice_packagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Invoice_packagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Invoice_packagesMaxAggregateInputType
  }

  export type GetInvoice_packagesAggregateType<T extends Invoice_packagesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice_packages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice_packages[P]>
      : GetScalarType<T[P], AggregateInvoice_packages[P]>
  }




  export type invoice_packagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_packagesWhereInput
    orderBy?: invoice_packagesOrderByWithAggregationInput | invoice_packagesOrderByWithAggregationInput[]
    by: Invoice_packagesScalarFieldEnum[] | Invoice_packagesScalarFieldEnum
    having?: invoice_packagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Invoice_packagesCountAggregateInputType | true
    _min?: Invoice_packagesMinAggregateInputType
    _max?: Invoice_packagesMaxAggregateInputType
  }

  export type Invoice_packagesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    invoice_id: string
    package_id: string
    _count: Invoice_packagesCountAggregateOutputType | null
    _min: Invoice_packagesMinAggregateOutputType | null
    _max: Invoice_packagesMaxAggregateOutputType | null
  }

  type GetInvoice_packagesGroupByPayload<T extends invoice_packagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Invoice_packagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Invoice_packagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Invoice_packagesGroupByOutputType[P]>
            : GetScalarType<T[P], Invoice_packagesGroupByOutputType[P]>
        }
      >
    >


  export type invoice_packagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    package_id?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_packages"]>

  export type invoice_packagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    package_id?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_packages"]>

  export type invoice_packagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    package_id?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_packages"]>

  export type invoice_packagesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    package_id?: boolean
  }

  export type invoice_packagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "invoice_id" | "package_id", ExtArgs["result"]["invoice_packages"]>
  export type invoice_packagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }
  export type invoice_packagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }
  export type invoice_packagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }

  export type $invoice_packagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoice_packages"
    objects: {
      invoices: Prisma.$invoicesPayload<ExtArgs>
      packages: Prisma.$packagesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      invoice_id: string
      package_id: string
    }, ExtArgs["result"]["invoice_packages"]>
    composites: {}
  }

  type invoice_packagesGetPayload<S extends boolean | null | undefined | invoice_packagesDefaultArgs> = $Result.GetResult<Prisma.$invoice_packagesPayload, S>

  type invoice_packagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoice_packagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Invoice_packagesCountAggregateInputType | true
    }

  export interface invoice_packagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoice_packages'], meta: { name: 'invoice_packages' } }
    /**
     * Find zero or one Invoice_packages that matches the filter.
     * @param {invoice_packagesFindUniqueArgs} args - Arguments to find a Invoice_packages
     * @example
     * // Get one Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoice_packagesFindUniqueArgs>(args: SelectSubset<T, invoice_packagesFindUniqueArgs<ExtArgs>>): Prisma__invoice_packagesClient<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice_packages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoice_packagesFindUniqueOrThrowArgs} args - Arguments to find a Invoice_packages
     * @example
     * // Get one Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoice_packagesFindUniqueOrThrowArgs>(args: SelectSubset<T, invoice_packagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoice_packagesClient<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice_packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_packagesFindFirstArgs} args - Arguments to find a Invoice_packages
     * @example
     * // Get one Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoice_packagesFindFirstArgs>(args?: SelectSubset<T, invoice_packagesFindFirstArgs<ExtArgs>>): Prisma__invoice_packagesClient<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice_packages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_packagesFindFirstOrThrowArgs} args - Arguments to find a Invoice_packages
     * @example
     * // Get one Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoice_packagesFindFirstOrThrowArgs>(args?: SelectSubset<T, invoice_packagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoice_packagesClient<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoice_packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_packagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.findMany()
     * 
     * // Get first 10 Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoice_packagesWithIdOnly = await prisma.invoice_packages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoice_packagesFindManyArgs>(args?: SelectSubset<T, invoice_packagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice_packages.
     * @param {invoice_packagesCreateArgs} args - Arguments to create a Invoice_packages.
     * @example
     * // Create one Invoice_packages
     * const Invoice_packages = await prisma.invoice_packages.create({
     *   data: {
     *     // ... data to create a Invoice_packages
     *   }
     * })
     * 
     */
    create<T extends invoice_packagesCreateArgs>(args: SelectSubset<T, invoice_packagesCreateArgs<ExtArgs>>): Prisma__invoice_packagesClient<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoice_packages.
     * @param {invoice_packagesCreateManyArgs} args - Arguments to create many Invoice_packages.
     * @example
     * // Create many Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoice_packagesCreateManyArgs>(args?: SelectSubset<T, invoice_packagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoice_packages and returns the data saved in the database.
     * @param {invoice_packagesCreateManyAndReturnArgs} args - Arguments to create many Invoice_packages.
     * @example
     * // Create many Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoice_packages and only return the `id`
     * const invoice_packagesWithIdOnly = await prisma.invoice_packages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invoice_packagesCreateManyAndReturnArgs>(args?: SelectSubset<T, invoice_packagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice_packages.
     * @param {invoice_packagesDeleteArgs} args - Arguments to delete one Invoice_packages.
     * @example
     * // Delete one Invoice_packages
     * const Invoice_packages = await prisma.invoice_packages.delete({
     *   where: {
     *     // ... filter to delete one Invoice_packages
     *   }
     * })
     * 
     */
    delete<T extends invoice_packagesDeleteArgs>(args: SelectSubset<T, invoice_packagesDeleteArgs<ExtArgs>>): Prisma__invoice_packagesClient<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice_packages.
     * @param {invoice_packagesUpdateArgs} args - Arguments to update one Invoice_packages.
     * @example
     * // Update one Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoice_packagesUpdateArgs>(args: SelectSubset<T, invoice_packagesUpdateArgs<ExtArgs>>): Prisma__invoice_packagesClient<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoice_packages.
     * @param {invoice_packagesDeleteManyArgs} args - Arguments to filter Invoice_packages to delete.
     * @example
     * // Delete a few Invoice_packages
     * const { count } = await prisma.invoice_packages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoice_packagesDeleteManyArgs>(args?: SelectSubset<T, invoice_packagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_packagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoice_packagesUpdateManyArgs>(args: SelectSubset<T, invoice_packagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_packages and returns the data updated in the database.
     * @param {invoice_packagesUpdateManyAndReturnArgs} args - Arguments to update many Invoice_packages.
     * @example
     * // Update many Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoice_packages and only return the `id`
     * const invoice_packagesWithIdOnly = await prisma.invoice_packages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invoice_packagesUpdateManyAndReturnArgs>(args: SelectSubset<T, invoice_packagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice_packages.
     * @param {invoice_packagesUpsertArgs} args - Arguments to update or create a Invoice_packages.
     * @example
     * // Update or create a Invoice_packages
     * const invoice_packages = await prisma.invoice_packages.upsert({
     *   create: {
     *     // ... data to create a Invoice_packages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice_packages we want to update
     *   }
     * })
     */
    upsert<T extends invoice_packagesUpsertArgs>(args: SelectSubset<T, invoice_packagesUpsertArgs<ExtArgs>>): Prisma__invoice_packagesClient<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoice_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_packagesCountArgs} args - Arguments to filter Invoice_packages to count.
     * @example
     * // Count the number of Invoice_packages
     * const count = await prisma.invoice_packages.count({
     *   where: {
     *     // ... the filter for the Invoice_packages we want to count
     *   }
     * })
    **/
    count<T extends invoice_packagesCountArgs>(
      args?: Subset<T, invoice_packagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invoice_packagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_packagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invoice_packagesAggregateArgs>(args: Subset<T, Invoice_packagesAggregateArgs>): Prisma.PrismaPromise<GetInvoice_packagesAggregateType<T>>

    /**
     * Group by Invoice_packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_packagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoice_packagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoice_packagesGroupByArgs['orderBy'] }
        : { orderBy?: invoice_packagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoice_packagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoice_packagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoice_packages model
   */
  readonly fields: invoice_packagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoice_packages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoice_packagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends invoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, invoicesDefaultArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    packages<T extends packagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, packagesDefaultArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoice_packages model
   */ 
  interface invoice_packagesFieldRefs {
    readonly id: FieldRef<"invoice_packages", 'String'>
    readonly created_at: FieldRef<"invoice_packages", 'DateTime'>
    readonly updated_at: FieldRef<"invoice_packages", 'DateTime'>
    readonly invoice_id: FieldRef<"invoice_packages", 'String'>
    readonly package_id: FieldRef<"invoice_packages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * invoice_packages findUnique
   */
  export type invoice_packagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * Filter, which invoice_packages to fetch.
     */
    where: invoice_packagesWhereUniqueInput
  }

  /**
   * invoice_packages findUniqueOrThrow
   */
  export type invoice_packagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * Filter, which invoice_packages to fetch.
     */
    where: invoice_packagesWhereUniqueInput
  }

  /**
   * invoice_packages findFirst
   */
  export type invoice_packagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * Filter, which invoice_packages to fetch.
     */
    where?: invoice_packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_packages to fetch.
     */
    orderBy?: invoice_packagesOrderByWithRelationInput | invoice_packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoice_packages.
     */
    cursor?: invoice_packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoice_packages.
     */
    distinct?: Invoice_packagesScalarFieldEnum | Invoice_packagesScalarFieldEnum[]
  }

  /**
   * invoice_packages findFirstOrThrow
   */
  export type invoice_packagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * Filter, which invoice_packages to fetch.
     */
    where?: invoice_packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_packages to fetch.
     */
    orderBy?: invoice_packagesOrderByWithRelationInput | invoice_packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoice_packages.
     */
    cursor?: invoice_packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoice_packages.
     */
    distinct?: Invoice_packagesScalarFieldEnum | Invoice_packagesScalarFieldEnum[]
  }

  /**
   * invoice_packages findMany
   */
  export type invoice_packagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * Filter, which invoice_packages to fetch.
     */
    where?: invoice_packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_packages to fetch.
     */
    orderBy?: invoice_packagesOrderByWithRelationInput | invoice_packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoice_packages.
     */
    cursor?: invoice_packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_packages.
     */
    skip?: number
    distinct?: Invoice_packagesScalarFieldEnum | Invoice_packagesScalarFieldEnum[]
  }

  /**
   * invoice_packages create
   */
  export type invoice_packagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * The data needed to create a invoice_packages.
     */
    data: XOR<invoice_packagesCreateInput, invoice_packagesUncheckedCreateInput>
  }

  /**
   * invoice_packages createMany
   */
  export type invoice_packagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoice_packages.
     */
    data: invoice_packagesCreateManyInput | invoice_packagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoice_packages createManyAndReturn
   */
  export type invoice_packagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * The data used to create many invoice_packages.
     */
    data: invoice_packagesCreateManyInput | invoice_packagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice_packages update
   */
  export type invoice_packagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * The data needed to update a invoice_packages.
     */
    data: XOR<invoice_packagesUpdateInput, invoice_packagesUncheckedUpdateInput>
    /**
     * Choose, which invoice_packages to update.
     */
    where: invoice_packagesWhereUniqueInput
  }

  /**
   * invoice_packages updateMany
   */
  export type invoice_packagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoice_packages.
     */
    data: XOR<invoice_packagesUpdateManyMutationInput, invoice_packagesUncheckedUpdateManyInput>
    /**
     * Filter which invoice_packages to update
     */
    where?: invoice_packagesWhereInput
    /**
     * Limit how many invoice_packages to update.
     */
    limit?: number
  }

  /**
   * invoice_packages updateManyAndReturn
   */
  export type invoice_packagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * The data used to update invoice_packages.
     */
    data: XOR<invoice_packagesUpdateManyMutationInput, invoice_packagesUncheckedUpdateManyInput>
    /**
     * Filter which invoice_packages to update
     */
    where?: invoice_packagesWhereInput
    /**
     * Limit how many invoice_packages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice_packages upsert
   */
  export type invoice_packagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * The filter to search for the invoice_packages to update in case it exists.
     */
    where: invoice_packagesWhereUniqueInput
    /**
     * In case the invoice_packages found by the `where` argument doesn't exist, create a new invoice_packages with this data.
     */
    create: XOR<invoice_packagesCreateInput, invoice_packagesUncheckedCreateInput>
    /**
     * In case the invoice_packages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoice_packagesUpdateInput, invoice_packagesUncheckedUpdateInput>
  }

  /**
   * invoice_packages delete
   */
  export type invoice_packagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    /**
     * Filter which invoice_packages to delete.
     */
    where: invoice_packagesWhereUniqueInput
  }

  /**
   * invoice_packages deleteMany
   */
  export type invoice_packagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice_packages to delete
     */
    where?: invoice_packagesWhereInput
    /**
     * Limit how many invoice_packages to delete.
     */
    limit?: number
  }

  /**
   * invoice_packages without action
   */
  export type invoice_packagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
  }


  /**
   * Model invoices
   */

  export type AggregateInvoices = {
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  export type InvoicesAvgAggregateOutputType = {
    total_amount: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    conversion_rate: Decimal | null
    commission_amount: Decimal | null
    marketplace_fee_rate: Decimal | null
    price_plan: Decimal | null
    paid_amount: Decimal | null
    remaining_amount: Decimal | null
  }

  export type InvoicesSumAggregateOutputType = {
    total_amount: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    conversion_rate: Decimal | null
    commission_amount: Decimal | null
    marketplace_fee_rate: Decimal | null
    price_plan: Decimal | null
    paid_amount: Decimal | null
    remaining_amount: Decimal | null
  }

  export type InvoicesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    invoice_number: string | null
    issue_date: Date | null
    due_date: Date | null
    status: $Enums.invoice_status_enum | null
    is_paid: boolean | null
    total_amount: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    user_id: string | null
    branch_id: string | null
    operator_id: string | null
    notes: string | null
    payment_terms: string | null
    currency: string | null
    conversion_rate: Decimal | null
    tracking_number: string | null
    shipping_method: string | null
    invoice_type: $Enums.invoice_type_enum | null
    commission_amount: Decimal | null
    marketplace_fee_rate: Decimal | null
    platform: string | null
    external_reference_id: string | null
    price_plan: Decimal | null
    shipping_insurance: boolean | null
    paid_amount: Decimal | null
    remaining_amount: Decimal | null
    last_payment_date: Date | null
  }

  export type InvoicesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    invoice_number: string | null
    issue_date: Date | null
    due_date: Date | null
    status: $Enums.invoice_status_enum | null
    is_paid: boolean | null
    total_amount: Decimal | null
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    user_id: string | null
    branch_id: string | null
    operator_id: string | null
    notes: string | null
    payment_terms: string | null
    currency: string | null
    conversion_rate: Decimal | null
    tracking_number: string | null
    shipping_method: string | null
    invoice_type: $Enums.invoice_type_enum | null
    commission_amount: Decimal | null
    marketplace_fee_rate: Decimal | null
    platform: string | null
    external_reference_id: string | null
    price_plan: Decimal | null
    shipping_insurance: boolean | null
    paid_amount: Decimal | null
    remaining_amount: Decimal | null
    last_payment_date: Date | null
  }

  export type InvoicesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    invoice_number: number
    issue_date: number
    due_date: number
    status: number
    is_paid: number
    total_amount: number
    tax_amount: number
    discount_amount: number
    user_id: number
    branch_id: number
    operator_id: number
    billing_address: number
    shipping_address: number
    notes: number
    payment_terms: number
    currency: number
    conversion_rate: number
    tracking_number: number
    shipping_method: number
    invoice_type: number
    commission_amount: number
    marketplace_fee_rate: number
    platform: number
    external_reference_id: number
    tax_details: number
    price_plan: number
    shipping_insurance: number
    paid_amount: number
    remaining_amount: number
    last_payment_date: number
    _all: number
  }


  export type InvoicesAvgAggregateInputType = {
    total_amount?: true
    tax_amount?: true
    discount_amount?: true
    conversion_rate?: true
    commission_amount?: true
    marketplace_fee_rate?: true
    price_plan?: true
    paid_amount?: true
    remaining_amount?: true
  }

  export type InvoicesSumAggregateInputType = {
    total_amount?: true
    tax_amount?: true
    discount_amount?: true
    conversion_rate?: true
    commission_amount?: true
    marketplace_fee_rate?: true
    price_plan?: true
    paid_amount?: true
    remaining_amount?: true
  }

  export type InvoicesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_number?: true
    issue_date?: true
    due_date?: true
    status?: true
    is_paid?: true
    total_amount?: true
    tax_amount?: true
    discount_amount?: true
    user_id?: true
    branch_id?: true
    operator_id?: true
    notes?: true
    payment_terms?: true
    currency?: true
    conversion_rate?: true
    tracking_number?: true
    shipping_method?: true
    invoice_type?: true
    commission_amount?: true
    marketplace_fee_rate?: true
    platform?: true
    external_reference_id?: true
    price_plan?: true
    shipping_insurance?: true
    paid_amount?: true
    remaining_amount?: true
    last_payment_date?: true
  }

  export type InvoicesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_number?: true
    issue_date?: true
    due_date?: true
    status?: true
    is_paid?: true
    total_amount?: true
    tax_amount?: true
    discount_amount?: true
    user_id?: true
    branch_id?: true
    operator_id?: true
    notes?: true
    payment_terms?: true
    currency?: true
    conversion_rate?: true
    tracking_number?: true
    shipping_method?: true
    invoice_type?: true
    commission_amount?: true
    marketplace_fee_rate?: true
    platform?: true
    external_reference_id?: true
    price_plan?: true
    shipping_insurance?: true
    paid_amount?: true
    remaining_amount?: true
    last_payment_date?: true
  }

  export type InvoicesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_number?: true
    issue_date?: true
    due_date?: true
    status?: true
    is_paid?: true
    total_amount?: true
    tax_amount?: true
    discount_amount?: true
    user_id?: true
    branch_id?: true
    operator_id?: true
    billing_address?: true
    shipping_address?: true
    notes?: true
    payment_terms?: true
    currency?: true
    conversion_rate?: true
    tracking_number?: true
    shipping_method?: true
    invoice_type?: true
    commission_amount?: true
    marketplace_fee_rate?: true
    platform?: true
    external_reference_id?: true
    tax_details?: true
    price_plan?: true
    shipping_insurance?: true
    paid_amount?: true
    remaining_amount?: true
    last_payment_date?: true
    _all?: true
  }

  export type InvoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to aggregate.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoices
    **/
    _count?: true | InvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicesMaxAggregateInputType
  }

  export type GetInvoicesAggregateType<T extends InvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoices[P]>
      : GetScalarType<T[P], AggregateInvoices[P]>
  }




  export type invoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithAggregationInput | invoicesOrderByWithAggregationInput[]
    by: InvoicesScalarFieldEnum[] | InvoicesScalarFieldEnum
    having?: invoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicesCountAggregateInputType | true
    _avg?: InvoicesAvgAggregateInputType
    _sum?: InvoicesSumAggregateInputType
    _min?: InvoicesMinAggregateInputType
    _max?: InvoicesMaxAggregateInputType
  }

  export type InvoicesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    invoice_number: string
    issue_date: Date
    due_date: Date
    status: $Enums.invoice_status_enum
    is_paid: boolean | null
    total_amount: Decimal
    tax_amount: Decimal | null
    discount_amount: Decimal | null
    user_id: string | null
    branch_id: string | null
    operator_id: string | null
    billing_address: JsonValue | null
    shipping_address: JsonValue | null
    notes: string | null
    payment_terms: string | null
    currency: string | null
    conversion_rate: Decimal | null
    tracking_number: string | null
    shipping_method: string | null
    invoice_type: $Enums.invoice_type_enum | null
    commission_amount: Decimal | null
    marketplace_fee_rate: Decimal | null
    platform: string | null
    external_reference_id: string | null
    tax_details: JsonValue | null
    price_plan: Decimal
    shipping_insurance: boolean
    paid_amount: Decimal | null
    remaining_amount: Decimal | null
    last_payment_date: Date | null
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  type GetInvoicesGroupByPayload<T extends invoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
        }
      >
    >


  export type invoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_number?: boolean
    issue_date?: boolean
    due_date?: boolean
    status?: boolean
    is_paid?: boolean
    total_amount?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    user_id?: boolean
    branch_id?: boolean
    operator_id?: boolean
    billing_address?: boolean
    shipping_address?: boolean
    notes?: boolean
    payment_terms?: boolean
    currency?: boolean
    conversion_rate?: boolean
    tracking_number?: boolean
    shipping_method?: boolean
    invoice_type?: boolean
    commission_amount?: boolean
    marketplace_fee_rate?: boolean
    platform?: boolean
    external_reference_id?: boolean
    tax_details?: boolean
    price_plan?: boolean
    shipping_insurance?: boolean
    paid_amount?: boolean
    remaining_amount?: boolean
    last_payment_date?: boolean
    invoice_items?: boolean | invoices$invoice_itemsArgs<ExtArgs>
    invoice_packages?: boolean | invoices$invoice_packagesArgs<ExtArgs>
    branches?: boolean | invoices$branchesArgs<ExtArgs>
    operators?: boolean | invoices$operatorsArgs<ExtArgs>
    users?: boolean | invoices$usersArgs<ExtArgs>
    payments?: boolean | invoices$paymentsArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type invoicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_number?: boolean
    issue_date?: boolean
    due_date?: boolean
    status?: boolean
    is_paid?: boolean
    total_amount?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    user_id?: boolean
    branch_id?: boolean
    operator_id?: boolean
    billing_address?: boolean
    shipping_address?: boolean
    notes?: boolean
    payment_terms?: boolean
    currency?: boolean
    conversion_rate?: boolean
    tracking_number?: boolean
    shipping_method?: boolean
    invoice_type?: boolean
    commission_amount?: boolean
    marketplace_fee_rate?: boolean
    platform?: boolean
    external_reference_id?: boolean
    tax_details?: boolean
    price_plan?: boolean
    shipping_insurance?: boolean
    paid_amount?: boolean
    remaining_amount?: boolean
    last_payment_date?: boolean
    branches?: boolean | invoices$branchesArgs<ExtArgs>
    operators?: boolean | invoices$operatorsArgs<ExtArgs>
    users?: boolean | invoices$usersArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type invoicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_number?: boolean
    issue_date?: boolean
    due_date?: boolean
    status?: boolean
    is_paid?: boolean
    total_amount?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    user_id?: boolean
    branch_id?: boolean
    operator_id?: boolean
    billing_address?: boolean
    shipping_address?: boolean
    notes?: boolean
    payment_terms?: boolean
    currency?: boolean
    conversion_rate?: boolean
    tracking_number?: boolean
    shipping_method?: boolean
    invoice_type?: boolean
    commission_amount?: boolean
    marketplace_fee_rate?: boolean
    platform?: boolean
    external_reference_id?: boolean
    tax_details?: boolean
    price_plan?: boolean
    shipping_insurance?: boolean
    paid_amount?: boolean
    remaining_amount?: boolean
    last_payment_date?: boolean
    branches?: boolean | invoices$branchesArgs<ExtArgs>
    operators?: boolean | invoices$operatorsArgs<ExtArgs>
    users?: boolean | invoices$usersArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type invoicesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_number?: boolean
    issue_date?: boolean
    due_date?: boolean
    status?: boolean
    is_paid?: boolean
    total_amount?: boolean
    tax_amount?: boolean
    discount_amount?: boolean
    user_id?: boolean
    branch_id?: boolean
    operator_id?: boolean
    billing_address?: boolean
    shipping_address?: boolean
    notes?: boolean
    payment_terms?: boolean
    currency?: boolean
    conversion_rate?: boolean
    tracking_number?: boolean
    shipping_method?: boolean
    invoice_type?: boolean
    commission_amount?: boolean
    marketplace_fee_rate?: boolean
    platform?: boolean
    external_reference_id?: boolean
    tax_details?: boolean
    price_plan?: boolean
    shipping_insurance?: boolean
    paid_amount?: boolean
    remaining_amount?: boolean
    last_payment_date?: boolean
  }

  export type invoicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "invoice_number" | "issue_date" | "due_date" | "status" | "is_paid" | "total_amount" | "tax_amount" | "discount_amount" | "user_id" | "branch_id" | "operator_id" | "billing_address" | "shipping_address" | "notes" | "payment_terms" | "currency" | "conversion_rate" | "tracking_number" | "shipping_method" | "invoice_type" | "commission_amount" | "marketplace_fee_rate" | "platform" | "external_reference_id" | "tax_details" | "price_plan" | "shipping_insurance" | "paid_amount" | "remaining_amount" | "last_payment_date", ExtArgs["result"]["invoices"]>
  export type invoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_items?: boolean | invoices$invoice_itemsArgs<ExtArgs>
    invoice_packages?: boolean | invoices$invoice_packagesArgs<ExtArgs>
    branches?: boolean | invoices$branchesArgs<ExtArgs>
    operators?: boolean | invoices$operatorsArgs<ExtArgs>
    users?: boolean | invoices$usersArgs<ExtArgs>
    payments?: boolean | invoices$paymentsArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type invoicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | invoices$branchesArgs<ExtArgs>
    operators?: boolean | invoices$operatorsArgs<ExtArgs>
    users?: boolean | invoices$usersArgs<ExtArgs>
  }
  export type invoicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | invoices$branchesArgs<ExtArgs>
    operators?: boolean | invoices$operatorsArgs<ExtArgs>
    users?: boolean | invoices$usersArgs<ExtArgs>
  }

  export type $invoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoices"
    objects: {
      invoice_items: Prisma.$invoice_itemsPayload<ExtArgs>[]
      invoice_packages: Prisma.$invoice_packagesPayload<ExtArgs>[]
      branches: Prisma.$branchesPayload<ExtArgs> | null
      operators: Prisma.$operatorsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      invoice_number: string
      issue_date: Date
      due_date: Date
      status: $Enums.invoice_status_enum
      is_paid: boolean | null
      total_amount: Prisma.Decimal
      tax_amount: Prisma.Decimal | null
      discount_amount: Prisma.Decimal | null
      user_id: string | null
      branch_id: string | null
      operator_id: string | null
      billing_address: Prisma.JsonValue | null
      shipping_address: Prisma.JsonValue | null
      notes: string | null
      payment_terms: string | null
      currency: string | null
      conversion_rate: Prisma.Decimal | null
      tracking_number: string | null
      shipping_method: string | null
      invoice_type: $Enums.invoice_type_enum | null
      commission_amount: Prisma.Decimal | null
      marketplace_fee_rate: Prisma.Decimal | null
      platform: string | null
      external_reference_id: string | null
      tax_details: Prisma.JsonValue | null
      price_plan: Prisma.Decimal
      shipping_insurance: boolean
      paid_amount: Prisma.Decimal | null
      remaining_amount: Prisma.Decimal | null
      last_payment_date: Date | null
    }, ExtArgs["result"]["invoices"]>
    composites: {}
  }

  type invoicesGetPayload<S extends boolean | null | undefined | invoicesDefaultArgs> = $Result.GetResult<Prisma.$invoicesPayload, S>

  type invoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoicesCountAggregateInputType | true
    }

  export interface invoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoices'], meta: { name: 'invoices' } }
    /**
     * Find zero or one Invoices that matches the filter.
     * @param {invoicesFindUniqueArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoicesFindUniqueArgs>(args: SelectSubset<T, invoicesFindUniqueArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoicesFindUniqueOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, invoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindFirstArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoicesFindFirstArgs>(args?: SelectSubset<T, invoicesFindFirstArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindFirstOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, invoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoices.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoicesWithIdOnly = await prisma.invoices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoicesFindManyArgs>(args?: SelectSubset<T, invoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoices.
     * @param {invoicesCreateArgs} args - Arguments to create a Invoices.
     * @example
     * // Create one Invoices
     * const Invoices = await prisma.invoices.create({
     *   data: {
     *     // ... data to create a Invoices
     *   }
     * })
     * 
     */
    create<T extends invoicesCreateArgs>(args: SelectSubset<T, invoicesCreateArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {invoicesCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoices = await prisma.invoices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoicesCreateManyArgs>(args?: SelectSubset<T, invoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {invoicesCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoices = await prisma.invoices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoicesWithIdOnly = await prisma.invoices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invoicesCreateManyAndReturnArgs>(args?: SelectSubset<T, invoicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoices.
     * @param {invoicesDeleteArgs} args - Arguments to delete one Invoices.
     * @example
     * // Delete one Invoices
     * const Invoices = await prisma.invoices.delete({
     *   where: {
     *     // ... filter to delete one Invoices
     *   }
     * })
     * 
     */
    delete<T extends invoicesDeleteArgs>(args: SelectSubset<T, invoicesDeleteArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoices.
     * @param {invoicesUpdateArgs} args - Arguments to update one Invoices.
     * @example
     * // Update one Invoices
     * const invoices = await prisma.invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoicesUpdateArgs>(args: SelectSubset<T, invoicesUpdateArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {invoicesDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoicesDeleteManyArgs>(args?: SelectSubset<T, invoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoicesUpdateManyArgs>(args: SelectSubset<T, invoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {invoicesUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoicesWithIdOnly = await prisma.invoices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invoicesUpdateManyAndReturnArgs>(args: SelectSubset<T, invoicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoices.
     * @param {invoicesUpsertArgs} args - Arguments to update or create a Invoices.
     * @example
     * // Update or create a Invoices
     * const invoices = await prisma.invoices.upsert({
     *   create: {
     *     // ... data to create a Invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoices we want to update
     *   }
     * })
     */
    upsert<T extends invoicesUpsertArgs>(args: SelectSubset<T, invoicesUpsertArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoices.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends invoicesCountArgs>(
      args?: Subset<T, invoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicesAggregateArgs>(args: Subset<T, InvoicesAggregateArgs>): Prisma.PrismaPromise<GetInvoicesAggregateType<T>>

    /**
     * Group by Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoicesGroupByArgs['orderBy'] }
        : { orderBy?: invoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoices model
   */
  readonly fields: invoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice_items<T extends invoices$invoice_itemsArgs<ExtArgs> = {}>(args?: Subset<T, invoices$invoice_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice_packages<T extends invoices$invoice_packagesArgs<ExtArgs> = {}>(args?: Subset<T, invoices$invoice_packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branches<T extends invoices$branchesArgs<ExtArgs> = {}>(args?: Subset<T, invoices$branchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    operators<T extends invoices$operatorsArgs<ExtArgs> = {}>(args?: Subset<T, invoices$operatorsArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends invoices$usersArgs<ExtArgs> = {}>(args?: Subset<T, invoices$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends invoices$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, invoices$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoices model
   */ 
  interface invoicesFieldRefs {
    readonly id: FieldRef<"invoices", 'String'>
    readonly created_at: FieldRef<"invoices", 'DateTime'>
    readonly updated_at: FieldRef<"invoices", 'DateTime'>
    readonly invoice_number: FieldRef<"invoices", 'String'>
    readonly issue_date: FieldRef<"invoices", 'DateTime'>
    readonly due_date: FieldRef<"invoices", 'DateTime'>
    readonly status: FieldRef<"invoices", 'invoice_status_enum'>
    readonly is_paid: FieldRef<"invoices", 'Boolean'>
    readonly total_amount: FieldRef<"invoices", 'Decimal'>
    readonly tax_amount: FieldRef<"invoices", 'Decimal'>
    readonly discount_amount: FieldRef<"invoices", 'Decimal'>
    readonly user_id: FieldRef<"invoices", 'String'>
    readonly branch_id: FieldRef<"invoices", 'String'>
    readonly operator_id: FieldRef<"invoices", 'String'>
    readonly billing_address: FieldRef<"invoices", 'Json'>
    readonly shipping_address: FieldRef<"invoices", 'Json'>
    readonly notes: FieldRef<"invoices", 'String'>
    readonly payment_terms: FieldRef<"invoices", 'String'>
    readonly currency: FieldRef<"invoices", 'String'>
    readonly conversion_rate: FieldRef<"invoices", 'Decimal'>
    readonly tracking_number: FieldRef<"invoices", 'String'>
    readonly shipping_method: FieldRef<"invoices", 'String'>
    readonly invoice_type: FieldRef<"invoices", 'invoice_type_enum'>
    readonly commission_amount: FieldRef<"invoices", 'Decimal'>
    readonly marketplace_fee_rate: FieldRef<"invoices", 'Decimal'>
    readonly platform: FieldRef<"invoices", 'String'>
    readonly external_reference_id: FieldRef<"invoices", 'String'>
    readonly tax_details: FieldRef<"invoices", 'Json'>
    readonly price_plan: FieldRef<"invoices", 'Decimal'>
    readonly shipping_insurance: FieldRef<"invoices", 'Boolean'>
    readonly paid_amount: FieldRef<"invoices", 'Decimal'>
    readonly remaining_amount: FieldRef<"invoices", 'Decimal'>
    readonly last_payment_date: FieldRef<"invoices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * invoices findUnique
   */
  export type invoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices findUniqueOrThrow
   */
  export type invoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices findFirst
   */
  export type invoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices findFirstOrThrow
   */
  export type invoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices findMany
   */
  export type invoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices create
   */
  export type invoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a invoices.
     */
    data: XOR<invoicesCreateInput, invoicesUncheckedCreateInput>
  }

  /**
   * invoices createMany
   */
  export type invoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoices.
     */
    data: invoicesCreateManyInput | invoicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoices createManyAndReturn
   */
  export type invoicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * The data used to create many invoices.
     */
    data: invoicesCreateManyInput | invoicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoices update
   */
  export type invoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a invoices.
     */
    data: XOR<invoicesUpdateInput, invoicesUncheckedUpdateInput>
    /**
     * Choose, which invoices to update.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices updateMany
   */
  export type invoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoices.
     */
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoicesWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
  }

  /**
   * invoices updateManyAndReturn
   */
  export type invoicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * The data used to update invoices.
     */
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoicesWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoices upsert
   */
  export type invoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the invoices to update in case it exists.
     */
    where: invoicesWhereUniqueInput
    /**
     * In case the invoices found by the `where` argument doesn't exist, create a new invoices with this data.
     */
    create: XOR<invoicesCreateInput, invoicesUncheckedCreateInput>
    /**
     * In case the invoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoicesUpdateInput, invoicesUncheckedUpdateInput>
  }

  /**
   * invoices delete
   */
  export type invoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter which invoices to delete.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices deleteMany
   */
  export type invoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to delete
     */
    where?: invoicesWhereInput
    /**
     * Limit how many invoices to delete.
     */
    limit?: number
  }

  /**
   * invoices.invoice_items
   */
  export type invoices$invoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    where?: invoice_itemsWhereInput
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    cursor?: invoice_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * invoices.invoice_packages
   */
  export type invoices$invoice_packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    where?: invoice_packagesWhereInput
    orderBy?: invoice_packagesOrderByWithRelationInput | invoice_packagesOrderByWithRelationInput[]
    cursor?: invoice_packagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_packagesScalarFieldEnum | Invoice_packagesScalarFieldEnum[]
  }

  /**
   * invoices.branches
   */
  export type invoices$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * invoices.operators
   */
  export type invoices$operatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    where?: operatorsWhereInput
  }

  /**
   * invoices.users
   */
  export type invoices$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * invoices.payments
   */
  export type invoices$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * invoices without action
   */
  export type invoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
  }


  /**
   * Model notification_preferences
   */

  export type AggregateNotification_preferences = {
    _count: Notification_preferencesCountAggregateOutputType | null
    _min: Notification_preferencesMinAggregateOutputType | null
    _max: Notification_preferencesMaxAggregateOutputType | null
  }

  export type Notification_preferencesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    push_enabled: boolean | null
    email_enabled: boolean | null
    sms_enabled: boolean | null
    news_and_updates: boolean | null
    order_updates: boolean | null
    promotions: boolean | null
    security_alerts: boolean | null
    quiet_hours_start: Date | null
    quiet_hours_end: Date | null
    quiet_hours_enabled: boolean | null
    frequency: string | null
  }

  export type Notification_preferencesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    push_enabled: boolean | null
    email_enabled: boolean | null
    sms_enabled: boolean | null
    news_and_updates: boolean | null
    order_updates: boolean | null
    promotions: boolean | null
    security_alerts: boolean | null
    quiet_hours_start: Date | null
    quiet_hours_end: Date | null
    quiet_hours_enabled: boolean | null
    frequency: string | null
  }

  export type Notification_preferencesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    user_id: number
    push_enabled: number
    email_enabled: number
    sms_enabled: number
    news_and_updates: number
    order_updates: number
    promotions: number
    security_alerts: number
    quiet_hours_start: number
    quiet_hours_end: number
    quiet_hours_enabled: number
    frequency: number
    _all: number
  }


  export type Notification_preferencesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    push_enabled?: true
    email_enabled?: true
    sms_enabled?: true
    news_and_updates?: true
    order_updates?: true
    promotions?: true
    security_alerts?: true
    quiet_hours_start?: true
    quiet_hours_end?: true
    quiet_hours_enabled?: true
    frequency?: true
  }

  export type Notification_preferencesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    push_enabled?: true
    email_enabled?: true
    sms_enabled?: true
    news_and_updates?: true
    order_updates?: true
    promotions?: true
    security_alerts?: true
    quiet_hours_start?: true
    quiet_hours_end?: true
    quiet_hours_enabled?: true
    frequency?: true
  }

  export type Notification_preferencesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    push_enabled?: true
    email_enabled?: true
    sms_enabled?: true
    news_and_updates?: true
    order_updates?: true
    promotions?: true
    security_alerts?: true
    quiet_hours_start?: true
    quiet_hours_end?: true
    quiet_hours_enabled?: true
    frequency?: true
    _all?: true
  }

  export type Notification_preferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_preferences to aggregate.
     */
    where?: notification_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_preferences to fetch.
     */
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notification_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notification_preferences
    **/
    _count?: true | Notification_preferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_preferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_preferencesMaxAggregateInputType
  }

  export type GetNotification_preferencesAggregateType<T extends Notification_preferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_preferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_preferences[P]>
      : GetScalarType<T[P], AggregateNotification_preferences[P]>
  }




  export type notification_preferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_preferencesWhereInput
    orderBy?: notification_preferencesOrderByWithAggregationInput | notification_preferencesOrderByWithAggregationInput[]
    by: Notification_preferencesScalarFieldEnum[] | Notification_preferencesScalarFieldEnum
    having?: notification_preferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_preferencesCountAggregateInputType | true
    _min?: Notification_preferencesMinAggregateInputType
    _max?: Notification_preferencesMaxAggregateInputType
  }

  export type Notification_preferencesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    user_id: string
    push_enabled: boolean | null
    email_enabled: boolean | null
    sms_enabled: boolean | null
    news_and_updates: boolean | null
    order_updates: boolean | null
    promotions: boolean | null
    security_alerts: boolean | null
    quiet_hours_start: Date | null
    quiet_hours_end: Date | null
    quiet_hours_enabled: boolean | null
    frequency: string | null
    _count: Notification_preferencesCountAggregateOutputType | null
    _min: Notification_preferencesMinAggregateOutputType | null
    _max: Notification_preferencesMaxAggregateOutputType | null
  }

  type GetNotification_preferencesGroupByPayload<T extends notification_preferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_preferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_preferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_preferencesGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_preferencesGroupByOutputType[P]>
        }
      >
    >


  export type notification_preferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    push_enabled?: boolean
    email_enabled?: boolean
    sms_enabled?: boolean
    news_and_updates?: boolean
    order_updates?: boolean
    promotions?: boolean
    security_alerts?: boolean
    quiet_hours_start?: boolean
    quiet_hours_end?: boolean
    quiet_hours_enabled?: boolean
    frequency?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_preferences"]>

  export type notification_preferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    push_enabled?: boolean
    email_enabled?: boolean
    sms_enabled?: boolean
    news_and_updates?: boolean
    order_updates?: boolean
    promotions?: boolean
    security_alerts?: boolean
    quiet_hours_start?: boolean
    quiet_hours_end?: boolean
    quiet_hours_enabled?: boolean
    frequency?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_preferences"]>

  export type notification_preferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    push_enabled?: boolean
    email_enabled?: boolean
    sms_enabled?: boolean
    news_and_updates?: boolean
    order_updates?: boolean
    promotions?: boolean
    security_alerts?: boolean
    quiet_hours_start?: boolean
    quiet_hours_end?: boolean
    quiet_hours_enabled?: boolean
    frequency?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_preferences"]>

  export type notification_preferencesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    push_enabled?: boolean
    email_enabled?: boolean
    sms_enabled?: boolean
    news_and_updates?: boolean
    order_updates?: boolean
    promotions?: boolean
    security_alerts?: boolean
    quiet_hours_start?: boolean
    quiet_hours_end?: boolean
    quiet_hours_enabled?: boolean
    frequency?: boolean
  }

  export type notification_preferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "user_id" | "push_enabled" | "email_enabled" | "sms_enabled" | "news_and_updates" | "order_updates" | "promotions" | "security_alerts" | "quiet_hours_start" | "quiet_hours_end" | "quiet_hours_enabled" | "frequency", ExtArgs["result"]["notification_preferences"]>
  export type notification_preferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notification_preferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notification_preferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notification_preferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification_preferences"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      user_id: string
      push_enabled: boolean | null
      email_enabled: boolean | null
      sms_enabled: boolean | null
      news_and_updates: boolean | null
      order_updates: boolean | null
      promotions: boolean | null
      security_alerts: boolean | null
      quiet_hours_start: Date | null
      quiet_hours_end: Date | null
      quiet_hours_enabled: boolean | null
      frequency: string | null
    }, ExtArgs["result"]["notification_preferences"]>
    composites: {}
  }

  type notification_preferencesGetPayload<S extends boolean | null | undefined | notification_preferencesDefaultArgs> = $Result.GetResult<Prisma.$notification_preferencesPayload, S>

  type notification_preferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notification_preferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Notification_preferencesCountAggregateInputType | true
    }

  export interface notification_preferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification_preferences'], meta: { name: 'notification_preferences' } }
    /**
     * Find zero or one Notification_preferences that matches the filter.
     * @param {notification_preferencesFindUniqueArgs} args - Arguments to find a Notification_preferences
     * @example
     * // Get one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notification_preferencesFindUniqueArgs>(args: SelectSubset<T, notification_preferencesFindUniqueArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification_preferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notification_preferencesFindUniqueOrThrowArgs} args - Arguments to find a Notification_preferences
     * @example
     * // Get one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notification_preferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, notification_preferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesFindFirstArgs} args - Arguments to find a Notification_preferences
     * @example
     * // Get one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notification_preferencesFindFirstArgs>(args?: SelectSubset<T, notification_preferencesFindFirstArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_preferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesFindFirstOrThrowArgs} args - Arguments to find a Notification_preferences
     * @example
     * // Get one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notification_preferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, notification_preferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notification_preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findMany()
     * 
     * // Get first 10 Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notification_preferencesWithIdOnly = await prisma.notification_preferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notification_preferencesFindManyArgs>(args?: SelectSubset<T, notification_preferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification_preferences.
     * @param {notification_preferencesCreateArgs} args - Arguments to create a Notification_preferences.
     * @example
     * // Create one Notification_preferences
     * const Notification_preferences = await prisma.notification_preferences.create({
     *   data: {
     *     // ... data to create a Notification_preferences
     *   }
     * })
     * 
     */
    create<T extends notification_preferencesCreateArgs>(args: SelectSubset<T, notification_preferencesCreateArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notification_preferences.
     * @param {notification_preferencesCreateManyArgs} args - Arguments to create many Notification_preferences.
     * @example
     * // Create many Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notification_preferencesCreateManyArgs>(args?: SelectSubset<T, notification_preferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notification_preferences and returns the data saved in the database.
     * @param {notification_preferencesCreateManyAndReturnArgs} args - Arguments to create many Notification_preferences.
     * @example
     * // Create many Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notification_preferences and only return the `id`
     * const notification_preferencesWithIdOnly = await prisma.notification_preferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notification_preferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, notification_preferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification_preferences.
     * @param {notification_preferencesDeleteArgs} args - Arguments to delete one Notification_preferences.
     * @example
     * // Delete one Notification_preferences
     * const Notification_preferences = await prisma.notification_preferences.delete({
     *   where: {
     *     // ... filter to delete one Notification_preferences
     *   }
     * })
     * 
     */
    delete<T extends notification_preferencesDeleteArgs>(args: SelectSubset<T, notification_preferencesDeleteArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification_preferences.
     * @param {notification_preferencesUpdateArgs} args - Arguments to update one Notification_preferences.
     * @example
     * // Update one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notification_preferencesUpdateArgs>(args: SelectSubset<T, notification_preferencesUpdateArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notification_preferences.
     * @param {notification_preferencesDeleteManyArgs} args - Arguments to filter Notification_preferences to delete.
     * @example
     * // Delete a few Notification_preferences
     * const { count } = await prisma.notification_preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notification_preferencesDeleteManyArgs>(args?: SelectSubset<T, notification_preferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notification_preferencesUpdateManyArgs>(args: SelectSubset<T, notification_preferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_preferences and returns the data updated in the database.
     * @param {notification_preferencesUpdateManyAndReturnArgs} args - Arguments to update many Notification_preferences.
     * @example
     * // Update many Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notification_preferences and only return the `id`
     * const notification_preferencesWithIdOnly = await prisma.notification_preferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notification_preferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, notification_preferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification_preferences.
     * @param {notification_preferencesUpsertArgs} args - Arguments to update or create a Notification_preferences.
     * @example
     * // Update or create a Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.upsert({
     *   create: {
     *     // ... data to create a Notification_preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_preferences we want to update
     *   }
     * })
     */
    upsert<T extends notification_preferencesUpsertArgs>(args: SelectSubset<T, notification_preferencesUpsertArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notification_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesCountArgs} args - Arguments to filter Notification_preferences to count.
     * @example
     * // Count the number of Notification_preferences
     * const count = await prisma.notification_preferences.count({
     *   where: {
     *     // ... the filter for the Notification_preferences we want to count
     *   }
     * })
    **/
    count<T extends notification_preferencesCountArgs>(
      args?: Subset<T, notification_preferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_preferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_preferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_preferencesAggregateArgs>(args: Subset<T, Notification_preferencesAggregateArgs>): Prisma.PrismaPromise<GetNotification_preferencesAggregateType<T>>

    /**
     * Group by Notification_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notification_preferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notification_preferencesGroupByArgs['orderBy'] }
        : { orderBy?: notification_preferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notification_preferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_preferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification_preferences model
   */
  readonly fields: notification_preferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification_preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notification_preferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification_preferences model
   */ 
  interface notification_preferencesFieldRefs {
    readonly id: FieldRef<"notification_preferences", 'String'>
    readonly created_at: FieldRef<"notification_preferences", 'DateTime'>
    readonly updated_at: FieldRef<"notification_preferences", 'DateTime'>
    readonly user_id: FieldRef<"notification_preferences", 'String'>
    readonly push_enabled: FieldRef<"notification_preferences", 'Boolean'>
    readonly email_enabled: FieldRef<"notification_preferences", 'Boolean'>
    readonly sms_enabled: FieldRef<"notification_preferences", 'Boolean'>
    readonly news_and_updates: FieldRef<"notification_preferences", 'Boolean'>
    readonly order_updates: FieldRef<"notification_preferences", 'Boolean'>
    readonly promotions: FieldRef<"notification_preferences", 'Boolean'>
    readonly security_alerts: FieldRef<"notification_preferences", 'Boolean'>
    readonly quiet_hours_start: FieldRef<"notification_preferences", 'DateTime'>
    readonly quiet_hours_end: FieldRef<"notification_preferences", 'DateTime'>
    readonly quiet_hours_enabled: FieldRef<"notification_preferences", 'Boolean'>
    readonly frequency: FieldRef<"notification_preferences", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notification_preferences findUnique
   */
  export type notification_preferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where: notification_preferencesWhereUniqueInput
  }

  /**
   * notification_preferences findUniqueOrThrow
   */
  export type notification_preferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where: notification_preferencesWhereUniqueInput
  }

  /**
   * notification_preferences findFirst
   */
  export type notification_preferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where?: notification_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_preferences to fetch.
     */
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_preferences.
     */
    cursor?: notification_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_preferences.
     */
    distinct?: Notification_preferencesScalarFieldEnum | Notification_preferencesScalarFieldEnum[]
  }

  /**
   * notification_preferences findFirstOrThrow
   */
  export type notification_preferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where?: notification_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_preferences to fetch.
     */
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_preferences.
     */
    cursor?: notification_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_preferences.
     */
    distinct?: Notification_preferencesScalarFieldEnum | Notification_preferencesScalarFieldEnum[]
  }

  /**
   * notification_preferences findMany
   */
  export type notification_preferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where?: notification_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_preferences to fetch.
     */
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notification_preferences.
     */
    cursor?: notification_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_preferences.
     */
    skip?: number
    distinct?: Notification_preferencesScalarFieldEnum | Notification_preferencesScalarFieldEnum[]
  }

  /**
   * notification_preferences create
   */
  export type notification_preferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a notification_preferences.
     */
    data: XOR<notification_preferencesCreateInput, notification_preferencesUncheckedCreateInput>
  }

  /**
   * notification_preferences createMany
   */
  export type notification_preferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notification_preferences.
     */
    data: notification_preferencesCreateManyInput | notification_preferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_preferences createManyAndReturn
   */
  export type notification_preferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * The data used to create many notification_preferences.
     */
    data: notification_preferencesCreateManyInput | notification_preferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification_preferences update
   */
  export type notification_preferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a notification_preferences.
     */
    data: XOR<notification_preferencesUpdateInput, notification_preferencesUncheckedUpdateInput>
    /**
     * Choose, which notification_preferences to update.
     */
    where: notification_preferencesWhereUniqueInput
  }

  /**
   * notification_preferences updateMany
   */
  export type notification_preferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notification_preferences.
     */
    data: XOR<notification_preferencesUpdateManyMutationInput, notification_preferencesUncheckedUpdateManyInput>
    /**
     * Filter which notification_preferences to update
     */
    where?: notification_preferencesWhereInput
    /**
     * Limit how many notification_preferences to update.
     */
    limit?: number
  }

  /**
   * notification_preferences updateManyAndReturn
   */
  export type notification_preferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * The data used to update notification_preferences.
     */
    data: XOR<notification_preferencesUpdateManyMutationInput, notification_preferencesUncheckedUpdateManyInput>
    /**
     * Filter which notification_preferences to update
     */
    where?: notification_preferencesWhereInput
    /**
     * Limit how many notification_preferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification_preferences upsert
   */
  export type notification_preferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the notification_preferences to update in case it exists.
     */
    where: notification_preferencesWhereUniqueInput
    /**
     * In case the notification_preferences found by the `where` argument doesn't exist, create a new notification_preferences with this data.
     */
    create: XOR<notification_preferencesCreateInput, notification_preferencesUncheckedCreateInput>
    /**
     * In case the notification_preferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notification_preferencesUpdateInput, notification_preferencesUncheckedUpdateInput>
  }

  /**
   * notification_preferences delete
   */
  export type notification_preferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter which notification_preferences to delete.
     */
    where: notification_preferencesWhereUniqueInput
  }

  /**
   * notification_preferences deleteMany
   */
  export type notification_preferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_preferences to delete
     */
    where?: notification_preferencesWhereInput
    /**
     * Limit how many notification_preferences to delete.
     */
    limit?: number
  }

  /**
   * notification_preferences without action
   */
  export type notification_preferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
  }


  /**
   * Model notification_users
   */

  export type AggregateNotification_users = {
    _count: Notification_usersCountAggregateOutputType | null
    _min: Notification_usersMinAggregateOutputType | null
    _max: Notification_usersMaxAggregateOutputType | null
  }

  export type Notification_usersMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    title: string | null
    message: string | null
    type: string | null
    is_read: boolean | null
    is_deleted: boolean | null
    user_id: string | null
    priority: string | null
    action_url: string | null
    icon: string | null
    expiry_date: Date | null
    requires_action: boolean | null
  }

  export type Notification_usersMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    title: string | null
    message: string | null
    type: string | null
    is_read: boolean | null
    is_deleted: boolean | null
    user_id: string | null
    priority: string | null
    action_url: string | null
    icon: string | null
    expiry_date: Date | null
    requires_action: boolean | null
  }

  export type Notification_usersCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    title: number
    message: number
    type: number
    is_read: number
    is_deleted: number
    user_id: number
    data: number
    priority: number
    action_url: number
    icon: number
    expiry_date: number
    requires_action: number
    _all: number
  }


  export type Notification_usersMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    title?: true
    message?: true
    type?: true
    is_read?: true
    is_deleted?: true
    user_id?: true
    priority?: true
    action_url?: true
    icon?: true
    expiry_date?: true
    requires_action?: true
  }

  export type Notification_usersMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    title?: true
    message?: true
    type?: true
    is_read?: true
    is_deleted?: true
    user_id?: true
    priority?: true
    action_url?: true
    icon?: true
    expiry_date?: true
    requires_action?: true
  }

  export type Notification_usersCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    title?: true
    message?: true
    type?: true
    is_read?: true
    is_deleted?: true
    user_id?: true
    data?: true
    priority?: true
    action_url?: true
    icon?: true
    expiry_date?: true
    requires_action?: true
    _all?: true
  }

  export type Notification_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_users to aggregate.
     */
    where?: notification_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_users to fetch.
     */
    orderBy?: notification_usersOrderByWithRelationInput | notification_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notification_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notification_users
    **/
    _count?: true | Notification_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_usersMaxAggregateInputType
  }

  export type GetNotification_usersAggregateType<T extends Notification_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_users[P]>
      : GetScalarType<T[P], AggregateNotification_users[P]>
  }




  export type notification_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_usersWhereInput
    orderBy?: notification_usersOrderByWithAggregationInput | notification_usersOrderByWithAggregationInput[]
    by: Notification_usersScalarFieldEnum[] | Notification_usersScalarFieldEnum
    having?: notification_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_usersCountAggregateInputType | true
    _min?: Notification_usersMinAggregateInputType
    _max?: Notification_usersMaxAggregateInputType
  }

  export type Notification_usersGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    title: string
    message: string
    type: string
    is_read: boolean | null
    is_deleted: boolean | null
    user_id: string
    data: JsonValue | null
    priority: string | null
    action_url: string | null
    icon: string | null
    expiry_date: Date | null
    requires_action: boolean | null
    _count: Notification_usersCountAggregateOutputType | null
    _min: Notification_usersMinAggregateOutputType | null
    _max: Notification_usersMaxAggregateOutputType | null
  }

  type GetNotification_usersGroupByPayload<T extends notification_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_usersGroupByOutputType[P]>
        }
      >
    >


  export type notification_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    is_read?: boolean
    is_deleted?: boolean
    user_id?: boolean
    data?: boolean
    priority?: boolean
    action_url?: boolean
    icon?: boolean
    expiry_date?: boolean
    requires_action?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_users"]>

  export type notification_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    is_read?: boolean
    is_deleted?: boolean
    user_id?: boolean
    data?: boolean
    priority?: boolean
    action_url?: boolean
    icon?: boolean
    expiry_date?: boolean
    requires_action?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_users"]>

  export type notification_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    is_read?: boolean
    is_deleted?: boolean
    user_id?: boolean
    data?: boolean
    priority?: boolean
    action_url?: boolean
    icon?: boolean
    expiry_date?: boolean
    requires_action?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_users"]>

  export type notification_usersSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    is_read?: boolean
    is_deleted?: boolean
    user_id?: boolean
    data?: boolean
    priority?: boolean
    action_url?: boolean
    icon?: boolean
    expiry_date?: boolean
    requires_action?: boolean
  }

  export type notification_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "title" | "message" | "type" | "is_read" | "is_deleted" | "user_id" | "data" | "priority" | "action_url" | "icon" | "expiry_date" | "requires_action", ExtArgs["result"]["notification_users"]>
  export type notification_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notification_usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notification_usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notification_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification_users"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      title: string
      message: string
      type: string
      is_read: boolean | null
      is_deleted: boolean | null
      user_id: string
      data: Prisma.JsonValue | null
      priority: string | null
      action_url: string | null
      icon: string | null
      expiry_date: Date | null
      requires_action: boolean | null
    }, ExtArgs["result"]["notification_users"]>
    composites: {}
  }

  type notification_usersGetPayload<S extends boolean | null | undefined | notification_usersDefaultArgs> = $Result.GetResult<Prisma.$notification_usersPayload, S>

  type notification_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notification_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Notification_usersCountAggregateInputType | true
    }

  export interface notification_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification_users'], meta: { name: 'notification_users' } }
    /**
     * Find zero or one Notification_users that matches the filter.
     * @param {notification_usersFindUniqueArgs} args - Arguments to find a Notification_users
     * @example
     * // Get one Notification_users
     * const notification_users = await prisma.notification_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notification_usersFindUniqueArgs>(args: SelectSubset<T, notification_usersFindUniqueArgs<ExtArgs>>): Prisma__notification_usersClient<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notification_usersFindUniqueOrThrowArgs} args - Arguments to find a Notification_users
     * @example
     * // Get one Notification_users
     * const notification_users = await prisma.notification_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notification_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, notification_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notification_usersClient<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_usersFindFirstArgs} args - Arguments to find a Notification_users
     * @example
     * // Get one Notification_users
     * const notification_users = await prisma.notification_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notification_usersFindFirstArgs>(args?: SelectSubset<T, notification_usersFindFirstArgs<ExtArgs>>): Prisma__notification_usersClient<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_usersFindFirstOrThrowArgs} args - Arguments to find a Notification_users
     * @example
     * // Get one Notification_users
     * const notification_users = await prisma.notification_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notification_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, notification_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__notification_usersClient<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notification_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_users
     * const notification_users = await prisma.notification_users.findMany()
     * 
     * // Get first 10 Notification_users
     * const notification_users = await prisma.notification_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notification_usersWithIdOnly = await prisma.notification_users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notification_usersFindManyArgs>(args?: SelectSubset<T, notification_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification_users.
     * @param {notification_usersCreateArgs} args - Arguments to create a Notification_users.
     * @example
     * // Create one Notification_users
     * const Notification_users = await prisma.notification_users.create({
     *   data: {
     *     // ... data to create a Notification_users
     *   }
     * })
     * 
     */
    create<T extends notification_usersCreateArgs>(args: SelectSubset<T, notification_usersCreateArgs<ExtArgs>>): Prisma__notification_usersClient<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notification_users.
     * @param {notification_usersCreateManyArgs} args - Arguments to create many Notification_users.
     * @example
     * // Create many Notification_users
     * const notification_users = await prisma.notification_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notification_usersCreateManyArgs>(args?: SelectSubset<T, notification_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notification_users and returns the data saved in the database.
     * @param {notification_usersCreateManyAndReturnArgs} args - Arguments to create many Notification_users.
     * @example
     * // Create many Notification_users
     * const notification_users = await prisma.notification_users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notification_users and only return the `id`
     * const notification_usersWithIdOnly = await prisma.notification_users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notification_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, notification_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification_users.
     * @param {notification_usersDeleteArgs} args - Arguments to delete one Notification_users.
     * @example
     * // Delete one Notification_users
     * const Notification_users = await prisma.notification_users.delete({
     *   where: {
     *     // ... filter to delete one Notification_users
     *   }
     * })
     * 
     */
    delete<T extends notification_usersDeleteArgs>(args: SelectSubset<T, notification_usersDeleteArgs<ExtArgs>>): Prisma__notification_usersClient<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification_users.
     * @param {notification_usersUpdateArgs} args - Arguments to update one Notification_users.
     * @example
     * // Update one Notification_users
     * const notification_users = await prisma.notification_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notification_usersUpdateArgs>(args: SelectSubset<T, notification_usersUpdateArgs<ExtArgs>>): Prisma__notification_usersClient<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notification_users.
     * @param {notification_usersDeleteManyArgs} args - Arguments to filter Notification_users to delete.
     * @example
     * // Delete a few Notification_users
     * const { count } = await prisma.notification_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notification_usersDeleteManyArgs>(args?: SelectSubset<T, notification_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_users
     * const notification_users = await prisma.notification_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notification_usersUpdateManyArgs>(args: SelectSubset<T, notification_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_users and returns the data updated in the database.
     * @param {notification_usersUpdateManyAndReturnArgs} args - Arguments to update many Notification_users.
     * @example
     * // Update many Notification_users
     * const notification_users = await prisma.notification_users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notification_users and only return the `id`
     * const notification_usersWithIdOnly = await prisma.notification_users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notification_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, notification_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification_users.
     * @param {notification_usersUpsertArgs} args - Arguments to update or create a Notification_users.
     * @example
     * // Update or create a Notification_users
     * const notification_users = await prisma.notification_users.upsert({
     *   create: {
     *     // ... data to create a Notification_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_users we want to update
     *   }
     * })
     */
    upsert<T extends notification_usersUpsertArgs>(args: SelectSubset<T, notification_usersUpsertArgs<ExtArgs>>): Prisma__notification_usersClient<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notification_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_usersCountArgs} args - Arguments to filter Notification_users to count.
     * @example
     * // Count the number of Notification_users
     * const count = await prisma.notification_users.count({
     *   where: {
     *     // ... the filter for the Notification_users we want to count
     *   }
     * })
    **/
    count<T extends notification_usersCountArgs>(
      args?: Subset<T, notification_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_usersAggregateArgs>(args: Subset<T, Notification_usersAggregateArgs>): Prisma.PrismaPromise<GetNotification_usersAggregateType<T>>

    /**
     * Group by Notification_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notification_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notification_usersGroupByArgs['orderBy'] }
        : { orderBy?: notification_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notification_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification_users model
   */
  readonly fields: notification_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notification_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification_users model
   */ 
  interface notification_usersFieldRefs {
    readonly id: FieldRef<"notification_users", 'String'>
    readonly created_at: FieldRef<"notification_users", 'DateTime'>
    readonly updated_at: FieldRef<"notification_users", 'DateTime'>
    readonly title: FieldRef<"notification_users", 'String'>
    readonly message: FieldRef<"notification_users", 'String'>
    readonly type: FieldRef<"notification_users", 'String'>
    readonly is_read: FieldRef<"notification_users", 'Boolean'>
    readonly is_deleted: FieldRef<"notification_users", 'Boolean'>
    readonly user_id: FieldRef<"notification_users", 'String'>
    readonly data: FieldRef<"notification_users", 'Json'>
    readonly priority: FieldRef<"notification_users", 'String'>
    readonly action_url: FieldRef<"notification_users", 'String'>
    readonly icon: FieldRef<"notification_users", 'String'>
    readonly expiry_date: FieldRef<"notification_users", 'DateTime'>
    readonly requires_action: FieldRef<"notification_users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * notification_users findUnique
   */
  export type notification_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * Filter, which notification_users to fetch.
     */
    where: notification_usersWhereUniqueInput
  }

  /**
   * notification_users findUniqueOrThrow
   */
  export type notification_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * Filter, which notification_users to fetch.
     */
    where: notification_usersWhereUniqueInput
  }

  /**
   * notification_users findFirst
   */
  export type notification_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * Filter, which notification_users to fetch.
     */
    where?: notification_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_users to fetch.
     */
    orderBy?: notification_usersOrderByWithRelationInput | notification_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_users.
     */
    cursor?: notification_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_users.
     */
    distinct?: Notification_usersScalarFieldEnum | Notification_usersScalarFieldEnum[]
  }

  /**
   * notification_users findFirstOrThrow
   */
  export type notification_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * Filter, which notification_users to fetch.
     */
    where?: notification_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_users to fetch.
     */
    orderBy?: notification_usersOrderByWithRelationInput | notification_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_users.
     */
    cursor?: notification_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_users.
     */
    distinct?: Notification_usersScalarFieldEnum | Notification_usersScalarFieldEnum[]
  }

  /**
   * notification_users findMany
   */
  export type notification_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * Filter, which notification_users to fetch.
     */
    where?: notification_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_users to fetch.
     */
    orderBy?: notification_usersOrderByWithRelationInput | notification_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notification_users.
     */
    cursor?: notification_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_users.
     */
    skip?: number
    distinct?: Notification_usersScalarFieldEnum | Notification_usersScalarFieldEnum[]
  }

  /**
   * notification_users create
   */
  export type notification_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * The data needed to create a notification_users.
     */
    data: XOR<notification_usersCreateInput, notification_usersUncheckedCreateInput>
  }

  /**
   * notification_users createMany
   */
  export type notification_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notification_users.
     */
    data: notification_usersCreateManyInput | notification_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_users createManyAndReturn
   */
  export type notification_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * The data used to create many notification_users.
     */
    data: notification_usersCreateManyInput | notification_usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification_users update
   */
  export type notification_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * The data needed to update a notification_users.
     */
    data: XOR<notification_usersUpdateInput, notification_usersUncheckedUpdateInput>
    /**
     * Choose, which notification_users to update.
     */
    where: notification_usersWhereUniqueInput
  }

  /**
   * notification_users updateMany
   */
  export type notification_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notification_users.
     */
    data: XOR<notification_usersUpdateManyMutationInput, notification_usersUncheckedUpdateManyInput>
    /**
     * Filter which notification_users to update
     */
    where?: notification_usersWhereInput
    /**
     * Limit how many notification_users to update.
     */
    limit?: number
  }

  /**
   * notification_users updateManyAndReturn
   */
  export type notification_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * The data used to update notification_users.
     */
    data: XOR<notification_usersUpdateManyMutationInput, notification_usersUncheckedUpdateManyInput>
    /**
     * Filter which notification_users to update
     */
    where?: notification_usersWhereInput
    /**
     * Limit how many notification_users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification_users upsert
   */
  export type notification_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * The filter to search for the notification_users to update in case it exists.
     */
    where: notification_usersWhereUniqueInput
    /**
     * In case the notification_users found by the `where` argument doesn't exist, create a new notification_users with this data.
     */
    create: XOR<notification_usersCreateInput, notification_usersUncheckedCreateInput>
    /**
     * In case the notification_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notification_usersUpdateInput, notification_usersUncheckedUpdateInput>
  }

  /**
   * notification_users delete
   */
  export type notification_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    /**
     * Filter which notification_users to delete.
     */
    where: notification_usersWhereUniqueInput
  }

  /**
   * notification_users deleteMany
   */
  export type notification_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_users to delete
     */
    where?: notification_usersWhereInput
    /**
     * Limit how many notification_users to delete.
     */
    limit?: number
  }

  /**
   * notification_users without action
   */
  export type notification_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
  }


  /**
   * Model notifications_operator
   */

  export type AggregateNotifications_operator = {
    _count: Notifications_operatorCountAggregateOutputType | null
    _min: Notifications_operatorMinAggregateOutputType | null
    _max: Notifications_operatorMaxAggregateOutputType | null
  }

  export type Notifications_operatorMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    title: string | null
    message: string | null
    is_read: boolean | null
    operator_id: string | null
    notification_type: string | null
    priority: string | null
    action_required: boolean | null
    action_type: string | null
    expiry_date: Date | null
  }

  export type Notifications_operatorMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    title: string | null
    message: string | null
    is_read: boolean | null
    operator_id: string | null
    notification_type: string | null
    priority: string | null
    action_required: boolean | null
    action_type: string | null
    expiry_date: Date | null
  }

  export type Notifications_operatorCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    title: number
    message: number
    is_read: number
    operator_id: number
    data: number
    notification_type: number
    priority: number
    action_required: number
    action_type: number
    action_data: number
    expiry_date: number
    _all: number
  }


  export type Notifications_operatorMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    title?: true
    message?: true
    is_read?: true
    operator_id?: true
    notification_type?: true
    priority?: true
    action_required?: true
    action_type?: true
    expiry_date?: true
  }

  export type Notifications_operatorMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    title?: true
    message?: true
    is_read?: true
    operator_id?: true
    notification_type?: true
    priority?: true
    action_required?: true
    action_type?: true
    expiry_date?: true
  }

  export type Notifications_operatorCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    title?: true
    message?: true
    is_read?: true
    operator_id?: true
    data?: true
    notification_type?: true
    priority?: true
    action_required?: true
    action_type?: true
    action_data?: true
    expiry_date?: true
    _all?: true
  }

  export type Notifications_operatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications_operator to aggregate.
     */
    where?: notifications_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications_operators to fetch.
     */
    orderBy?: notifications_operatorOrderByWithRelationInput | notifications_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notifications_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications_operators
    **/
    _count?: true | Notifications_operatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notifications_operatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notifications_operatorMaxAggregateInputType
  }

  export type GetNotifications_operatorAggregateType<T extends Notifications_operatorAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications_operator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications_operator[P]>
      : GetScalarType<T[P], AggregateNotifications_operator[P]>
  }




  export type notifications_operatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notifications_operatorWhereInput
    orderBy?: notifications_operatorOrderByWithAggregationInput | notifications_operatorOrderByWithAggregationInput[]
    by: Notifications_operatorScalarFieldEnum[] | Notifications_operatorScalarFieldEnum
    having?: notifications_operatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notifications_operatorCountAggregateInputType | true
    _min?: Notifications_operatorMinAggregateInputType
    _max?: Notifications_operatorMaxAggregateInputType
  }

  export type Notifications_operatorGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    title: string
    message: string
    is_read: boolean | null
    operator_id: string
    data: JsonValue | null
    notification_type: string | null
    priority: string | null
    action_required: boolean | null
    action_type: string | null
    action_data: JsonValue | null
    expiry_date: Date | null
    _count: Notifications_operatorCountAggregateOutputType | null
    _min: Notifications_operatorMinAggregateOutputType | null
    _max: Notifications_operatorMaxAggregateOutputType | null
  }

  type GetNotifications_operatorGroupByPayload<T extends notifications_operatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notifications_operatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notifications_operatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notifications_operatorGroupByOutputType[P]>
            : GetScalarType<T[P], Notifications_operatorGroupByOutputType[P]>
        }
      >
    >


  export type notifications_operatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    operator_id?: boolean
    data?: boolean
    notification_type?: boolean
    priority?: boolean
    action_required?: boolean
    action_type?: boolean
    action_data?: boolean
    expiry_date?: boolean
    operators?: boolean | operatorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications_operator"]>

  export type notifications_operatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    operator_id?: boolean
    data?: boolean
    notification_type?: boolean
    priority?: boolean
    action_required?: boolean
    action_type?: boolean
    action_data?: boolean
    expiry_date?: boolean
    operators?: boolean | operatorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications_operator"]>

  export type notifications_operatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    operator_id?: boolean
    data?: boolean
    notification_type?: boolean
    priority?: boolean
    action_required?: boolean
    action_type?: boolean
    action_data?: boolean
    expiry_date?: boolean
    operators?: boolean | operatorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications_operator"]>

  export type notifications_operatorSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    operator_id?: boolean
    data?: boolean
    notification_type?: boolean
    priority?: boolean
    action_required?: boolean
    action_type?: boolean
    action_data?: boolean
    expiry_date?: boolean
  }

  export type notifications_operatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "title" | "message" | "is_read" | "operator_id" | "data" | "notification_type" | "priority" | "action_required" | "action_type" | "action_data" | "expiry_date", ExtArgs["result"]["notifications_operator"]>
  export type notifications_operatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operators?: boolean | operatorsDefaultArgs<ExtArgs>
  }
  export type notifications_operatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operators?: boolean | operatorsDefaultArgs<ExtArgs>
  }
  export type notifications_operatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operators?: boolean | operatorsDefaultArgs<ExtArgs>
  }

  export type $notifications_operatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications_operator"
    objects: {
      operators: Prisma.$operatorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      title: string
      message: string
      is_read: boolean | null
      operator_id: string
      data: Prisma.JsonValue | null
      notification_type: string | null
      priority: string | null
      action_required: boolean | null
      action_type: string | null
      action_data: Prisma.JsonValue | null
      expiry_date: Date | null
    }, ExtArgs["result"]["notifications_operator"]>
    composites: {}
  }

  type notifications_operatorGetPayload<S extends boolean | null | undefined | notifications_operatorDefaultArgs> = $Result.GetResult<Prisma.$notifications_operatorPayload, S>

  type notifications_operatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notifications_operatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Notifications_operatorCountAggregateInputType | true
    }

  export interface notifications_operatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications_operator'], meta: { name: 'notifications_operator' } }
    /**
     * Find zero or one Notifications_operator that matches the filter.
     * @param {notifications_operatorFindUniqueArgs} args - Arguments to find a Notifications_operator
     * @example
     * // Get one Notifications_operator
     * const notifications_operator = await prisma.notifications_operator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notifications_operatorFindUniqueArgs>(args: SelectSubset<T, notifications_operatorFindUniqueArgs<ExtArgs>>): Prisma__notifications_operatorClient<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications_operator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notifications_operatorFindUniqueOrThrowArgs} args - Arguments to find a Notifications_operator
     * @example
     * // Get one Notifications_operator
     * const notifications_operator = await prisma.notifications_operator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notifications_operatorFindUniqueOrThrowArgs>(args: SelectSubset<T, notifications_operatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notifications_operatorClient<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications_operator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifications_operatorFindFirstArgs} args - Arguments to find a Notifications_operator
     * @example
     * // Get one Notifications_operator
     * const notifications_operator = await prisma.notifications_operator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notifications_operatorFindFirstArgs>(args?: SelectSubset<T, notifications_operatorFindFirstArgs<ExtArgs>>): Prisma__notifications_operatorClient<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications_operator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifications_operatorFindFirstOrThrowArgs} args - Arguments to find a Notifications_operator
     * @example
     * // Get one Notifications_operator
     * const notifications_operator = await prisma.notifications_operator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notifications_operatorFindFirstOrThrowArgs>(args?: SelectSubset<T, notifications_operatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__notifications_operatorClient<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications_operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifications_operatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications_operators
     * const notifications_operators = await prisma.notifications_operator.findMany()
     * 
     * // Get first 10 Notifications_operators
     * const notifications_operators = await prisma.notifications_operator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notifications_operatorWithIdOnly = await prisma.notifications_operator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notifications_operatorFindManyArgs>(args?: SelectSubset<T, notifications_operatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications_operator.
     * @param {notifications_operatorCreateArgs} args - Arguments to create a Notifications_operator.
     * @example
     * // Create one Notifications_operator
     * const Notifications_operator = await prisma.notifications_operator.create({
     *   data: {
     *     // ... data to create a Notifications_operator
     *   }
     * })
     * 
     */
    create<T extends notifications_operatorCreateArgs>(args: SelectSubset<T, notifications_operatorCreateArgs<ExtArgs>>): Prisma__notifications_operatorClient<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications_operators.
     * @param {notifications_operatorCreateManyArgs} args - Arguments to create many Notifications_operators.
     * @example
     * // Create many Notifications_operators
     * const notifications_operator = await prisma.notifications_operator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notifications_operatorCreateManyArgs>(args?: SelectSubset<T, notifications_operatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications_operators and returns the data saved in the database.
     * @param {notifications_operatorCreateManyAndReturnArgs} args - Arguments to create many Notifications_operators.
     * @example
     * // Create many Notifications_operators
     * const notifications_operator = await prisma.notifications_operator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications_operators and only return the `id`
     * const notifications_operatorWithIdOnly = await prisma.notifications_operator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notifications_operatorCreateManyAndReturnArgs>(args?: SelectSubset<T, notifications_operatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications_operator.
     * @param {notifications_operatorDeleteArgs} args - Arguments to delete one Notifications_operator.
     * @example
     * // Delete one Notifications_operator
     * const Notifications_operator = await prisma.notifications_operator.delete({
     *   where: {
     *     // ... filter to delete one Notifications_operator
     *   }
     * })
     * 
     */
    delete<T extends notifications_operatorDeleteArgs>(args: SelectSubset<T, notifications_operatorDeleteArgs<ExtArgs>>): Prisma__notifications_operatorClient<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications_operator.
     * @param {notifications_operatorUpdateArgs} args - Arguments to update one Notifications_operator.
     * @example
     * // Update one Notifications_operator
     * const notifications_operator = await prisma.notifications_operator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notifications_operatorUpdateArgs>(args: SelectSubset<T, notifications_operatorUpdateArgs<ExtArgs>>): Prisma__notifications_operatorClient<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications_operators.
     * @param {notifications_operatorDeleteManyArgs} args - Arguments to filter Notifications_operators to delete.
     * @example
     * // Delete a few Notifications_operators
     * const { count } = await prisma.notifications_operator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notifications_operatorDeleteManyArgs>(args?: SelectSubset<T, notifications_operatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications_operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifications_operatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications_operators
     * const notifications_operator = await prisma.notifications_operator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notifications_operatorUpdateManyArgs>(args: SelectSubset<T, notifications_operatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications_operators and returns the data updated in the database.
     * @param {notifications_operatorUpdateManyAndReturnArgs} args - Arguments to update many Notifications_operators.
     * @example
     * // Update many Notifications_operators
     * const notifications_operator = await prisma.notifications_operator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications_operators and only return the `id`
     * const notifications_operatorWithIdOnly = await prisma.notifications_operator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notifications_operatorUpdateManyAndReturnArgs>(args: SelectSubset<T, notifications_operatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications_operator.
     * @param {notifications_operatorUpsertArgs} args - Arguments to update or create a Notifications_operator.
     * @example
     * // Update or create a Notifications_operator
     * const notifications_operator = await prisma.notifications_operator.upsert({
     *   create: {
     *     // ... data to create a Notifications_operator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications_operator we want to update
     *   }
     * })
     */
    upsert<T extends notifications_operatorUpsertArgs>(args: SelectSubset<T, notifications_operatorUpsertArgs<ExtArgs>>): Prisma__notifications_operatorClient<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications_operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifications_operatorCountArgs} args - Arguments to filter Notifications_operators to count.
     * @example
     * // Count the number of Notifications_operators
     * const count = await prisma.notifications_operator.count({
     *   where: {
     *     // ... the filter for the Notifications_operators we want to count
     *   }
     * })
    **/
    count<T extends notifications_operatorCountArgs>(
      args?: Subset<T, notifications_operatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notifications_operatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications_operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notifications_operatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notifications_operatorAggregateArgs>(args: Subset<T, Notifications_operatorAggregateArgs>): Prisma.PrismaPromise<GetNotifications_operatorAggregateType<T>>

    /**
     * Group by Notifications_operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifications_operatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notifications_operatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notifications_operatorGroupByArgs['orderBy'] }
        : { orderBy?: notifications_operatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notifications_operatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotifications_operatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications_operator model
   */
  readonly fields: notifications_operatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications_operator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notifications_operatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operators<T extends operatorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, operatorsDefaultArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications_operator model
   */ 
  interface notifications_operatorFieldRefs {
    readonly id: FieldRef<"notifications_operator", 'String'>
    readonly created_at: FieldRef<"notifications_operator", 'DateTime'>
    readonly updated_at: FieldRef<"notifications_operator", 'DateTime'>
    readonly title: FieldRef<"notifications_operator", 'String'>
    readonly message: FieldRef<"notifications_operator", 'String'>
    readonly is_read: FieldRef<"notifications_operator", 'Boolean'>
    readonly operator_id: FieldRef<"notifications_operator", 'String'>
    readonly data: FieldRef<"notifications_operator", 'Json'>
    readonly notification_type: FieldRef<"notifications_operator", 'String'>
    readonly priority: FieldRef<"notifications_operator", 'String'>
    readonly action_required: FieldRef<"notifications_operator", 'Boolean'>
    readonly action_type: FieldRef<"notifications_operator", 'String'>
    readonly action_data: FieldRef<"notifications_operator", 'Json'>
    readonly expiry_date: FieldRef<"notifications_operator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications_operator findUnique
   */
  export type notifications_operatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * Filter, which notifications_operator to fetch.
     */
    where: notifications_operatorWhereUniqueInput
  }

  /**
   * notifications_operator findUniqueOrThrow
   */
  export type notifications_operatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * Filter, which notifications_operator to fetch.
     */
    where: notifications_operatorWhereUniqueInput
  }

  /**
   * notifications_operator findFirst
   */
  export type notifications_operatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * Filter, which notifications_operator to fetch.
     */
    where?: notifications_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications_operators to fetch.
     */
    orderBy?: notifications_operatorOrderByWithRelationInput | notifications_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications_operators.
     */
    cursor?: notifications_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications_operators.
     */
    distinct?: Notifications_operatorScalarFieldEnum | Notifications_operatorScalarFieldEnum[]
  }

  /**
   * notifications_operator findFirstOrThrow
   */
  export type notifications_operatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * Filter, which notifications_operator to fetch.
     */
    where?: notifications_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications_operators to fetch.
     */
    orderBy?: notifications_operatorOrderByWithRelationInput | notifications_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications_operators.
     */
    cursor?: notifications_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications_operators.
     */
    distinct?: Notifications_operatorScalarFieldEnum | Notifications_operatorScalarFieldEnum[]
  }

  /**
   * notifications_operator findMany
   */
  export type notifications_operatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * Filter, which notifications_operators to fetch.
     */
    where?: notifications_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications_operators to fetch.
     */
    orderBy?: notifications_operatorOrderByWithRelationInput | notifications_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications_operators.
     */
    cursor?: notifications_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications_operators.
     */
    skip?: number
    distinct?: Notifications_operatorScalarFieldEnum | Notifications_operatorScalarFieldEnum[]
  }

  /**
   * notifications_operator create
   */
  export type notifications_operatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications_operator.
     */
    data: XOR<notifications_operatorCreateInput, notifications_operatorUncheckedCreateInput>
  }

  /**
   * notifications_operator createMany
   */
  export type notifications_operatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications_operators.
     */
    data: notifications_operatorCreateManyInput | notifications_operatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications_operator createManyAndReturn
   */
  export type notifications_operatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * The data used to create many notifications_operators.
     */
    data: notifications_operatorCreateManyInput | notifications_operatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications_operator update
   */
  export type notifications_operatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications_operator.
     */
    data: XOR<notifications_operatorUpdateInput, notifications_operatorUncheckedUpdateInput>
    /**
     * Choose, which notifications_operator to update.
     */
    where: notifications_operatorWhereUniqueInput
  }

  /**
   * notifications_operator updateMany
   */
  export type notifications_operatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications_operators.
     */
    data: XOR<notifications_operatorUpdateManyMutationInput, notifications_operatorUncheckedUpdateManyInput>
    /**
     * Filter which notifications_operators to update
     */
    where?: notifications_operatorWhereInput
    /**
     * Limit how many notifications_operators to update.
     */
    limit?: number
  }

  /**
   * notifications_operator updateManyAndReturn
   */
  export type notifications_operatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * The data used to update notifications_operators.
     */
    data: XOR<notifications_operatorUpdateManyMutationInput, notifications_operatorUncheckedUpdateManyInput>
    /**
     * Filter which notifications_operators to update
     */
    where?: notifications_operatorWhereInput
    /**
     * Limit how many notifications_operators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications_operator upsert
   */
  export type notifications_operatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications_operator to update in case it exists.
     */
    where: notifications_operatorWhereUniqueInput
    /**
     * In case the notifications_operator found by the `where` argument doesn't exist, create a new notifications_operator with this data.
     */
    create: XOR<notifications_operatorCreateInput, notifications_operatorUncheckedCreateInput>
    /**
     * In case the notifications_operator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notifications_operatorUpdateInput, notifications_operatorUncheckedUpdateInput>
  }

  /**
   * notifications_operator delete
   */
  export type notifications_operatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    /**
     * Filter which notifications_operator to delete.
     */
    where: notifications_operatorWhereUniqueInput
  }

  /**
   * notifications_operator deleteMany
   */
  export type notifications_operatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications_operators to delete
     */
    where?: notifications_operatorWhereInput
    /**
     * Limit how many notifications_operators to delete.
     */
    limit?: number
  }

  /**
   * notifications_operator without action
   */
  export type notifications_operatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
  }


  /**
   * Model operator_types
   */

  export type AggregateOperator_types = {
    _count: Operator_typesCountAggregateOutputType | null
    _min: Operator_typesMinAggregateOutputType | null
    _max: Operator_typesMaxAggregateOutputType | null
  }

  export type Operator_typesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
  }

  export type Operator_typesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
  }

  export type Operator_typesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    description: number
    permissions: number
    _all: number
  }


  export type Operator_typesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
  }

  export type Operator_typesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
  }

  export type Operator_typesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    permissions?: true
    _all?: true
  }

  export type Operator_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operator_types to aggregate.
     */
    where?: operator_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operator_types to fetch.
     */
    orderBy?: operator_typesOrderByWithRelationInput | operator_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operator_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operator_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operator_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operator_types
    **/
    _count?: true | Operator_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Operator_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Operator_typesMaxAggregateInputType
  }

  export type GetOperator_typesAggregateType<T extends Operator_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateOperator_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperator_types[P]>
      : GetScalarType<T[P], AggregateOperator_types[P]>
  }




  export type operator_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operator_typesWhereInput
    orderBy?: operator_typesOrderByWithAggregationInput | operator_typesOrderByWithAggregationInput[]
    by: Operator_typesScalarFieldEnum[] | Operator_typesScalarFieldEnum
    having?: operator_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Operator_typesCountAggregateInputType | true
    _min?: Operator_typesMinAggregateInputType
    _max?: Operator_typesMaxAggregateInputType
  }

  export type Operator_typesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    name: string
    description: string | null
    permissions: JsonValue | null
    _count: Operator_typesCountAggregateOutputType | null
    _min: Operator_typesMinAggregateOutputType | null
    _max: Operator_typesMaxAggregateOutputType | null
  }

  type GetOperator_typesGroupByPayload<T extends operator_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Operator_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Operator_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Operator_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Operator_typesGroupByOutputType[P]>
        }
      >
    >


  export type operator_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    operators?: boolean | operator_types$operatorsArgs<ExtArgs>
    _count?: boolean | Operator_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator_types"]>

  export type operator_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
  }, ExtArgs["result"]["operator_types"]>

  export type operator_typesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
  }, ExtArgs["result"]["operator_types"]>

  export type operator_typesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
  }

  export type operator_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "description" | "permissions", ExtArgs["result"]["operator_types"]>
  export type operator_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operators?: boolean | operator_types$operatorsArgs<ExtArgs>
    _count?: boolean | Operator_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type operator_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type operator_typesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $operator_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "operator_types"
    objects: {
      operators: Prisma.$operatorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      name: string
      description: string | null
      permissions: Prisma.JsonValue | null
    }, ExtArgs["result"]["operator_types"]>
    composites: {}
  }

  type operator_typesGetPayload<S extends boolean | null | undefined | operator_typesDefaultArgs> = $Result.GetResult<Prisma.$operator_typesPayload, S>

  type operator_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<operator_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Operator_typesCountAggregateInputType | true
    }

  export interface operator_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operator_types'], meta: { name: 'operator_types' } }
    /**
     * Find zero or one Operator_types that matches the filter.
     * @param {operator_typesFindUniqueArgs} args - Arguments to find a Operator_types
     * @example
     * // Get one Operator_types
     * const operator_types = await prisma.operator_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends operator_typesFindUniqueArgs>(args: SelectSubset<T, operator_typesFindUniqueArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Operator_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {operator_typesFindUniqueOrThrowArgs} args - Arguments to find a Operator_types
     * @example
     * // Get one Operator_types
     * const operator_types = await prisma.operator_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends operator_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, operator_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operator_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operator_typesFindFirstArgs} args - Arguments to find a Operator_types
     * @example
     * // Get one Operator_types
     * const operator_types = await prisma.operator_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends operator_typesFindFirstArgs>(args?: SelectSubset<T, operator_typesFindFirstArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operator_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operator_typesFindFirstOrThrowArgs} args - Arguments to find a Operator_types
     * @example
     * // Get one Operator_types
     * const operator_types = await prisma.operator_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends operator_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, operator_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Operator_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operator_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operator_types
     * const operator_types = await prisma.operator_types.findMany()
     * 
     * // Get first 10 Operator_types
     * const operator_types = await prisma.operator_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operator_typesWithIdOnly = await prisma.operator_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends operator_typesFindManyArgs>(args?: SelectSubset<T, operator_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Operator_types.
     * @param {operator_typesCreateArgs} args - Arguments to create a Operator_types.
     * @example
     * // Create one Operator_types
     * const Operator_types = await prisma.operator_types.create({
     *   data: {
     *     // ... data to create a Operator_types
     *   }
     * })
     * 
     */
    create<T extends operator_typesCreateArgs>(args: SelectSubset<T, operator_typesCreateArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Operator_types.
     * @param {operator_typesCreateManyArgs} args - Arguments to create many Operator_types.
     * @example
     * // Create many Operator_types
     * const operator_types = await prisma.operator_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends operator_typesCreateManyArgs>(args?: SelectSubset<T, operator_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operator_types and returns the data saved in the database.
     * @param {operator_typesCreateManyAndReturnArgs} args - Arguments to create many Operator_types.
     * @example
     * // Create many Operator_types
     * const operator_types = await prisma.operator_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operator_types and only return the `id`
     * const operator_typesWithIdOnly = await prisma.operator_types.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends operator_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, operator_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Operator_types.
     * @param {operator_typesDeleteArgs} args - Arguments to delete one Operator_types.
     * @example
     * // Delete one Operator_types
     * const Operator_types = await prisma.operator_types.delete({
     *   where: {
     *     // ... filter to delete one Operator_types
     *   }
     * })
     * 
     */
    delete<T extends operator_typesDeleteArgs>(args: SelectSubset<T, operator_typesDeleteArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Operator_types.
     * @param {operator_typesUpdateArgs} args - Arguments to update one Operator_types.
     * @example
     * // Update one Operator_types
     * const operator_types = await prisma.operator_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends operator_typesUpdateArgs>(args: SelectSubset<T, operator_typesUpdateArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Operator_types.
     * @param {operator_typesDeleteManyArgs} args - Arguments to filter Operator_types to delete.
     * @example
     * // Delete a few Operator_types
     * const { count } = await prisma.operator_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends operator_typesDeleteManyArgs>(args?: SelectSubset<T, operator_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operator_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operator_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operator_types
     * const operator_types = await prisma.operator_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends operator_typesUpdateManyArgs>(args: SelectSubset<T, operator_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operator_types and returns the data updated in the database.
     * @param {operator_typesUpdateManyAndReturnArgs} args - Arguments to update many Operator_types.
     * @example
     * // Update many Operator_types
     * const operator_types = await prisma.operator_types.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operator_types and only return the `id`
     * const operator_typesWithIdOnly = await prisma.operator_types.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends operator_typesUpdateManyAndReturnArgs>(args: SelectSubset<T, operator_typesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Operator_types.
     * @param {operator_typesUpsertArgs} args - Arguments to update or create a Operator_types.
     * @example
     * // Update or create a Operator_types
     * const operator_types = await prisma.operator_types.upsert({
     *   create: {
     *     // ... data to create a Operator_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operator_types we want to update
     *   }
     * })
     */
    upsert<T extends operator_typesUpsertArgs>(args: SelectSubset<T, operator_typesUpsertArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Operator_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operator_typesCountArgs} args - Arguments to filter Operator_types to count.
     * @example
     * // Count the number of Operator_types
     * const count = await prisma.operator_types.count({
     *   where: {
     *     // ... the filter for the Operator_types we want to count
     *   }
     * })
    **/
    count<T extends operator_typesCountArgs>(
      args?: Subset<T, operator_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Operator_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operator_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operator_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Operator_typesAggregateArgs>(args: Subset<T, Operator_typesAggregateArgs>): Prisma.PrismaPromise<GetOperator_typesAggregateType<T>>

    /**
     * Group by Operator_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operator_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operator_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operator_typesGroupByArgs['orderBy'] }
        : { orderBy?: operator_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operator_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperator_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the operator_types model
   */
  readonly fields: operator_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for operator_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__operator_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operators<T extends operator_types$operatorsArgs<ExtArgs> = {}>(args?: Subset<T, operator_types$operatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the operator_types model
   */ 
  interface operator_typesFieldRefs {
    readonly id: FieldRef<"operator_types", 'String'>
    readonly created_at: FieldRef<"operator_types", 'DateTime'>
    readonly updated_at: FieldRef<"operator_types", 'DateTime'>
    readonly name: FieldRef<"operator_types", 'String'>
    readonly description: FieldRef<"operator_types", 'String'>
    readonly permissions: FieldRef<"operator_types", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * operator_types findUnique
   */
  export type operator_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * Filter, which operator_types to fetch.
     */
    where: operator_typesWhereUniqueInput
  }

  /**
   * operator_types findUniqueOrThrow
   */
  export type operator_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * Filter, which operator_types to fetch.
     */
    where: operator_typesWhereUniqueInput
  }

  /**
   * operator_types findFirst
   */
  export type operator_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * Filter, which operator_types to fetch.
     */
    where?: operator_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operator_types to fetch.
     */
    orderBy?: operator_typesOrderByWithRelationInput | operator_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operator_types.
     */
    cursor?: operator_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operator_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operator_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operator_types.
     */
    distinct?: Operator_typesScalarFieldEnum | Operator_typesScalarFieldEnum[]
  }

  /**
   * operator_types findFirstOrThrow
   */
  export type operator_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * Filter, which operator_types to fetch.
     */
    where?: operator_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operator_types to fetch.
     */
    orderBy?: operator_typesOrderByWithRelationInput | operator_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operator_types.
     */
    cursor?: operator_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operator_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operator_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operator_types.
     */
    distinct?: Operator_typesScalarFieldEnum | Operator_typesScalarFieldEnum[]
  }

  /**
   * operator_types findMany
   */
  export type operator_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * Filter, which operator_types to fetch.
     */
    where?: operator_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operator_types to fetch.
     */
    orderBy?: operator_typesOrderByWithRelationInput | operator_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operator_types.
     */
    cursor?: operator_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operator_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operator_types.
     */
    skip?: number
    distinct?: Operator_typesScalarFieldEnum | Operator_typesScalarFieldEnum[]
  }

  /**
   * operator_types create
   */
  export type operator_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a operator_types.
     */
    data: XOR<operator_typesCreateInput, operator_typesUncheckedCreateInput>
  }

  /**
   * operator_types createMany
   */
  export type operator_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operator_types.
     */
    data: operator_typesCreateManyInput | operator_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * operator_types createManyAndReturn
   */
  export type operator_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * The data used to create many operator_types.
     */
    data: operator_typesCreateManyInput | operator_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * operator_types update
   */
  export type operator_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a operator_types.
     */
    data: XOR<operator_typesUpdateInput, operator_typesUncheckedUpdateInput>
    /**
     * Choose, which operator_types to update.
     */
    where: operator_typesWhereUniqueInput
  }

  /**
   * operator_types updateMany
   */
  export type operator_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operator_types.
     */
    data: XOR<operator_typesUpdateManyMutationInput, operator_typesUncheckedUpdateManyInput>
    /**
     * Filter which operator_types to update
     */
    where?: operator_typesWhereInput
    /**
     * Limit how many operator_types to update.
     */
    limit?: number
  }

  /**
   * operator_types updateManyAndReturn
   */
  export type operator_typesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * The data used to update operator_types.
     */
    data: XOR<operator_typesUpdateManyMutationInput, operator_typesUncheckedUpdateManyInput>
    /**
     * Filter which operator_types to update
     */
    where?: operator_typesWhereInput
    /**
     * Limit how many operator_types to update.
     */
    limit?: number
  }

  /**
   * operator_types upsert
   */
  export type operator_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the operator_types to update in case it exists.
     */
    where: operator_typesWhereUniqueInput
    /**
     * In case the operator_types found by the `where` argument doesn't exist, create a new operator_types with this data.
     */
    create: XOR<operator_typesCreateInput, operator_typesUncheckedCreateInput>
    /**
     * In case the operator_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operator_typesUpdateInput, operator_typesUncheckedUpdateInput>
  }

  /**
   * operator_types delete
   */
  export type operator_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
    /**
     * Filter which operator_types to delete.
     */
    where: operator_typesWhereUniqueInput
  }

  /**
   * operator_types deleteMany
   */
  export type operator_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operator_types to delete
     */
    where?: operator_typesWhereInput
    /**
     * Limit how many operator_types to delete.
     */
    limit?: number
  }

  /**
   * operator_types.operators
   */
  export type operator_types$operatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    where?: operatorsWhereInput
    orderBy?: operatorsOrderByWithRelationInput | operatorsOrderByWithRelationInput[]
    cursor?: operatorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorsScalarFieldEnum | OperatorsScalarFieldEnum[]
  }

  /**
   * operator_types without action
   */
  export type operator_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator_types
     */
    select?: operator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator_types
     */
    omit?: operator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operator_typesInclude<ExtArgs> | null
  }


  /**
   * Model operators
   */

  export type AggregateOperators = {
    _count: OperatorsCountAggregateOutputType | null
    _min: OperatorsMinAggregateOutputType | null
    _max: OperatorsMaxAggregateOutputType | null
  }

  export type OperatorsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    phone: string | null
    photo: string | null
    role: $Enums.operator_role_enum | null
    status: $Enums.operator_status_enum | null
    last_login_at: Date | null
    branch_id: string | null
    type_operator_id: string | null
    position: string | null
    hire_date: Date | null
    birth_date: Date | null
    personal_id: string | null
    address: string | null
  }

  export type OperatorsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    phone: string | null
    photo: string | null
    role: $Enums.operator_role_enum | null
    status: $Enums.operator_status_enum | null
    last_login_at: Date | null
    branch_id: string | null
    type_operator_id: string | null
    position: string | null
    hire_date: Date | null
    birth_date: Date | null
    personal_id: string | null
    address: string | null
  }

  export type OperatorsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    email: number
    password: number
    first_name: number
    last_name: number
    phone: number
    photo: number
    role: number
    status: number
    last_login_at: number
    branch_id: number
    type_operator_id: number
    position: number
    hire_date: number
    birth_date: number
    emergency_contact: number
    skills: number
    personal_id: number
    address: number
    _all: number
  }


  export type OperatorsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    phone?: true
    photo?: true
    role?: true
    status?: true
    last_login_at?: true
    branch_id?: true
    type_operator_id?: true
    position?: true
    hire_date?: true
    birth_date?: true
    personal_id?: true
    address?: true
  }

  export type OperatorsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    phone?: true
    photo?: true
    role?: true
    status?: true
    last_login_at?: true
    branch_id?: true
    type_operator_id?: true
    position?: true
    hire_date?: true
    birth_date?: true
    personal_id?: true
    address?: true
  }

  export type OperatorsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    phone?: true
    photo?: true
    role?: true
    status?: true
    last_login_at?: true
    branch_id?: true
    type_operator_id?: true
    position?: true
    hire_date?: true
    birth_date?: true
    emergency_contact?: true
    skills?: true
    personal_id?: true
    address?: true
    _all?: true
  }

  export type OperatorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operators to aggregate.
     */
    where?: operatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operators to fetch.
     */
    orderBy?: operatorsOrderByWithRelationInput | operatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operators
    **/
    _count?: true | OperatorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorsMaxAggregateInputType
  }

  export type GetOperatorsAggregateType<T extends OperatorsAggregateArgs> = {
        [P in keyof T & keyof AggregateOperators]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperators[P]>
      : GetScalarType<T[P], AggregateOperators[P]>
  }




  export type operatorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operatorsWhereInput
    orderBy?: operatorsOrderByWithAggregationInput | operatorsOrderByWithAggregationInput[]
    by: OperatorsScalarFieldEnum[] | OperatorsScalarFieldEnum
    having?: operatorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorsCountAggregateInputType | true
    _min?: OperatorsMinAggregateInputType
    _max?: OperatorsMaxAggregateInputType
  }

  export type OperatorsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone: string | null
    photo: string | null
    role: $Enums.operator_role_enum
    status: $Enums.operator_status_enum
    last_login_at: Date | null
    branch_id: string
    type_operator_id: string
    position: string | null
    hire_date: Date | null
    birth_date: Date | null
    emergency_contact: JsonValue | null
    skills: string[]
    personal_id: string | null
    address: string | null
    _count: OperatorsCountAggregateOutputType | null
    _min: OperatorsMinAggregateOutputType | null
    _max: OperatorsMaxAggregateOutputType | null
  }

  type GetOperatorsGroupByPayload<T extends operatorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorsGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorsGroupByOutputType[P]>
        }
      >
    >


  export type operatorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    photo?: boolean
    role?: boolean
    status?: boolean
    last_login_at?: boolean
    branch_id?: boolean
    type_operator_id?: boolean
    position?: boolean
    hire_date?: boolean
    birth_date?: boolean
    emergency_contact?: boolean
    skills?: boolean
    personal_id?: boolean
    address?: boolean
    activities?: boolean | operators$activitiesArgs<ExtArgs>
    email_templates?: boolean | operators$email_templatesArgs<ExtArgs>
    invoices?: boolean | operators$invoicesArgs<ExtArgs>
    notifications_operator?: boolean | operators$notifications_operatorArgs<ExtArgs>
    branches?: boolean | branchesDefaultArgs<ExtArgs>
    operator_types?: boolean | operator_typesDefaultArgs<ExtArgs>
    packages?: boolean | operators$packagesArgs<ExtArgs>
    _count?: boolean | OperatorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operators"]>

  export type operatorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    photo?: boolean
    role?: boolean
    status?: boolean
    last_login_at?: boolean
    branch_id?: boolean
    type_operator_id?: boolean
    position?: boolean
    hire_date?: boolean
    birth_date?: boolean
    emergency_contact?: boolean
    skills?: boolean
    personal_id?: boolean
    address?: boolean
    branches?: boolean | branchesDefaultArgs<ExtArgs>
    operator_types?: boolean | operator_typesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operators"]>

  export type operatorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    photo?: boolean
    role?: boolean
    status?: boolean
    last_login_at?: boolean
    branch_id?: boolean
    type_operator_id?: boolean
    position?: boolean
    hire_date?: boolean
    birth_date?: boolean
    emergency_contact?: boolean
    skills?: boolean
    personal_id?: boolean
    address?: boolean
    branches?: boolean | branchesDefaultArgs<ExtArgs>
    operator_types?: boolean | operator_typesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operators"]>

  export type operatorsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    photo?: boolean
    role?: boolean
    status?: boolean
    last_login_at?: boolean
    branch_id?: boolean
    type_operator_id?: boolean
    position?: boolean
    hire_date?: boolean
    birth_date?: boolean
    emergency_contact?: boolean
    skills?: boolean
    personal_id?: boolean
    address?: boolean
  }

  export type operatorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "email" | "password" | "first_name" | "last_name" | "phone" | "photo" | "role" | "status" | "last_login_at" | "branch_id" | "type_operator_id" | "position" | "hire_date" | "birth_date" | "emergency_contact" | "skills" | "personal_id" | "address", ExtArgs["result"]["operators"]>
  export type operatorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | operators$activitiesArgs<ExtArgs>
    email_templates?: boolean | operators$email_templatesArgs<ExtArgs>
    invoices?: boolean | operators$invoicesArgs<ExtArgs>
    notifications_operator?: boolean | operators$notifications_operatorArgs<ExtArgs>
    branches?: boolean | branchesDefaultArgs<ExtArgs>
    operator_types?: boolean | operator_typesDefaultArgs<ExtArgs>
    packages?: boolean | operators$packagesArgs<ExtArgs>
    _count?: boolean | OperatorsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type operatorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | branchesDefaultArgs<ExtArgs>
    operator_types?: boolean | operator_typesDefaultArgs<ExtArgs>
  }
  export type operatorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | branchesDefaultArgs<ExtArgs>
    operator_types?: boolean | operator_typesDefaultArgs<ExtArgs>
  }

  export type $operatorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "operators"
    objects: {
      activities: Prisma.$activitiesPayload<ExtArgs>[]
      email_templates: Prisma.$email_templatesPayload<ExtArgs>[]
      invoices: Prisma.$invoicesPayload<ExtArgs>[]
      notifications_operator: Prisma.$notifications_operatorPayload<ExtArgs>[]
      branches: Prisma.$branchesPayload<ExtArgs>
      operator_types: Prisma.$operator_typesPayload<ExtArgs>
      packages: Prisma.$packagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      email: string
      password: string
      first_name: string
      last_name: string
      phone: string | null
      photo: string | null
      role: $Enums.operator_role_enum
      status: $Enums.operator_status_enum
      last_login_at: Date | null
      branch_id: string
      type_operator_id: string
      position: string | null
      hire_date: Date | null
      birth_date: Date | null
      emergency_contact: Prisma.JsonValue | null
      skills: string[]
      personal_id: string | null
      address: string | null
    }, ExtArgs["result"]["operators"]>
    composites: {}
  }

  type operatorsGetPayload<S extends boolean | null | undefined | operatorsDefaultArgs> = $Result.GetResult<Prisma.$operatorsPayload, S>

  type operatorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<operatorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperatorsCountAggregateInputType | true
    }

  export interface operatorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operators'], meta: { name: 'operators' } }
    /**
     * Find zero or one Operators that matches the filter.
     * @param {operatorsFindUniqueArgs} args - Arguments to find a Operators
     * @example
     * // Get one Operators
     * const operators = await prisma.operators.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends operatorsFindUniqueArgs>(args: SelectSubset<T, operatorsFindUniqueArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Operators that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {operatorsFindUniqueOrThrowArgs} args - Arguments to find a Operators
     * @example
     * // Get one Operators
     * const operators = await prisma.operators.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends operatorsFindUniqueOrThrowArgs>(args: SelectSubset<T, operatorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorsFindFirstArgs} args - Arguments to find a Operators
     * @example
     * // Get one Operators
     * const operators = await prisma.operators.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends operatorsFindFirstArgs>(args?: SelectSubset<T, operatorsFindFirstArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operators that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorsFindFirstOrThrowArgs} args - Arguments to find a Operators
     * @example
     * // Get one Operators
     * const operators = await prisma.operators.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends operatorsFindFirstOrThrowArgs>(args?: SelectSubset<T, operatorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operators
     * const operators = await prisma.operators.findMany()
     * 
     * // Get first 10 Operators
     * const operators = await prisma.operators.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorsWithIdOnly = await prisma.operators.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends operatorsFindManyArgs>(args?: SelectSubset<T, operatorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Operators.
     * @param {operatorsCreateArgs} args - Arguments to create a Operators.
     * @example
     * // Create one Operators
     * const Operators = await prisma.operators.create({
     *   data: {
     *     // ... data to create a Operators
     *   }
     * })
     * 
     */
    create<T extends operatorsCreateArgs>(args: SelectSubset<T, operatorsCreateArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Operators.
     * @param {operatorsCreateManyArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operators = await prisma.operators.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends operatorsCreateManyArgs>(args?: SelectSubset<T, operatorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operators and returns the data saved in the database.
     * @param {operatorsCreateManyAndReturnArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operators = await prisma.operators.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operators and only return the `id`
     * const operatorsWithIdOnly = await prisma.operators.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends operatorsCreateManyAndReturnArgs>(args?: SelectSubset<T, operatorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Operators.
     * @param {operatorsDeleteArgs} args - Arguments to delete one Operators.
     * @example
     * // Delete one Operators
     * const Operators = await prisma.operators.delete({
     *   where: {
     *     // ... filter to delete one Operators
     *   }
     * })
     * 
     */
    delete<T extends operatorsDeleteArgs>(args: SelectSubset<T, operatorsDeleteArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Operators.
     * @param {operatorsUpdateArgs} args - Arguments to update one Operators.
     * @example
     * // Update one Operators
     * const operators = await prisma.operators.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends operatorsUpdateArgs>(args: SelectSubset<T, operatorsUpdateArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Operators.
     * @param {operatorsDeleteManyArgs} args - Arguments to filter Operators to delete.
     * @example
     * // Delete a few Operators
     * const { count } = await prisma.operators.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends operatorsDeleteManyArgs>(args?: SelectSubset<T, operatorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operators
     * const operators = await prisma.operators.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends operatorsUpdateManyArgs>(args: SelectSubset<T, operatorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators and returns the data updated in the database.
     * @param {operatorsUpdateManyAndReturnArgs} args - Arguments to update many Operators.
     * @example
     * // Update many Operators
     * const operators = await prisma.operators.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operators and only return the `id`
     * const operatorsWithIdOnly = await prisma.operators.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends operatorsUpdateManyAndReturnArgs>(args: SelectSubset<T, operatorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Operators.
     * @param {operatorsUpsertArgs} args - Arguments to update or create a Operators.
     * @example
     * // Update or create a Operators
     * const operators = await prisma.operators.upsert({
     *   create: {
     *     // ... data to create a Operators
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operators we want to update
     *   }
     * })
     */
    upsert<T extends operatorsUpsertArgs>(args: SelectSubset<T, operatorsUpsertArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorsCountArgs} args - Arguments to filter Operators to count.
     * @example
     * // Count the number of Operators
     * const count = await prisma.operators.count({
     *   where: {
     *     // ... the filter for the Operators we want to count
     *   }
     * })
    **/
    count<T extends operatorsCountArgs>(
      args?: Subset<T, operatorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorsAggregateArgs>(args: Subset<T, OperatorsAggregateArgs>): Prisma.PrismaPromise<GetOperatorsAggregateType<T>>

    /**
     * Group by Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operatorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operatorsGroupByArgs['orderBy'] }
        : { orderBy?: operatorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operatorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the operators model
   */
  readonly fields: operatorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for operators.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__operatorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends operators$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, operators$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    email_templates<T extends operators$email_templatesArgs<ExtArgs> = {}>(args?: Subset<T, operators$email_templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends operators$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, operators$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications_operator<T extends operators$notifications_operatorArgs<ExtArgs> = {}>(args?: Subset<T, operators$notifications_operatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notifications_operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branches<T extends branchesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, branchesDefaultArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    operator_types<T extends operator_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, operator_typesDefaultArgs<ExtArgs>>): Prisma__operator_typesClient<$Result.GetResult<Prisma.$operator_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    packages<T extends operators$packagesArgs<ExtArgs> = {}>(args?: Subset<T, operators$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the operators model
   */ 
  interface operatorsFieldRefs {
    readonly id: FieldRef<"operators", 'String'>
    readonly created_at: FieldRef<"operators", 'DateTime'>
    readonly updated_at: FieldRef<"operators", 'DateTime'>
    readonly email: FieldRef<"operators", 'String'>
    readonly password: FieldRef<"operators", 'String'>
    readonly first_name: FieldRef<"operators", 'String'>
    readonly last_name: FieldRef<"operators", 'String'>
    readonly phone: FieldRef<"operators", 'String'>
    readonly photo: FieldRef<"operators", 'String'>
    readonly role: FieldRef<"operators", 'operator_role_enum'>
    readonly status: FieldRef<"operators", 'operator_status_enum'>
    readonly last_login_at: FieldRef<"operators", 'DateTime'>
    readonly branch_id: FieldRef<"operators", 'String'>
    readonly type_operator_id: FieldRef<"operators", 'String'>
    readonly position: FieldRef<"operators", 'String'>
    readonly hire_date: FieldRef<"operators", 'DateTime'>
    readonly birth_date: FieldRef<"operators", 'DateTime'>
    readonly emergency_contact: FieldRef<"operators", 'Json'>
    readonly skills: FieldRef<"operators", 'String[]'>
    readonly personal_id: FieldRef<"operators", 'String'>
    readonly address: FieldRef<"operators", 'String'>
  }
    

  // Custom InputTypes
  /**
   * operators findUnique
   */
  export type operatorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * Filter, which operators to fetch.
     */
    where: operatorsWhereUniqueInput
  }

  /**
   * operators findUniqueOrThrow
   */
  export type operatorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * Filter, which operators to fetch.
     */
    where: operatorsWhereUniqueInput
  }

  /**
   * operators findFirst
   */
  export type operatorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * Filter, which operators to fetch.
     */
    where?: operatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operators to fetch.
     */
    orderBy?: operatorsOrderByWithRelationInput | operatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operators.
     */
    cursor?: operatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operators.
     */
    distinct?: OperatorsScalarFieldEnum | OperatorsScalarFieldEnum[]
  }

  /**
   * operators findFirstOrThrow
   */
  export type operatorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * Filter, which operators to fetch.
     */
    where?: operatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operators to fetch.
     */
    orderBy?: operatorsOrderByWithRelationInput | operatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operators.
     */
    cursor?: operatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operators.
     */
    distinct?: OperatorsScalarFieldEnum | OperatorsScalarFieldEnum[]
  }

  /**
   * operators findMany
   */
  export type operatorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * Filter, which operators to fetch.
     */
    where?: operatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operators to fetch.
     */
    orderBy?: operatorsOrderByWithRelationInput | operatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operators.
     */
    cursor?: operatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operators.
     */
    skip?: number
    distinct?: OperatorsScalarFieldEnum | OperatorsScalarFieldEnum[]
  }

  /**
   * operators create
   */
  export type operatorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * The data needed to create a operators.
     */
    data: XOR<operatorsCreateInput, operatorsUncheckedCreateInput>
  }

  /**
   * operators createMany
   */
  export type operatorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operators.
     */
    data: operatorsCreateManyInput | operatorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * operators createManyAndReturn
   */
  export type operatorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * The data used to create many operators.
     */
    data: operatorsCreateManyInput | operatorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * operators update
   */
  export type operatorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * The data needed to update a operators.
     */
    data: XOR<operatorsUpdateInput, operatorsUncheckedUpdateInput>
    /**
     * Choose, which operators to update.
     */
    where: operatorsWhereUniqueInput
  }

  /**
   * operators updateMany
   */
  export type operatorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operators.
     */
    data: XOR<operatorsUpdateManyMutationInput, operatorsUncheckedUpdateManyInput>
    /**
     * Filter which operators to update
     */
    where?: operatorsWhereInput
    /**
     * Limit how many operators to update.
     */
    limit?: number
  }

  /**
   * operators updateManyAndReturn
   */
  export type operatorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * The data used to update operators.
     */
    data: XOR<operatorsUpdateManyMutationInput, operatorsUncheckedUpdateManyInput>
    /**
     * Filter which operators to update
     */
    where?: operatorsWhereInput
    /**
     * Limit how many operators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * operators upsert
   */
  export type operatorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * The filter to search for the operators to update in case it exists.
     */
    where: operatorsWhereUniqueInput
    /**
     * In case the operators found by the `where` argument doesn't exist, create a new operators with this data.
     */
    create: XOR<operatorsCreateInput, operatorsUncheckedCreateInput>
    /**
     * In case the operators was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operatorsUpdateInput, operatorsUncheckedUpdateInput>
  }

  /**
   * operators delete
   */
  export type operatorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    /**
     * Filter which operators to delete.
     */
    where: operatorsWhereUniqueInput
  }

  /**
   * operators deleteMany
   */
  export type operatorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operators to delete
     */
    where?: operatorsWhereInput
    /**
     * Limit how many operators to delete.
     */
    limit?: number
  }

  /**
   * operators.activities
   */
  export type operators$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activities
     */
    select?: activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activities
     */
    omit?: activitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitiesInclude<ExtArgs> | null
    where?: activitiesWhereInput
    orderBy?: activitiesOrderByWithRelationInput | activitiesOrderByWithRelationInput[]
    cursor?: activitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivitiesScalarFieldEnum | ActivitiesScalarFieldEnum[]
  }

  /**
   * operators.email_templates
   */
  export type operators$email_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_templatesInclude<ExtArgs> | null
    where?: email_templatesWhereInput
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    cursor?: email_templatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * operators.invoices
   */
  export type operators$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    cursor?: invoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * operators.notifications_operator
   */
  export type operators$notifications_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications_operator
     */
    select?: notifications_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications_operator
     */
    omit?: notifications_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifications_operatorInclude<ExtArgs> | null
    where?: notifications_operatorWhereInput
    orderBy?: notifications_operatorOrderByWithRelationInput | notifications_operatorOrderByWithRelationInput[]
    cursor?: notifications_operatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Notifications_operatorScalarFieldEnum | Notifications_operatorScalarFieldEnum[]
  }

  /**
   * operators.packages
   */
  export type operators$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    where?: packagesWhereInput
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    cursor?: packagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * operators without action
   */
  export type operatorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
  }


  /**
   * Model packages
   */

  export type AggregatePackages = {
    _count: PackagesCountAggregateOutputType | null
    _avg: PackagesAvgAggregateOutputType | null
    _sum: PackagesSumAggregateOutputType | null
    _min: PackagesMinAggregateOutputType | null
    _max: PackagesMaxAggregateOutputType | null
  }

  export type PackagesAvgAggregateOutputType = {
    height: Decimal | null
    width: Decimal | null
    length: Decimal | null
    weight: Decimal | null
    volumetric_weight: Decimal | null
    declared_value: Decimal | null
  }

  export type PackagesSumAggregateOutputType = {
    height: Decimal | null
    width: Decimal | null
    length: Decimal | null
    weight: Decimal | null
    volumetric_weight: Decimal | null
    declared_value: Decimal | null
  }

  export type PackagesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_reference: string | null
    package_status: $Enums.package_status_enum | null
    tracking_number: string | null
    height: Decimal | null
    width: Decimal | null
    length: Decimal | null
    weight: Decimal | null
    volumetric_weight: Decimal | null
    insurance: boolean | null
    branch_id: string | null
    notes: string | null
    declared_value: Decimal | null
    is_fragile: boolean | null
    estimated_delivery_date: Date | null
    operator_id: string | null
    position: string | null
  }

  export type PackagesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    user_reference: string | null
    package_status: $Enums.package_status_enum | null
    tracking_number: string | null
    height: Decimal | null
    width: Decimal | null
    length: Decimal | null
    weight: Decimal | null
    volumetric_weight: Decimal | null
    insurance: boolean | null
    branch_id: string | null
    notes: string | null
    declared_value: Decimal | null
    is_fragile: boolean | null
    estimated_delivery_date: Date | null
    operator_id: string | null
    position: string | null
  }

  export type PackagesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    user_reference: number
    package_status: number
    tracking_number: number
    height: number
    width: number
    length: number
    weight: number
    volumetric_weight: number
    insurance: number
    shipping_stages: number
    branch_id: number
    notes: number
    declared_value: number
    customs_information: number
    is_fragile: number
    estimated_delivery_date: number
    operator_id: number
    position: number
    _all: number
  }


  export type PackagesAvgAggregateInputType = {
    height?: true
    width?: true
    length?: true
    weight?: true
    volumetric_weight?: true
    declared_value?: true
  }

  export type PackagesSumAggregateInputType = {
    height?: true
    width?: true
    length?: true
    weight?: true
    volumetric_weight?: true
    declared_value?: true
  }

  export type PackagesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_reference?: true
    package_status?: true
    tracking_number?: true
    height?: true
    width?: true
    length?: true
    weight?: true
    volumetric_weight?: true
    insurance?: true
    branch_id?: true
    notes?: true
    declared_value?: true
    is_fragile?: true
    estimated_delivery_date?: true
    operator_id?: true
    position?: true
  }

  export type PackagesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_reference?: true
    package_status?: true
    tracking_number?: true
    height?: true
    width?: true
    length?: true
    weight?: true
    volumetric_weight?: true
    insurance?: true
    branch_id?: true
    notes?: true
    declared_value?: true
    is_fragile?: true
    estimated_delivery_date?: true
    operator_id?: true
    position?: true
  }

  export type PackagesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    user_reference?: true
    package_status?: true
    tracking_number?: true
    height?: true
    width?: true
    length?: true
    weight?: true
    volumetric_weight?: true
    insurance?: true
    shipping_stages?: true
    branch_id?: true
    notes?: true
    declared_value?: true
    customs_information?: true
    is_fragile?: true
    estimated_delivery_date?: true
    operator_id?: true
    position?: true
    _all?: true
  }

  export type PackagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which packages to aggregate.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned packages
    **/
    _count?: true | PackagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackagesMaxAggregateInputType
  }

  export type GetPackagesAggregateType<T extends PackagesAggregateArgs> = {
        [P in keyof T & keyof AggregatePackages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackages[P]>
      : GetScalarType<T[P], AggregatePackages[P]>
  }




  export type packagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: packagesWhereInput
    orderBy?: packagesOrderByWithAggregationInput | packagesOrderByWithAggregationInput[]
    by: PackagesScalarFieldEnum[] | PackagesScalarFieldEnum
    having?: packagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackagesCountAggregateInputType | true
    _avg?: PackagesAvgAggregateInputType
    _sum?: PackagesSumAggregateInputType
    _min?: PackagesMinAggregateInputType
    _max?: PackagesMaxAggregateInputType
  }

  export type PackagesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    user_reference: string | null
    package_status: $Enums.package_status_enum
    tracking_number: string | null
    height: Decimal | null
    width: Decimal | null
    length: Decimal | null
    weight: Decimal | null
    volumetric_weight: Decimal | null
    insurance: boolean | null
    shipping_stages: JsonValue[]
    branch_id: string | null
    notes: string | null
    declared_value: Decimal | null
    customs_information: JsonValue | null
    is_fragile: boolean | null
    estimated_delivery_date: Date | null
    operator_id: string | null
    position: string | null
    _count: PackagesCountAggregateOutputType | null
    _avg: PackagesAvgAggregateOutputType | null
    _sum: PackagesSumAggregateOutputType | null
    _min: PackagesMinAggregateOutputType | null
    _max: PackagesMaxAggregateOutputType | null
  }

  type GetPackagesGroupByPayload<T extends packagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackagesGroupByOutputType[P]>
            : GetScalarType<T[P], PackagesGroupByOutputType[P]>
        }
      >
    >


  export type packagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_reference?: boolean
    package_status?: boolean
    tracking_number?: boolean
    height?: boolean
    width?: boolean
    length?: boolean
    weight?: boolean
    volumetric_weight?: boolean
    insurance?: boolean
    shipping_stages?: boolean
    branch_id?: boolean
    notes?: boolean
    declared_value?: boolean
    customs_information?: boolean
    is_fragile?: boolean
    estimated_delivery_date?: boolean
    operator_id?: boolean
    position?: boolean
    invoice_packages?: boolean | packages$invoice_packagesArgs<ExtArgs>
    branches?: boolean | packages$branchesArgs<ExtArgs>
    users?: boolean | packages$usersArgs<ExtArgs>
    operators?: boolean | packages$operatorsArgs<ExtArgs>
    _count?: boolean | PackagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packages"]>

  export type packagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_reference?: boolean
    package_status?: boolean
    tracking_number?: boolean
    height?: boolean
    width?: boolean
    length?: boolean
    weight?: boolean
    volumetric_weight?: boolean
    insurance?: boolean
    shipping_stages?: boolean
    branch_id?: boolean
    notes?: boolean
    declared_value?: boolean
    customs_information?: boolean
    is_fragile?: boolean
    estimated_delivery_date?: boolean
    operator_id?: boolean
    position?: boolean
    branches?: boolean | packages$branchesArgs<ExtArgs>
    users?: boolean | packages$usersArgs<ExtArgs>
    operators?: boolean | packages$operatorsArgs<ExtArgs>
  }, ExtArgs["result"]["packages"]>

  export type packagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_reference?: boolean
    package_status?: boolean
    tracking_number?: boolean
    height?: boolean
    width?: boolean
    length?: boolean
    weight?: boolean
    volumetric_weight?: boolean
    insurance?: boolean
    shipping_stages?: boolean
    branch_id?: boolean
    notes?: boolean
    declared_value?: boolean
    customs_information?: boolean
    is_fragile?: boolean
    estimated_delivery_date?: boolean
    operator_id?: boolean
    position?: boolean
    branches?: boolean | packages$branchesArgs<ExtArgs>
    users?: boolean | packages$usersArgs<ExtArgs>
    operators?: boolean | packages$operatorsArgs<ExtArgs>
  }, ExtArgs["result"]["packages"]>

  export type packagesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_reference?: boolean
    package_status?: boolean
    tracking_number?: boolean
    height?: boolean
    width?: boolean
    length?: boolean
    weight?: boolean
    volumetric_weight?: boolean
    insurance?: boolean
    shipping_stages?: boolean
    branch_id?: boolean
    notes?: boolean
    declared_value?: boolean
    customs_information?: boolean
    is_fragile?: boolean
    estimated_delivery_date?: boolean
    operator_id?: boolean
    position?: boolean
  }

  export type packagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "user_reference" | "package_status" | "tracking_number" | "height" | "width" | "length" | "weight" | "volumetric_weight" | "insurance" | "shipping_stages" | "branch_id" | "notes" | "declared_value" | "customs_information" | "is_fragile" | "estimated_delivery_date" | "operator_id" | "position", ExtArgs["result"]["packages"]>
  export type packagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_packages?: boolean | packages$invoice_packagesArgs<ExtArgs>
    branches?: boolean | packages$branchesArgs<ExtArgs>
    users?: boolean | packages$usersArgs<ExtArgs>
    operators?: boolean | packages$operatorsArgs<ExtArgs>
    _count?: boolean | PackagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type packagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | packages$branchesArgs<ExtArgs>
    users?: boolean | packages$usersArgs<ExtArgs>
    operators?: boolean | packages$operatorsArgs<ExtArgs>
  }
  export type packagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | packages$branchesArgs<ExtArgs>
    users?: boolean | packages$usersArgs<ExtArgs>
    operators?: boolean | packages$operatorsArgs<ExtArgs>
  }

  export type $packagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "packages"
    objects: {
      invoice_packages: Prisma.$invoice_packagesPayload<ExtArgs>[]
      branches: Prisma.$branchesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
      operators: Prisma.$operatorsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      user_reference: string | null
      package_status: $Enums.package_status_enum
      tracking_number: string | null
      height: Prisma.Decimal | null
      width: Prisma.Decimal | null
      length: Prisma.Decimal | null
      weight: Prisma.Decimal | null
      volumetric_weight: Prisma.Decimal | null
      insurance: boolean | null
      shipping_stages: Prisma.JsonValue[]
      branch_id: string | null
      notes: string | null
      declared_value: Prisma.Decimal | null
      customs_information: Prisma.JsonValue | null
      is_fragile: boolean | null
      estimated_delivery_date: Date | null
      operator_id: string | null
      position: string | null
    }, ExtArgs["result"]["packages"]>
    composites: {}
  }

  type packagesGetPayload<S extends boolean | null | undefined | packagesDefaultArgs> = $Result.GetResult<Prisma.$packagesPayload, S>

  type packagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<packagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackagesCountAggregateInputType | true
    }

  export interface packagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['packages'], meta: { name: 'packages' } }
    /**
     * Find zero or one Packages that matches the filter.
     * @param {packagesFindUniqueArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends packagesFindUniqueArgs>(args: SelectSubset<T, packagesFindUniqueArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Packages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {packagesFindUniqueOrThrowArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends packagesFindUniqueOrThrowArgs>(args: SelectSubset<T, packagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindFirstArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends packagesFindFirstArgs>(args?: SelectSubset<T, packagesFindFirstArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Packages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindFirstOrThrowArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends packagesFindFirstOrThrowArgs>(args?: SelectSubset<T, packagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.packages.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.packages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packagesWithIdOnly = await prisma.packages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends packagesFindManyArgs>(args?: SelectSubset<T, packagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Packages.
     * @param {packagesCreateArgs} args - Arguments to create a Packages.
     * @example
     * // Create one Packages
     * const Packages = await prisma.packages.create({
     *   data: {
     *     // ... data to create a Packages
     *   }
     * })
     * 
     */
    create<T extends packagesCreateArgs>(args: SelectSubset<T, packagesCreateArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {packagesCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const packages = await prisma.packages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends packagesCreateManyArgs>(args?: SelectSubset<T, packagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Packages and returns the data saved in the database.
     * @param {packagesCreateManyAndReturnArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const packages = await prisma.packages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Packages and only return the `id`
     * const packagesWithIdOnly = await prisma.packages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends packagesCreateManyAndReturnArgs>(args?: SelectSubset<T, packagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Packages.
     * @param {packagesDeleteArgs} args - Arguments to delete one Packages.
     * @example
     * // Delete one Packages
     * const Packages = await prisma.packages.delete({
     *   where: {
     *     // ... filter to delete one Packages
     *   }
     * })
     * 
     */
    delete<T extends packagesDeleteArgs>(args: SelectSubset<T, packagesDeleteArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Packages.
     * @param {packagesUpdateArgs} args - Arguments to update one Packages.
     * @example
     * // Update one Packages
     * const packages = await prisma.packages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends packagesUpdateArgs>(args: SelectSubset<T, packagesUpdateArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {packagesDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.packages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends packagesDeleteManyArgs>(args?: SelectSubset<T, packagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const packages = await prisma.packages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends packagesUpdateManyArgs>(args: SelectSubset<T, packagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages and returns the data updated in the database.
     * @param {packagesUpdateManyAndReturnArgs} args - Arguments to update many Packages.
     * @example
     * // Update many Packages
     * const packages = await prisma.packages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Packages and only return the `id`
     * const packagesWithIdOnly = await prisma.packages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends packagesUpdateManyAndReturnArgs>(args: SelectSubset<T, packagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Packages.
     * @param {packagesUpsertArgs} args - Arguments to update or create a Packages.
     * @example
     * // Update or create a Packages
     * const packages = await prisma.packages.upsert({
     *   create: {
     *     // ... data to create a Packages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Packages we want to update
     *   }
     * })
     */
    upsert<T extends packagesUpsertArgs>(args: SelectSubset<T, packagesUpsertArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.packages.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends packagesCountArgs>(
      args?: Subset<T, packagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackagesAggregateArgs>(args: Subset<T, PackagesAggregateArgs>): Prisma.PrismaPromise<GetPackagesAggregateType<T>>

    /**
     * Group by Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends packagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: packagesGroupByArgs['orderBy'] }
        : { orderBy?: packagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, packagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the packages model
   */
  readonly fields: packagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for packages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__packagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice_packages<T extends packages$invoice_packagesArgs<ExtArgs> = {}>(args?: Subset<T, packages$invoice_packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branches<T extends packages$branchesArgs<ExtArgs> = {}>(args?: Subset<T, packages$branchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends packages$usersArgs<ExtArgs> = {}>(args?: Subset<T, packages$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    operators<T extends packages$operatorsArgs<ExtArgs> = {}>(args?: Subset<T, packages$operatorsArgs<ExtArgs>>): Prisma__operatorsClient<$Result.GetResult<Prisma.$operatorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the packages model
   */ 
  interface packagesFieldRefs {
    readonly id: FieldRef<"packages", 'String'>
    readonly created_at: FieldRef<"packages", 'DateTime'>
    readonly updated_at: FieldRef<"packages", 'DateTime'>
    readonly user_reference: FieldRef<"packages", 'String'>
    readonly package_status: FieldRef<"packages", 'package_status_enum'>
    readonly tracking_number: FieldRef<"packages", 'String'>
    readonly height: FieldRef<"packages", 'Decimal'>
    readonly width: FieldRef<"packages", 'Decimal'>
    readonly length: FieldRef<"packages", 'Decimal'>
    readonly weight: FieldRef<"packages", 'Decimal'>
    readonly volumetric_weight: FieldRef<"packages", 'Decimal'>
    readonly insurance: FieldRef<"packages", 'Boolean'>
    readonly shipping_stages: FieldRef<"packages", 'Json[]'>
    readonly branch_id: FieldRef<"packages", 'String'>
    readonly notes: FieldRef<"packages", 'String'>
    readonly declared_value: FieldRef<"packages", 'Decimal'>
    readonly customs_information: FieldRef<"packages", 'Json'>
    readonly is_fragile: FieldRef<"packages", 'Boolean'>
    readonly estimated_delivery_date: FieldRef<"packages", 'DateTime'>
    readonly operator_id: FieldRef<"packages", 'String'>
    readonly position: FieldRef<"packages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * packages findUnique
   */
  export type packagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages findUniqueOrThrow
   */
  export type packagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages findFirst
   */
  export type packagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packages.
     */
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages findFirstOrThrow
   */
  export type packagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packages.
     */
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages findMany
   */
  export type packagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages create
   */
  export type packagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * The data needed to create a packages.
     */
    data?: XOR<packagesCreateInput, packagesUncheckedCreateInput>
  }

  /**
   * packages createMany
   */
  export type packagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many packages.
     */
    data: packagesCreateManyInput | packagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * packages createManyAndReturn
   */
  export type packagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * The data used to create many packages.
     */
    data: packagesCreateManyInput | packagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * packages update
   */
  export type packagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * The data needed to update a packages.
     */
    data: XOR<packagesUpdateInput, packagesUncheckedUpdateInput>
    /**
     * Choose, which packages to update.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages updateMany
   */
  export type packagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update packages.
     */
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyInput>
    /**
     * Filter which packages to update
     */
    where?: packagesWhereInput
    /**
     * Limit how many packages to update.
     */
    limit?: number
  }

  /**
   * packages updateManyAndReturn
   */
  export type packagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * The data used to update packages.
     */
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyInput>
    /**
     * Filter which packages to update
     */
    where?: packagesWhereInput
    /**
     * Limit how many packages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * packages upsert
   */
  export type packagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * The filter to search for the packages to update in case it exists.
     */
    where: packagesWhereUniqueInput
    /**
     * In case the packages found by the `where` argument doesn't exist, create a new packages with this data.
     */
    create: XOR<packagesCreateInput, packagesUncheckedCreateInput>
    /**
     * In case the packages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<packagesUpdateInput, packagesUncheckedUpdateInput>
  }

  /**
   * packages delete
   */
  export type packagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter which packages to delete.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages deleteMany
   */
  export type packagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which packages to delete
     */
    where?: packagesWhereInput
    /**
     * Limit how many packages to delete.
     */
    limit?: number
  }

  /**
   * packages.invoice_packages
   */
  export type packages$invoice_packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_packages
     */
    select?: invoice_packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_packages
     */
    omit?: invoice_packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_packagesInclude<ExtArgs> | null
    where?: invoice_packagesWhereInput
    orderBy?: invoice_packagesOrderByWithRelationInput | invoice_packagesOrderByWithRelationInput[]
    cursor?: invoice_packagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_packagesScalarFieldEnum | Invoice_packagesScalarFieldEnum[]
  }

  /**
   * packages.branches
   */
  export type packages$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * packages.users
   */
  export type packages$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * packages.operators
   */
  export type packages$operatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operators
     */
    select?: operatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operators
     */
    omit?: operatorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorsInclude<ExtArgs> | null
    where?: operatorsWhereInput
  }

  /**
   * packages without action
   */
  export type packagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
  }


  /**
   * Model payment_types
   */

  export type AggregatePayment_types = {
    _count: Payment_typesCountAggregateOutputType | null
    _avg: Payment_typesAvgAggregateOutputType | null
    _sum: Payment_typesSumAggregateOutputType | null
    _min: Payment_typesMinAggregateOutputType | null
    _max: Payment_typesMaxAggregateOutputType | null
  }

  export type Payment_typesAvgAggregateOutputType = {
    id: number | null
    processing_fee_percentage: Decimal | null
    processing_fee_fixed: Decimal | null
  }

  export type Payment_typesSumAggregateOutputType = {
    id: number | null
    processing_fee_percentage: Decimal | null
    processing_fee_fixed: Decimal | null
  }

  export type Payment_typesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    is_active: boolean | null
    processing_fee_percentage: Decimal | null
    processing_fee_fixed: Decimal | null
    requires_approval: boolean | null
    icon: string | null
  }

  export type Payment_typesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    is_active: boolean | null
    processing_fee_percentage: Decimal | null
    processing_fee_fixed: Decimal | null
    requires_approval: boolean | null
    icon: string | null
  }

  export type Payment_typesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    is_active: number
    processing_fee_percentage: number
    processing_fee_fixed: number
    requires_approval: number
    icon: number
    _all: number
  }


  export type Payment_typesAvgAggregateInputType = {
    id?: true
    processing_fee_percentage?: true
    processing_fee_fixed?: true
  }

  export type Payment_typesSumAggregateInputType = {
    id?: true
    processing_fee_percentage?: true
    processing_fee_fixed?: true
  }

  export type Payment_typesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    is_active?: true
    processing_fee_percentage?: true
    processing_fee_fixed?: true
    requires_approval?: true
    icon?: true
  }

  export type Payment_typesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    is_active?: true
    processing_fee_percentage?: true
    processing_fee_fixed?: true
    requires_approval?: true
    icon?: true
  }

  export type Payment_typesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    is_active?: true
    processing_fee_percentage?: true
    processing_fee_fixed?: true
    requires_approval?: true
    icon?: true
    _all?: true
  }

  export type Payment_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_types to aggregate.
     */
    where?: payment_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_types to fetch.
     */
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_types
    **/
    _count?: true | Payment_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_typesMaxAggregateInputType
  }

  export type GetPayment_typesAggregateType<T extends Payment_typesAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_types[P]>
      : GetScalarType<T[P], AggregatePayment_types[P]>
  }




  export type payment_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_typesWhereInput
    orderBy?: payment_typesOrderByWithAggregationInput | payment_typesOrderByWithAggregationInput[]
    by: Payment_typesScalarFieldEnum[] | Payment_typesScalarFieldEnum
    having?: payment_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_typesCountAggregateInputType | true
    _avg?: Payment_typesAvgAggregateInputType
    _sum?: Payment_typesSumAggregateInputType
    _min?: Payment_typesMinAggregateInputType
    _max?: Payment_typesMaxAggregateInputType
  }

  export type Payment_typesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    is_active: boolean | null
    processing_fee_percentage: Decimal | null
    processing_fee_fixed: Decimal | null
    requires_approval: boolean | null
    icon: string | null
    _count: Payment_typesCountAggregateOutputType | null
    _avg: Payment_typesAvgAggregateOutputType | null
    _sum: Payment_typesSumAggregateOutputType | null
    _min: Payment_typesMinAggregateOutputType | null
    _max: Payment_typesMaxAggregateOutputType | null
  }

  type GetPayment_typesGroupByPayload<T extends payment_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_typesGroupByOutputType[P]>
        }
      >
    >


  export type payment_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    processing_fee_percentage?: boolean
    processing_fee_fixed?: boolean
    requires_approval?: boolean
    icon?: boolean
    payment_methods?: boolean | payment_types$payment_methodsArgs<ExtArgs>
    _count?: boolean | Payment_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_types"]>

  export type payment_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    processing_fee_percentage?: boolean
    processing_fee_fixed?: boolean
    requires_approval?: boolean
    icon?: boolean
  }, ExtArgs["result"]["payment_types"]>

  export type payment_typesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    processing_fee_percentage?: boolean
    processing_fee_fixed?: boolean
    requires_approval?: boolean
    icon?: boolean
  }, ExtArgs["result"]["payment_types"]>

  export type payment_typesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    processing_fee_percentage?: boolean
    processing_fee_fixed?: boolean
    requires_approval?: boolean
    icon?: boolean
  }

  export type payment_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "is_active" | "processing_fee_percentage" | "processing_fee_fixed" | "requires_approval" | "icon", ExtArgs["result"]["payment_types"]>
  export type payment_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_methods?: boolean | payment_types$payment_methodsArgs<ExtArgs>
    _count?: boolean | Payment_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payment_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type payment_typesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $payment_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_types"
    objects: {
      payment_methods: Prisma.$payment_methodsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      is_active: boolean | null
      processing_fee_percentage: Prisma.Decimal | null
      processing_fee_fixed: Prisma.Decimal | null
      requires_approval: boolean | null
      icon: string | null
    }, ExtArgs["result"]["payment_types"]>
    composites: {}
  }

  type payment_typesGetPayload<S extends boolean | null | undefined | payment_typesDefaultArgs> = $Result.GetResult<Prisma.$payment_typesPayload, S>

  type payment_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_typesCountAggregateInputType | true
    }

  export interface payment_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_types'], meta: { name: 'payment_types' } }
    /**
     * Find zero or one Payment_types that matches the filter.
     * @param {payment_typesFindUniqueArgs} args - Arguments to find a Payment_types
     * @example
     * // Get one Payment_types
     * const payment_types = await prisma.payment_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_typesFindUniqueArgs>(args: SelectSubset<T, payment_typesFindUniqueArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_typesFindUniqueOrThrowArgs} args - Arguments to find a Payment_types
     * @example
     * // Get one Payment_types
     * const payment_types = await prisma.payment_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesFindFirstArgs} args - Arguments to find a Payment_types
     * @example
     * // Get one Payment_types
     * const payment_types = await prisma.payment_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_typesFindFirstArgs>(args?: SelectSubset<T, payment_typesFindFirstArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesFindFirstOrThrowArgs} args - Arguments to find a Payment_types
     * @example
     * // Get one Payment_types
     * const payment_types = await prisma.payment_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_types
     * const payment_types = await prisma.payment_types.findMany()
     * 
     * // Get first 10 Payment_types
     * const payment_types = await prisma.payment_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_typesWithIdOnly = await prisma.payment_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_typesFindManyArgs>(args?: SelectSubset<T, payment_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_types.
     * @param {payment_typesCreateArgs} args - Arguments to create a Payment_types.
     * @example
     * // Create one Payment_types
     * const Payment_types = await prisma.payment_types.create({
     *   data: {
     *     // ... data to create a Payment_types
     *   }
     * })
     * 
     */
    create<T extends payment_typesCreateArgs>(args: SelectSubset<T, payment_typesCreateArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_types.
     * @param {payment_typesCreateManyArgs} args - Arguments to create many Payment_types.
     * @example
     * // Create many Payment_types
     * const payment_types = await prisma.payment_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_typesCreateManyArgs>(args?: SelectSubset<T, payment_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_types and returns the data saved in the database.
     * @param {payment_typesCreateManyAndReturnArgs} args - Arguments to create many Payment_types.
     * @example
     * // Create many Payment_types
     * const payment_types = await prisma.payment_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_types and only return the `id`
     * const payment_typesWithIdOnly = await prisma.payment_types.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_types.
     * @param {payment_typesDeleteArgs} args - Arguments to delete one Payment_types.
     * @example
     * // Delete one Payment_types
     * const Payment_types = await prisma.payment_types.delete({
     *   where: {
     *     // ... filter to delete one Payment_types
     *   }
     * })
     * 
     */
    delete<T extends payment_typesDeleteArgs>(args: SelectSubset<T, payment_typesDeleteArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_types.
     * @param {payment_typesUpdateArgs} args - Arguments to update one Payment_types.
     * @example
     * // Update one Payment_types
     * const payment_types = await prisma.payment_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_typesUpdateArgs>(args: SelectSubset<T, payment_typesUpdateArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_types.
     * @param {payment_typesDeleteManyArgs} args - Arguments to filter Payment_types to delete.
     * @example
     * // Delete a few Payment_types
     * const { count } = await prisma.payment_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_typesDeleteManyArgs>(args?: SelectSubset<T, payment_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_types
     * const payment_types = await prisma.payment_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_typesUpdateManyArgs>(args: SelectSubset<T, payment_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_types and returns the data updated in the database.
     * @param {payment_typesUpdateManyAndReturnArgs} args - Arguments to update many Payment_types.
     * @example
     * // Update many Payment_types
     * const payment_types = await prisma.payment_types.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_types and only return the `id`
     * const payment_typesWithIdOnly = await prisma.payment_types.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_typesUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_typesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_types.
     * @param {payment_typesUpsertArgs} args - Arguments to update or create a Payment_types.
     * @example
     * // Update or create a Payment_types
     * const payment_types = await prisma.payment_types.upsert({
     *   create: {
     *     // ... data to create a Payment_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_types we want to update
     *   }
     * })
     */
    upsert<T extends payment_typesUpsertArgs>(args: SelectSubset<T, payment_typesUpsertArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesCountArgs} args - Arguments to filter Payment_types to count.
     * @example
     * // Count the number of Payment_types
     * const count = await prisma.payment_types.count({
     *   where: {
     *     // ... the filter for the Payment_types we want to count
     *   }
     * })
    **/
    count<T extends payment_typesCountArgs>(
      args?: Subset<T, payment_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_typesAggregateArgs>(args: Subset<T, Payment_typesAggregateArgs>): Prisma.PrismaPromise<GetPayment_typesAggregateType<T>>

    /**
     * Group by Payment_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_typesGroupByArgs['orderBy'] }
        : { orderBy?: payment_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_types model
   */
  readonly fields: payment_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment_methods<T extends payment_types$payment_methodsArgs<ExtArgs> = {}>(args?: Subset<T, payment_types$payment_methodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_types model
   */ 
  interface payment_typesFieldRefs {
    readonly id: FieldRef<"payment_types", 'Int'>
    readonly name: FieldRef<"payment_types", 'String'>
    readonly description: FieldRef<"payment_types", 'String'>
    readonly is_active: FieldRef<"payment_types", 'Boolean'>
    readonly processing_fee_percentage: FieldRef<"payment_types", 'Decimal'>
    readonly processing_fee_fixed: FieldRef<"payment_types", 'Decimal'>
    readonly requires_approval: FieldRef<"payment_types", 'Boolean'>
    readonly icon: FieldRef<"payment_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment_types findUnique
   */
  export type payment_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where: payment_typesWhereUniqueInput
  }

  /**
   * payment_types findUniqueOrThrow
   */
  export type payment_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where: payment_typesWhereUniqueInput
  }

  /**
   * payment_types findFirst
   */
  export type payment_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where?: payment_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_types to fetch.
     */
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_types.
     */
    cursor?: payment_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_types.
     */
    distinct?: Payment_typesScalarFieldEnum | Payment_typesScalarFieldEnum[]
  }

  /**
   * payment_types findFirstOrThrow
   */
  export type payment_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where?: payment_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_types to fetch.
     */
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_types.
     */
    cursor?: payment_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_types.
     */
    distinct?: Payment_typesScalarFieldEnum | Payment_typesScalarFieldEnum[]
  }

  /**
   * payment_types findMany
   */
  export type payment_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter, which payment_types to fetch.
     */
    where?: payment_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_types to fetch.
     */
    orderBy?: payment_typesOrderByWithRelationInput | payment_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_types.
     */
    cursor?: payment_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_types.
     */
    skip?: number
    distinct?: Payment_typesScalarFieldEnum | Payment_typesScalarFieldEnum[]
  }

  /**
   * payment_types create
   */
  export type payment_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_types.
     */
    data: XOR<payment_typesCreateInput, payment_typesUncheckedCreateInput>
  }

  /**
   * payment_types createMany
   */
  export type payment_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_types.
     */
    data: payment_typesCreateManyInput | payment_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_types createManyAndReturn
   */
  export type payment_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * The data used to create many payment_types.
     */
    data: payment_typesCreateManyInput | payment_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_types update
   */
  export type payment_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_types.
     */
    data: XOR<payment_typesUpdateInput, payment_typesUncheckedUpdateInput>
    /**
     * Choose, which payment_types to update.
     */
    where: payment_typesWhereUniqueInput
  }

  /**
   * payment_types updateMany
   */
  export type payment_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_types.
     */
    data: XOR<payment_typesUpdateManyMutationInput, payment_typesUncheckedUpdateManyInput>
    /**
     * Filter which payment_types to update
     */
    where?: payment_typesWhereInput
    /**
     * Limit how many payment_types to update.
     */
    limit?: number
  }

  /**
   * payment_types updateManyAndReturn
   */
  export type payment_typesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * The data used to update payment_types.
     */
    data: XOR<payment_typesUpdateManyMutationInput, payment_typesUncheckedUpdateManyInput>
    /**
     * Filter which payment_types to update
     */
    where?: payment_typesWhereInput
    /**
     * Limit how many payment_types to update.
     */
    limit?: number
  }

  /**
   * payment_types upsert
   */
  export type payment_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_types to update in case it exists.
     */
    where: payment_typesWhereUniqueInput
    /**
     * In case the payment_types found by the `where` argument doesn't exist, create a new payment_types with this data.
     */
    create: XOR<payment_typesCreateInput, payment_typesUncheckedCreateInput>
    /**
     * In case the payment_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_typesUpdateInput, payment_typesUncheckedUpdateInput>
  }

  /**
   * payment_types delete
   */
  export type payment_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    /**
     * Filter which payment_types to delete.
     */
    where: payment_typesWhereUniqueInput
  }

  /**
   * payment_types deleteMany
   */
  export type payment_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_types to delete
     */
    where?: payment_typesWhereInput
    /**
     * Limit how many payment_types to delete.
     */
    limit?: number
  }

  /**
   * payment_types.payment_methods
   */
  export type payment_types$payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    where?: payment_methodsWhereInput
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    cursor?: payment_methodsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_methodsScalarFieldEnum | Payment_methodsScalarFieldEnum[]
  }

  /**
   * payment_types without action
   */
  export type payment_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    amount: Decimal | null
    exchange_rate: Decimal | null
    fees: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    amount: Decimal | null
    exchange_rate: Decimal | null
    fees: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    invoice_id: string | null
    amount: Decimal | null
    payment_date: Date | null
    payment_method: $Enums.payment_method_enum | null
    status: $Enums.payment_status_enum | null
    payment_provider: string | null
    currency: string | null
    exchange_rate: Decimal | null
    fees: Decimal | null
    receipt_url: string | null
    notes: string | null
    transaction_id: string | null
    payment_method_id: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    invoice_id: string | null
    amount: Decimal | null
    payment_date: Date | null
    payment_method: $Enums.payment_method_enum | null
    status: $Enums.payment_status_enum | null
    payment_provider: string | null
    currency: string | null
    exchange_rate: Decimal | null
    fees: Decimal | null
    receipt_url: string | null
    notes: string | null
    transaction_id: string | null
    payment_method_id: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    invoice_id: number
    amount: number
    payment_date: number
    payment_method: number
    status: number
    payment_provider: number
    currency: number
    exchange_rate: number
    fees: number
    payer_details: number
    receipt_url: number
    notes: number
    transaction_id: number
    payment_method_id: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    amount?: true
    exchange_rate?: true
    fees?: true
  }

  export type PaymentsSumAggregateInputType = {
    amount?: true
    exchange_rate?: true
    fees?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    status?: true
    payment_provider?: true
    currency?: true
    exchange_rate?: true
    fees?: true
    receipt_url?: true
    notes?: true
    transaction_id?: true
    payment_method_id?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    status?: true
    payment_provider?: true
    currency?: true
    exchange_rate?: true
    fees?: true
    receipt_url?: true
    notes?: true
    transaction_id?: true
    payment_method_id?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    invoice_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    status?: true
    payment_provider?: true
    currency?: true
    exchange_rate?: true
    fees?: true
    payer_details?: true
    receipt_url?: true
    notes?: true
    transaction_id?: true
    payment_method_id?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    invoice_id: string
    amount: Decimal
    payment_date: Date
    payment_method: $Enums.payment_method_enum
    status: $Enums.payment_status_enum
    payment_provider: string | null
    currency: string | null
    exchange_rate: Decimal | null
    fees: Decimal | null
    payer_details: JsonValue | null
    receipt_url: string | null
    notes: string | null
    transaction_id: string | null
    payment_method_id: string | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    status?: boolean
    payment_provider?: boolean
    currency?: boolean
    exchange_rate?: boolean
    fees?: boolean
    payer_details?: boolean
    receipt_url?: boolean
    notes?: boolean
    transaction_id?: boolean
    payment_method_id?: boolean
    payment_methods?: boolean | payments$payment_methodsArgs<ExtArgs>
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    transactions?: boolean | payments$transactionsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    status?: boolean
    payment_provider?: boolean
    currency?: boolean
    exchange_rate?: boolean
    fees?: boolean
    payer_details?: boolean
    receipt_url?: boolean
    notes?: boolean
    transaction_id?: boolean
    payment_method_id?: boolean
    payment_methods?: boolean | payments$payment_methodsArgs<ExtArgs>
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    transactions?: boolean | payments$transactionsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    status?: boolean
    payment_provider?: boolean
    currency?: boolean
    exchange_rate?: boolean
    fees?: boolean
    payer_details?: boolean
    receipt_url?: boolean
    notes?: boolean
    transaction_id?: boolean
    payment_method_id?: boolean
    payment_methods?: boolean | payments$payment_methodsArgs<ExtArgs>
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    transactions?: boolean | payments$transactionsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    status?: boolean
    payment_provider?: boolean
    currency?: boolean
    exchange_rate?: boolean
    fees?: boolean
    payer_details?: boolean
    receipt_url?: boolean
    notes?: boolean
    transaction_id?: boolean
    payment_method_id?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "invoice_id" | "amount" | "payment_date" | "payment_method" | "status" | "payment_provider" | "currency" | "exchange_rate" | "fees" | "payer_details" | "receipt_url" | "notes" | "transaction_id" | "payment_method_id", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_methods?: boolean | payments$payment_methodsArgs<ExtArgs>
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    transactions?: boolean | payments$transactionsArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_methods?: boolean | payments$payment_methodsArgs<ExtArgs>
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    transactions?: boolean | payments$transactionsArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_methods?: boolean | payments$payment_methodsArgs<ExtArgs>
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    transactions?: boolean | payments$transactionsArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      payment_methods: Prisma.$payment_methodsPayload<ExtArgs> | null
      invoices: Prisma.$invoicesPayload<ExtArgs>
      transactions: Prisma.$transactionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      invoice_id: string
      amount: Prisma.Decimal
      payment_date: Date
      payment_method: $Enums.payment_method_enum
      status: $Enums.payment_status_enum
      payment_provider: string | null
      currency: string | null
      exchange_rate: Prisma.Decimal | null
      fees: Prisma.Decimal | null
      payer_details: Prisma.JsonValue | null
      receipt_url: string | null
      notes: string | null
      transaction_id: string | null
      payment_method_id: string | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment_methods<T extends payments$payment_methodsArgs<ExtArgs> = {}>(args?: Subset<T, payments$payment_methodsArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends invoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, invoicesDefaultArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends payments$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, payments$transactionsArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */ 
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'String'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly updated_at: FieldRef<"payments", 'DateTime'>
    readonly invoice_id: FieldRef<"payments", 'String'>
    readonly amount: FieldRef<"payments", 'Decimal'>
    readonly payment_date: FieldRef<"payments", 'DateTime'>
    readonly payment_method: FieldRef<"payments", 'payment_method_enum'>
    readonly status: FieldRef<"payments", 'payment_status_enum'>
    readonly payment_provider: FieldRef<"payments", 'String'>
    readonly currency: FieldRef<"payments", 'String'>
    readonly exchange_rate: FieldRef<"payments", 'Decimal'>
    readonly fees: FieldRef<"payments", 'Decimal'>
    readonly payer_details: FieldRef<"payments", 'Json'>
    readonly receipt_url: FieldRef<"payments", 'String'>
    readonly notes: FieldRef<"payments", 'String'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly payment_method_id: FieldRef<"payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments.payment_methods
   */
  export type payments$payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    where?: payment_methodsWhereInput
  }

  /**
   * payments.transactions
   */
  export type payments$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model plan_addresses
   */

  export type AggregatePlan_addresses = {
    _count: Plan_addressesCountAggregateOutputType | null
    _min: Plan_addressesMinAggregateOutputType | null
    _max: Plan_addressesMaxAggregateOutputType | null
  }

  export type Plan_addressesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    plan_id: string | null
    address_type: string | null
    address_line1: string | null
    address_line2: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    contact_name: string | null
    contact_phone: string | null
    is_primary: boolean | null
  }

  export type Plan_addressesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    plan_id: string | null
    address_type: string | null
    address_line1: string | null
    address_line2: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    contact_name: string | null
    contact_phone: string | null
    is_primary: boolean | null
  }

  export type Plan_addressesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    plan_id: number
    address_type: number
    address_line1: number
    address_line2: number
    city: number
    state: number
    country: number
    postal_code: number
    contact_name: number
    contact_phone: number
    is_primary: number
    additional_info: number
    _all: number
  }


  export type Plan_addressesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    plan_id?: true
    address_type?: true
    address_line1?: true
    address_line2?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    contact_name?: true
    contact_phone?: true
    is_primary?: true
  }

  export type Plan_addressesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    plan_id?: true
    address_type?: true
    address_line1?: true
    address_line2?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    contact_name?: true
    contact_phone?: true
    is_primary?: true
  }

  export type Plan_addressesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    plan_id?: true
    address_type?: true
    address_line1?: true
    address_line2?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    contact_name?: true
    contact_phone?: true
    is_primary?: true
    additional_info?: true
    _all?: true
  }

  export type Plan_addressesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_addresses to aggregate.
     */
    where?: plan_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_addresses to fetch.
     */
    orderBy?: plan_addressesOrderByWithRelationInput | plan_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_addresses
    **/
    _count?: true | Plan_addressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_addressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_addressesMaxAggregateInputType
  }

  export type GetPlan_addressesAggregateType<T extends Plan_addressesAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_addresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_addresses[P]>
      : GetScalarType<T[P], AggregatePlan_addresses[P]>
  }




  export type plan_addressesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plan_addressesWhereInput
    orderBy?: plan_addressesOrderByWithAggregationInput | plan_addressesOrderByWithAggregationInput[]
    by: Plan_addressesScalarFieldEnum[] | Plan_addressesScalarFieldEnum
    having?: plan_addressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_addressesCountAggregateInputType | true
    _min?: Plan_addressesMinAggregateInputType
    _max?: Plan_addressesMaxAggregateInputType
  }

  export type Plan_addressesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    plan_id: string
    address_type: string
    address_line1: string
    address_line2: string
    city: string
    state: string
    country: string
    postal_code: string
    contact_name: string | null
    contact_phone: string
    is_primary: boolean
    additional_info: JsonValue | null
    _count: Plan_addressesCountAggregateOutputType | null
    _min: Plan_addressesMinAggregateOutputType | null
    _max: Plan_addressesMaxAggregateOutputType | null
  }

  type GetPlan_addressesGroupByPayload<T extends plan_addressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_addressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_addressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_addressesGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_addressesGroupByOutputType[P]>
        }
      >
    >


  export type plan_addressesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan_id?: boolean
    address_type?: boolean
    address_line1?: boolean
    address_line2?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    is_primary?: boolean
    additional_info?: boolean
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan_addresses"]>

  export type plan_addressesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan_id?: boolean
    address_type?: boolean
    address_line1?: boolean
    address_line2?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    is_primary?: boolean
    additional_info?: boolean
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan_addresses"]>

  export type plan_addressesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan_id?: boolean
    address_type?: boolean
    address_line1?: boolean
    address_line2?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    is_primary?: boolean
    additional_info?: boolean
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan_addresses"]>

  export type plan_addressesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan_id?: boolean
    address_type?: boolean
    address_line1?: boolean
    address_line2?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    is_primary?: boolean
    additional_info?: boolean
  }

  export type plan_addressesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "plan_id" | "address_type" | "address_line1" | "address_line2" | "city" | "state" | "country" | "postal_code" | "contact_name" | "contact_phone" | "is_primary" | "additional_info", ExtArgs["result"]["plan_addresses"]>
  export type plan_addressesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }
  export type plan_addressesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }
  export type plan_addressesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }

  export type $plan_addressesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plan_addresses"
    objects: {
      plans: Prisma.$plansPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      plan_id: string
      address_type: string
      address_line1: string
      address_line2: string
      city: string
      state: string
      country: string
      postal_code: string
      contact_name: string | null
      contact_phone: string
      is_primary: boolean
      additional_info: Prisma.JsonValue | null
    }, ExtArgs["result"]["plan_addresses"]>
    composites: {}
  }

  type plan_addressesGetPayload<S extends boolean | null | undefined | plan_addressesDefaultArgs> = $Result.GetResult<Prisma.$plan_addressesPayload, S>

  type plan_addressesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plan_addressesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Plan_addressesCountAggregateInputType | true
    }

  export interface plan_addressesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_addresses'], meta: { name: 'plan_addresses' } }
    /**
     * Find zero or one Plan_addresses that matches the filter.
     * @param {plan_addressesFindUniqueArgs} args - Arguments to find a Plan_addresses
     * @example
     * // Get one Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plan_addressesFindUniqueArgs>(args: SelectSubset<T, plan_addressesFindUniqueArgs<ExtArgs>>): Prisma__plan_addressesClient<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan_addresses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plan_addressesFindUniqueOrThrowArgs} args - Arguments to find a Plan_addresses
     * @example
     * // Get one Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plan_addressesFindUniqueOrThrowArgs>(args: SelectSubset<T, plan_addressesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plan_addressesClient<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_addressesFindFirstArgs} args - Arguments to find a Plan_addresses
     * @example
     * // Get one Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plan_addressesFindFirstArgs>(args?: SelectSubset<T, plan_addressesFindFirstArgs<ExtArgs>>): Prisma__plan_addressesClient<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_addressesFindFirstOrThrowArgs} args - Arguments to find a Plan_addresses
     * @example
     * // Get one Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plan_addressesFindFirstOrThrowArgs>(args?: SelectSubset<T, plan_addressesFindFirstOrThrowArgs<ExtArgs>>): Prisma__plan_addressesClient<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plan_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_addressesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.findMany()
     * 
     * // Get first 10 Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plan_addressesWithIdOnly = await prisma.plan_addresses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plan_addressesFindManyArgs>(args?: SelectSubset<T, plan_addressesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan_addresses.
     * @param {plan_addressesCreateArgs} args - Arguments to create a Plan_addresses.
     * @example
     * // Create one Plan_addresses
     * const Plan_addresses = await prisma.plan_addresses.create({
     *   data: {
     *     // ... data to create a Plan_addresses
     *   }
     * })
     * 
     */
    create<T extends plan_addressesCreateArgs>(args: SelectSubset<T, plan_addressesCreateArgs<ExtArgs>>): Prisma__plan_addressesClient<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plan_addresses.
     * @param {plan_addressesCreateManyArgs} args - Arguments to create many Plan_addresses.
     * @example
     * // Create many Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plan_addressesCreateManyArgs>(args?: SelectSubset<T, plan_addressesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plan_addresses and returns the data saved in the database.
     * @param {plan_addressesCreateManyAndReturnArgs} args - Arguments to create many Plan_addresses.
     * @example
     * // Create many Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plan_addresses and only return the `id`
     * const plan_addressesWithIdOnly = await prisma.plan_addresses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends plan_addressesCreateManyAndReturnArgs>(args?: SelectSubset<T, plan_addressesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan_addresses.
     * @param {plan_addressesDeleteArgs} args - Arguments to delete one Plan_addresses.
     * @example
     * // Delete one Plan_addresses
     * const Plan_addresses = await prisma.plan_addresses.delete({
     *   where: {
     *     // ... filter to delete one Plan_addresses
     *   }
     * })
     * 
     */
    delete<T extends plan_addressesDeleteArgs>(args: SelectSubset<T, plan_addressesDeleteArgs<ExtArgs>>): Prisma__plan_addressesClient<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan_addresses.
     * @param {plan_addressesUpdateArgs} args - Arguments to update one Plan_addresses.
     * @example
     * // Update one Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plan_addressesUpdateArgs>(args: SelectSubset<T, plan_addressesUpdateArgs<ExtArgs>>): Prisma__plan_addressesClient<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plan_addresses.
     * @param {plan_addressesDeleteManyArgs} args - Arguments to filter Plan_addresses to delete.
     * @example
     * // Delete a few Plan_addresses
     * const { count } = await prisma.plan_addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plan_addressesDeleteManyArgs>(args?: SelectSubset<T, plan_addressesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_addressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plan_addressesUpdateManyArgs>(args: SelectSubset<T, plan_addressesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_addresses and returns the data updated in the database.
     * @param {plan_addressesUpdateManyAndReturnArgs} args - Arguments to update many Plan_addresses.
     * @example
     * // Update many Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plan_addresses and only return the `id`
     * const plan_addressesWithIdOnly = await prisma.plan_addresses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends plan_addressesUpdateManyAndReturnArgs>(args: SelectSubset<T, plan_addressesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan_addresses.
     * @param {plan_addressesUpsertArgs} args - Arguments to update or create a Plan_addresses.
     * @example
     * // Update or create a Plan_addresses
     * const plan_addresses = await prisma.plan_addresses.upsert({
     *   create: {
     *     // ... data to create a Plan_addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_addresses we want to update
     *   }
     * })
     */
    upsert<T extends plan_addressesUpsertArgs>(args: SelectSubset<T, plan_addressesUpsertArgs<ExtArgs>>): Prisma__plan_addressesClient<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plan_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_addressesCountArgs} args - Arguments to filter Plan_addresses to count.
     * @example
     * // Count the number of Plan_addresses
     * const count = await prisma.plan_addresses.count({
     *   where: {
     *     // ... the filter for the Plan_addresses we want to count
     *   }
     * })
    **/
    count<T extends plan_addressesCountArgs>(
      args?: Subset<T, plan_addressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_addressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_addressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_addressesAggregateArgs>(args: Subset<T, Plan_addressesAggregateArgs>): Prisma.PrismaPromise<GetPlan_addressesAggregateType<T>>

    /**
     * Group by Plan_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_addressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_addressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_addressesGroupByArgs['orderBy'] }
        : { orderBy?: plan_addressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_addressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_addressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plan_addresses model
   */
  readonly fields: plan_addressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plan_addressesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plans<T extends plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, plansDefaultArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plan_addresses model
   */ 
  interface plan_addressesFieldRefs {
    readonly id: FieldRef<"plan_addresses", 'String'>
    readonly created_at: FieldRef<"plan_addresses", 'DateTime'>
    readonly updated_at: FieldRef<"plan_addresses", 'DateTime'>
    readonly plan_id: FieldRef<"plan_addresses", 'String'>
    readonly address_type: FieldRef<"plan_addresses", 'String'>
    readonly address_line1: FieldRef<"plan_addresses", 'String'>
    readonly address_line2: FieldRef<"plan_addresses", 'String'>
    readonly city: FieldRef<"plan_addresses", 'String'>
    readonly state: FieldRef<"plan_addresses", 'String'>
    readonly country: FieldRef<"plan_addresses", 'String'>
    readonly postal_code: FieldRef<"plan_addresses", 'String'>
    readonly contact_name: FieldRef<"plan_addresses", 'String'>
    readonly contact_phone: FieldRef<"plan_addresses", 'String'>
    readonly is_primary: FieldRef<"plan_addresses", 'Boolean'>
    readonly additional_info: FieldRef<"plan_addresses", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * plan_addresses findUnique
   */
  export type plan_addressesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * Filter, which plan_addresses to fetch.
     */
    where: plan_addressesWhereUniqueInput
  }

  /**
   * plan_addresses findUniqueOrThrow
   */
  export type plan_addressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * Filter, which plan_addresses to fetch.
     */
    where: plan_addressesWhereUniqueInput
  }

  /**
   * plan_addresses findFirst
   */
  export type plan_addressesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * Filter, which plan_addresses to fetch.
     */
    where?: plan_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_addresses to fetch.
     */
    orderBy?: plan_addressesOrderByWithRelationInput | plan_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_addresses.
     */
    cursor?: plan_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_addresses.
     */
    distinct?: Plan_addressesScalarFieldEnum | Plan_addressesScalarFieldEnum[]
  }

  /**
   * plan_addresses findFirstOrThrow
   */
  export type plan_addressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * Filter, which plan_addresses to fetch.
     */
    where?: plan_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_addresses to fetch.
     */
    orderBy?: plan_addressesOrderByWithRelationInput | plan_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_addresses.
     */
    cursor?: plan_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_addresses.
     */
    distinct?: Plan_addressesScalarFieldEnum | Plan_addressesScalarFieldEnum[]
  }

  /**
   * plan_addresses findMany
   */
  export type plan_addressesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * Filter, which plan_addresses to fetch.
     */
    where?: plan_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_addresses to fetch.
     */
    orderBy?: plan_addressesOrderByWithRelationInput | plan_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_addresses.
     */
    cursor?: plan_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_addresses.
     */
    skip?: number
    distinct?: Plan_addressesScalarFieldEnum | Plan_addressesScalarFieldEnum[]
  }

  /**
   * plan_addresses create
   */
  export type plan_addressesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * The data needed to create a plan_addresses.
     */
    data: XOR<plan_addressesCreateInput, plan_addressesUncheckedCreateInput>
  }

  /**
   * plan_addresses createMany
   */
  export type plan_addressesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_addresses.
     */
    data: plan_addressesCreateManyInput | plan_addressesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plan_addresses createManyAndReturn
   */
  export type plan_addressesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * The data used to create many plan_addresses.
     */
    data: plan_addressesCreateManyInput | plan_addressesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * plan_addresses update
   */
  export type plan_addressesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * The data needed to update a plan_addresses.
     */
    data: XOR<plan_addressesUpdateInput, plan_addressesUncheckedUpdateInput>
    /**
     * Choose, which plan_addresses to update.
     */
    where: plan_addressesWhereUniqueInput
  }

  /**
   * plan_addresses updateMany
   */
  export type plan_addressesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_addresses.
     */
    data: XOR<plan_addressesUpdateManyMutationInput, plan_addressesUncheckedUpdateManyInput>
    /**
     * Filter which plan_addresses to update
     */
    where?: plan_addressesWhereInput
    /**
     * Limit how many plan_addresses to update.
     */
    limit?: number
  }

  /**
   * plan_addresses updateManyAndReturn
   */
  export type plan_addressesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * The data used to update plan_addresses.
     */
    data: XOR<plan_addressesUpdateManyMutationInput, plan_addressesUncheckedUpdateManyInput>
    /**
     * Filter which plan_addresses to update
     */
    where?: plan_addressesWhereInput
    /**
     * Limit how many plan_addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * plan_addresses upsert
   */
  export type plan_addressesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * The filter to search for the plan_addresses to update in case it exists.
     */
    where: plan_addressesWhereUniqueInput
    /**
     * In case the plan_addresses found by the `where` argument doesn't exist, create a new plan_addresses with this data.
     */
    create: XOR<plan_addressesCreateInput, plan_addressesUncheckedCreateInput>
    /**
     * In case the plan_addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_addressesUpdateInput, plan_addressesUncheckedUpdateInput>
  }

  /**
   * plan_addresses delete
   */
  export type plan_addressesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    /**
     * Filter which plan_addresses to delete.
     */
    where: plan_addressesWhereUniqueInput
  }

  /**
   * plan_addresses deleteMany
   */
  export type plan_addressesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_addresses to delete
     */
    where?: plan_addressesWhereInput
    /**
     * Limit how many plan_addresses to delete.
     */
    limit?: number
  }

  /**
   * plan_addresses without action
   */
  export type plan_addressesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
  }


  /**
   * Model plan_features
   */

  export type AggregatePlan_features = {
    _count: Plan_featuresCountAggregateOutputType | null
    _avg: Plan_featuresAvgAggregateOutputType | null
    _sum: Plan_featuresSumAggregateOutputType | null
    _min: Plan_featuresMinAggregateOutputType | null
    _max: Plan_featuresMaxAggregateOutputType | null
  }

  export type Plan_featuresAvgAggregateOutputType = {
    limit_quantity: number | null
  }

  export type Plan_featuresSumAggregateOutputType = {
    limit_quantity: number | null
  }

  export type Plan_featuresMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    plan_id: string | null
    feature_name: string | null
    feature_value: string | null
    is_included: boolean | null
    limit_quantity: number | null
    description: string | null
  }

  export type Plan_featuresMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    plan_id: string | null
    feature_name: string | null
    feature_value: string | null
    is_included: boolean | null
    limit_quantity: number | null
    description: string | null
  }

  export type Plan_featuresCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    plan_id: number
    feature_name: number
    feature_value: number
    is_included: number
    limit_quantity: number
    description: number
    _all: number
  }


  export type Plan_featuresAvgAggregateInputType = {
    limit_quantity?: true
  }

  export type Plan_featuresSumAggregateInputType = {
    limit_quantity?: true
  }

  export type Plan_featuresMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    plan_id?: true
    feature_name?: true
    feature_value?: true
    is_included?: true
    limit_quantity?: true
    description?: true
  }

  export type Plan_featuresMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    plan_id?: true
    feature_name?: true
    feature_value?: true
    is_included?: true
    limit_quantity?: true
    description?: true
  }

  export type Plan_featuresCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    plan_id?: true
    feature_name?: true
    feature_value?: true
    is_included?: true
    limit_quantity?: true
    description?: true
    _all?: true
  }

  export type Plan_featuresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_features to aggregate.
     */
    where?: plan_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_features to fetch.
     */
    orderBy?: plan_featuresOrderByWithRelationInput | plan_featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_features
    **/
    _count?: true | Plan_featuresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plan_featuresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plan_featuresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_featuresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_featuresMaxAggregateInputType
  }

  export type GetPlan_featuresAggregateType<T extends Plan_featuresAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_features]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_features[P]>
      : GetScalarType<T[P], AggregatePlan_features[P]>
  }




  export type plan_featuresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plan_featuresWhereInput
    orderBy?: plan_featuresOrderByWithAggregationInput | plan_featuresOrderByWithAggregationInput[]
    by: Plan_featuresScalarFieldEnum[] | Plan_featuresScalarFieldEnum
    having?: plan_featuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_featuresCountAggregateInputType | true
    _avg?: Plan_featuresAvgAggregateInputType
    _sum?: Plan_featuresSumAggregateInputType
    _min?: Plan_featuresMinAggregateInputType
    _max?: Plan_featuresMaxAggregateInputType
  }

  export type Plan_featuresGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    plan_id: string
    feature_name: string
    feature_value: string | null
    is_included: boolean | null
    limit_quantity: number | null
    description: string | null
    _count: Plan_featuresCountAggregateOutputType | null
    _avg: Plan_featuresAvgAggregateOutputType | null
    _sum: Plan_featuresSumAggregateOutputType | null
    _min: Plan_featuresMinAggregateOutputType | null
    _max: Plan_featuresMaxAggregateOutputType | null
  }

  type GetPlan_featuresGroupByPayload<T extends plan_featuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_featuresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_featuresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_featuresGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_featuresGroupByOutputType[P]>
        }
      >
    >


  export type plan_featuresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan_id?: boolean
    feature_name?: boolean
    feature_value?: boolean
    is_included?: boolean
    limit_quantity?: boolean
    description?: boolean
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan_features"]>

  export type plan_featuresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan_id?: boolean
    feature_name?: boolean
    feature_value?: boolean
    is_included?: boolean
    limit_quantity?: boolean
    description?: boolean
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan_features"]>

  export type plan_featuresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan_id?: boolean
    feature_name?: boolean
    feature_value?: boolean
    is_included?: boolean
    limit_quantity?: boolean
    description?: boolean
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan_features"]>

  export type plan_featuresSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan_id?: boolean
    feature_name?: boolean
    feature_value?: boolean
    is_included?: boolean
    limit_quantity?: boolean
    description?: boolean
  }

  export type plan_featuresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "plan_id" | "feature_name" | "feature_value" | "is_included" | "limit_quantity" | "description", ExtArgs["result"]["plan_features"]>
  export type plan_featuresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }
  export type plan_featuresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }
  export type plan_featuresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | plansDefaultArgs<ExtArgs>
  }

  export type $plan_featuresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plan_features"
    objects: {
      plans: Prisma.$plansPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      plan_id: string
      feature_name: string
      feature_value: string | null
      is_included: boolean | null
      limit_quantity: number | null
      description: string | null
    }, ExtArgs["result"]["plan_features"]>
    composites: {}
  }

  type plan_featuresGetPayload<S extends boolean | null | undefined | plan_featuresDefaultArgs> = $Result.GetResult<Prisma.$plan_featuresPayload, S>

  type plan_featuresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plan_featuresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Plan_featuresCountAggregateInputType | true
    }

  export interface plan_featuresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_features'], meta: { name: 'plan_features' } }
    /**
     * Find zero or one Plan_features that matches the filter.
     * @param {plan_featuresFindUniqueArgs} args - Arguments to find a Plan_features
     * @example
     * // Get one Plan_features
     * const plan_features = await prisma.plan_features.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plan_featuresFindUniqueArgs>(args: SelectSubset<T, plan_featuresFindUniqueArgs<ExtArgs>>): Prisma__plan_featuresClient<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan_features that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plan_featuresFindUniqueOrThrowArgs} args - Arguments to find a Plan_features
     * @example
     * // Get one Plan_features
     * const plan_features = await prisma.plan_features.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plan_featuresFindUniqueOrThrowArgs>(args: SelectSubset<T, plan_featuresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plan_featuresClient<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_featuresFindFirstArgs} args - Arguments to find a Plan_features
     * @example
     * // Get one Plan_features
     * const plan_features = await prisma.plan_features.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plan_featuresFindFirstArgs>(args?: SelectSubset<T, plan_featuresFindFirstArgs<ExtArgs>>): Prisma__plan_featuresClient<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_features that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_featuresFindFirstOrThrowArgs} args - Arguments to find a Plan_features
     * @example
     * // Get one Plan_features
     * const plan_features = await prisma.plan_features.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plan_featuresFindFirstOrThrowArgs>(args?: SelectSubset<T, plan_featuresFindFirstOrThrowArgs<ExtArgs>>): Prisma__plan_featuresClient<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plan_features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_featuresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_features
     * const plan_features = await prisma.plan_features.findMany()
     * 
     * // Get first 10 Plan_features
     * const plan_features = await prisma.plan_features.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plan_featuresWithIdOnly = await prisma.plan_features.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plan_featuresFindManyArgs>(args?: SelectSubset<T, plan_featuresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan_features.
     * @param {plan_featuresCreateArgs} args - Arguments to create a Plan_features.
     * @example
     * // Create one Plan_features
     * const Plan_features = await prisma.plan_features.create({
     *   data: {
     *     // ... data to create a Plan_features
     *   }
     * })
     * 
     */
    create<T extends plan_featuresCreateArgs>(args: SelectSubset<T, plan_featuresCreateArgs<ExtArgs>>): Prisma__plan_featuresClient<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plan_features.
     * @param {plan_featuresCreateManyArgs} args - Arguments to create many Plan_features.
     * @example
     * // Create many Plan_features
     * const plan_features = await prisma.plan_features.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plan_featuresCreateManyArgs>(args?: SelectSubset<T, plan_featuresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plan_features and returns the data saved in the database.
     * @param {plan_featuresCreateManyAndReturnArgs} args - Arguments to create many Plan_features.
     * @example
     * // Create many Plan_features
     * const plan_features = await prisma.plan_features.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plan_features and only return the `id`
     * const plan_featuresWithIdOnly = await prisma.plan_features.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends plan_featuresCreateManyAndReturnArgs>(args?: SelectSubset<T, plan_featuresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan_features.
     * @param {plan_featuresDeleteArgs} args - Arguments to delete one Plan_features.
     * @example
     * // Delete one Plan_features
     * const Plan_features = await prisma.plan_features.delete({
     *   where: {
     *     // ... filter to delete one Plan_features
     *   }
     * })
     * 
     */
    delete<T extends plan_featuresDeleteArgs>(args: SelectSubset<T, plan_featuresDeleteArgs<ExtArgs>>): Prisma__plan_featuresClient<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan_features.
     * @param {plan_featuresUpdateArgs} args - Arguments to update one Plan_features.
     * @example
     * // Update one Plan_features
     * const plan_features = await prisma.plan_features.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plan_featuresUpdateArgs>(args: SelectSubset<T, plan_featuresUpdateArgs<ExtArgs>>): Prisma__plan_featuresClient<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plan_features.
     * @param {plan_featuresDeleteManyArgs} args - Arguments to filter Plan_features to delete.
     * @example
     * // Delete a few Plan_features
     * const { count } = await prisma.plan_features.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plan_featuresDeleteManyArgs>(args?: SelectSubset<T, plan_featuresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_featuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_features
     * const plan_features = await prisma.plan_features.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plan_featuresUpdateManyArgs>(args: SelectSubset<T, plan_featuresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_features and returns the data updated in the database.
     * @param {plan_featuresUpdateManyAndReturnArgs} args - Arguments to update many Plan_features.
     * @example
     * // Update many Plan_features
     * const plan_features = await prisma.plan_features.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plan_features and only return the `id`
     * const plan_featuresWithIdOnly = await prisma.plan_features.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends plan_featuresUpdateManyAndReturnArgs>(args: SelectSubset<T, plan_featuresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan_features.
     * @param {plan_featuresUpsertArgs} args - Arguments to update or create a Plan_features.
     * @example
     * // Update or create a Plan_features
     * const plan_features = await prisma.plan_features.upsert({
     *   create: {
     *     // ... data to create a Plan_features
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_features we want to update
     *   }
     * })
     */
    upsert<T extends plan_featuresUpsertArgs>(args: SelectSubset<T, plan_featuresUpsertArgs<ExtArgs>>): Prisma__plan_featuresClient<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plan_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_featuresCountArgs} args - Arguments to filter Plan_features to count.
     * @example
     * // Count the number of Plan_features
     * const count = await prisma.plan_features.count({
     *   where: {
     *     // ... the filter for the Plan_features we want to count
     *   }
     * })
    **/
    count<T extends plan_featuresCountArgs>(
      args?: Subset<T, plan_featuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_featuresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_featuresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_featuresAggregateArgs>(args: Subset<T, Plan_featuresAggregateArgs>): Prisma.PrismaPromise<GetPlan_featuresAggregateType<T>>

    /**
     * Group by Plan_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_featuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_featuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_featuresGroupByArgs['orderBy'] }
        : { orderBy?: plan_featuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_featuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_featuresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plan_features model
   */
  readonly fields: plan_featuresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_features.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plan_featuresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plans<T extends plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, plansDefaultArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plan_features model
   */ 
  interface plan_featuresFieldRefs {
    readonly id: FieldRef<"plan_features", 'String'>
    readonly created_at: FieldRef<"plan_features", 'DateTime'>
    readonly updated_at: FieldRef<"plan_features", 'DateTime'>
    readonly plan_id: FieldRef<"plan_features", 'String'>
    readonly feature_name: FieldRef<"plan_features", 'String'>
    readonly feature_value: FieldRef<"plan_features", 'String'>
    readonly is_included: FieldRef<"plan_features", 'Boolean'>
    readonly limit_quantity: FieldRef<"plan_features", 'Int'>
    readonly description: FieldRef<"plan_features", 'String'>
  }
    

  // Custom InputTypes
  /**
   * plan_features findUnique
   */
  export type plan_featuresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * Filter, which plan_features to fetch.
     */
    where: plan_featuresWhereUniqueInput
  }

  /**
   * plan_features findUniqueOrThrow
   */
  export type plan_featuresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * Filter, which plan_features to fetch.
     */
    where: plan_featuresWhereUniqueInput
  }

  /**
   * plan_features findFirst
   */
  export type plan_featuresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * Filter, which plan_features to fetch.
     */
    where?: plan_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_features to fetch.
     */
    orderBy?: plan_featuresOrderByWithRelationInput | plan_featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_features.
     */
    cursor?: plan_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_features.
     */
    distinct?: Plan_featuresScalarFieldEnum | Plan_featuresScalarFieldEnum[]
  }

  /**
   * plan_features findFirstOrThrow
   */
  export type plan_featuresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * Filter, which plan_features to fetch.
     */
    where?: plan_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_features to fetch.
     */
    orderBy?: plan_featuresOrderByWithRelationInput | plan_featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_features.
     */
    cursor?: plan_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_features.
     */
    distinct?: Plan_featuresScalarFieldEnum | Plan_featuresScalarFieldEnum[]
  }

  /**
   * plan_features findMany
   */
  export type plan_featuresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * Filter, which plan_features to fetch.
     */
    where?: plan_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_features to fetch.
     */
    orderBy?: plan_featuresOrderByWithRelationInput | plan_featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_features.
     */
    cursor?: plan_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_features.
     */
    skip?: number
    distinct?: Plan_featuresScalarFieldEnum | Plan_featuresScalarFieldEnum[]
  }

  /**
   * plan_features create
   */
  export type plan_featuresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * The data needed to create a plan_features.
     */
    data: XOR<plan_featuresCreateInput, plan_featuresUncheckedCreateInput>
  }

  /**
   * plan_features createMany
   */
  export type plan_featuresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_features.
     */
    data: plan_featuresCreateManyInput | plan_featuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plan_features createManyAndReturn
   */
  export type plan_featuresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * The data used to create many plan_features.
     */
    data: plan_featuresCreateManyInput | plan_featuresCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * plan_features update
   */
  export type plan_featuresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * The data needed to update a plan_features.
     */
    data: XOR<plan_featuresUpdateInput, plan_featuresUncheckedUpdateInput>
    /**
     * Choose, which plan_features to update.
     */
    where: plan_featuresWhereUniqueInput
  }

  /**
   * plan_features updateMany
   */
  export type plan_featuresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_features.
     */
    data: XOR<plan_featuresUpdateManyMutationInput, plan_featuresUncheckedUpdateManyInput>
    /**
     * Filter which plan_features to update
     */
    where?: plan_featuresWhereInput
    /**
     * Limit how many plan_features to update.
     */
    limit?: number
  }

  /**
   * plan_features updateManyAndReturn
   */
  export type plan_featuresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * The data used to update plan_features.
     */
    data: XOR<plan_featuresUpdateManyMutationInput, plan_featuresUncheckedUpdateManyInput>
    /**
     * Filter which plan_features to update
     */
    where?: plan_featuresWhereInput
    /**
     * Limit how many plan_features to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * plan_features upsert
   */
  export type plan_featuresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * The filter to search for the plan_features to update in case it exists.
     */
    where: plan_featuresWhereUniqueInput
    /**
     * In case the plan_features found by the `where` argument doesn't exist, create a new plan_features with this data.
     */
    create: XOR<plan_featuresCreateInput, plan_featuresUncheckedCreateInput>
    /**
     * In case the plan_features was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_featuresUpdateInput, plan_featuresUncheckedUpdateInput>
  }

  /**
   * plan_features delete
   */
  export type plan_featuresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    /**
     * Filter which plan_features to delete.
     */
    where: plan_featuresWhereUniqueInput
  }

  /**
   * plan_features deleteMany
   */
  export type plan_featuresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_features to delete
     */
    where?: plan_featuresWhereInput
    /**
     * Limit how many plan_features to delete.
     */
    limit?: number
  }

  /**
   * plan_features without action
   */
  export type plan_featuresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
  }


  /**
   * Model plans
   */

  export type AggregatePlans = {
    _count: PlansCountAggregateOutputType | null
    _avg: PlansAvgAggregateOutputType | null
    _sum: PlansSumAggregateOutputType | null
    _min: PlansMinAggregateOutputType | null
    _max: PlansMaxAggregateOutputType | null
  }

  export type PlansAvgAggregateOutputType = {
    price: Decimal | null
    trial_period_days: number | null
    setup_fee: Decimal | null
    max_users: number | null
  }

  export type PlansSumAggregateOutputType = {
    price: Decimal | null
    trial_period_days: number | null
    setup_fee: Decimal | null
    max_users: number | null
  }

  export type PlansMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    price: Decimal | null
    billing_cycle: string | null
    color: string | null
    is_active: boolean | null
    branch_id: string | null
    trial_period_days: number | null
    setup_fee: Decimal | null
    max_users: number | null
  }

  export type PlansMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    price: Decimal | null
    billing_cycle: string | null
    color: string | null
    is_active: boolean | null
    branch_id: string | null
    trial_period_days: number | null
    setup_fee: Decimal | null
    max_users: number | null
  }

  export type PlansCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    description: number
    price: number
    billing_cycle: number
    color: number
    is_active: number
    branch_id: number
    trial_period_days: number
    setup_fee: number
    max_users: number
    discounts: number
    _all: number
  }


  export type PlansAvgAggregateInputType = {
    price?: true
    trial_period_days?: true
    setup_fee?: true
    max_users?: true
  }

  export type PlansSumAggregateInputType = {
    price?: true
    trial_period_days?: true
    setup_fee?: true
    max_users?: true
  }

  export type PlansMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    price?: true
    billing_cycle?: true
    color?: true
    is_active?: true
    branch_id?: true
    trial_period_days?: true
    setup_fee?: true
    max_users?: true
  }

  export type PlansMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    price?: true
    billing_cycle?: true
    color?: true
    is_active?: true
    branch_id?: true
    trial_period_days?: true
    setup_fee?: true
    max_users?: true
  }

  export type PlansCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    price?: true
    billing_cycle?: true
    color?: true
    is_active?: true
    branch_id?: true
    trial_period_days?: true
    setup_fee?: true
    max_users?: true
    discounts?: true
    _all?: true
  }

  export type PlansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plans to aggregate.
     */
    where?: plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: plansOrderByWithRelationInput | plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plans
    **/
    _count?: true | PlansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlansMaxAggregateInputType
  }

  export type GetPlansAggregateType<T extends PlansAggregateArgs> = {
        [P in keyof T & keyof AggregatePlans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlans[P]>
      : GetScalarType<T[P], AggregatePlans[P]>
  }




  export type plansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plansWhereInput
    orderBy?: plansOrderByWithAggregationInput | plansOrderByWithAggregationInput[]
    by: PlansScalarFieldEnum[] | PlansScalarFieldEnum
    having?: plansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlansCountAggregateInputType | true
    _avg?: PlansAvgAggregateInputType
    _sum?: PlansSumAggregateInputType
    _min?: PlansMinAggregateInputType
    _max?: PlansMaxAggregateInputType
  }

  export type PlansGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    name: string
    description: string | null
    price: Decimal
    billing_cycle: string
    color: string | null
    is_active: boolean | null
    branch_id: string | null
    trial_period_days: number | null
    setup_fee: Decimal | null
    max_users: number | null
    discounts: JsonValue | null
    _count: PlansCountAggregateOutputType | null
    _avg: PlansAvgAggregateOutputType | null
    _sum: PlansSumAggregateOutputType | null
    _min: PlansMinAggregateOutputType | null
    _max: PlansMaxAggregateOutputType | null
  }

  type GetPlansGroupByPayload<T extends plansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlansGroupByOutputType[P]>
            : GetScalarType<T[P], PlansGroupByOutputType[P]>
        }
      >
    >


  export type plansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    billing_cycle?: boolean
    color?: boolean
    is_active?: boolean
    branch_id?: boolean
    trial_period_days?: boolean
    setup_fee?: boolean
    max_users?: boolean
    discounts?: boolean
    invoice_items?: boolean | plans$invoice_itemsArgs<ExtArgs>
    plan_addresses?: boolean | plans$plan_addressesArgs<ExtArgs>
    plan_features?: boolean | plans$plan_featuresArgs<ExtArgs>
    branches?: boolean | plans$branchesArgs<ExtArgs>
    users?: boolean | plans$usersArgs<ExtArgs>
    _count?: boolean | PlansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plans"]>

  export type plansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    billing_cycle?: boolean
    color?: boolean
    is_active?: boolean
    branch_id?: boolean
    trial_period_days?: boolean
    setup_fee?: boolean
    max_users?: boolean
    discounts?: boolean
    branches?: boolean | plans$branchesArgs<ExtArgs>
  }, ExtArgs["result"]["plans"]>

  export type plansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    billing_cycle?: boolean
    color?: boolean
    is_active?: boolean
    branch_id?: boolean
    trial_period_days?: boolean
    setup_fee?: boolean
    max_users?: boolean
    discounts?: boolean
    branches?: boolean | plans$branchesArgs<ExtArgs>
  }, ExtArgs["result"]["plans"]>

  export type plansSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    billing_cycle?: boolean
    color?: boolean
    is_active?: boolean
    branch_id?: boolean
    trial_period_days?: boolean
    setup_fee?: boolean
    max_users?: boolean
    discounts?: boolean
  }

  export type plansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "description" | "price" | "billing_cycle" | "color" | "is_active" | "branch_id" | "trial_period_days" | "setup_fee" | "max_users" | "discounts", ExtArgs["result"]["plans"]>
  export type plansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_items?: boolean | plans$invoice_itemsArgs<ExtArgs>
    plan_addresses?: boolean | plans$plan_addressesArgs<ExtArgs>
    plan_features?: boolean | plans$plan_featuresArgs<ExtArgs>
    branches?: boolean | plans$branchesArgs<ExtArgs>
    users?: boolean | plans$usersArgs<ExtArgs>
    _count?: boolean | PlansCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type plansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | plans$branchesArgs<ExtArgs>
  }
  export type plansIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | plans$branchesArgs<ExtArgs>
  }

  export type $plansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plans"
    objects: {
      invoice_items: Prisma.$invoice_itemsPayload<ExtArgs>[]
      plan_addresses: Prisma.$plan_addressesPayload<ExtArgs>[]
      plan_features: Prisma.$plan_featuresPayload<ExtArgs>[]
      branches: Prisma.$branchesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      name: string
      description: string | null
      price: Prisma.Decimal
      billing_cycle: string
      color: string | null
      is_active: boolean | null
      branch_id: string | null
      trial_period_days: number | null
      setup_fee: Prisma.Decimal | null
      max_users: number | null
      discounts: Prisma.JsonValue | null
    }, ExtArgs["result"]["plans"]>
    composites: {}
  }

  type plansGetPayload<S extends boolean | null | undefined | plansDefaultArgs> = $Result.GetResult<Prisma.$plansPayload, S>

  type plansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlansCountAggregateInputType | true
    }

  export interface plansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plans'], meta: { name: 'plans' } }
    /**
     * Find zero or one Plans that matches the filter.
     * @param {plansFindUniqueArgs} args - Arguments to find a Plans
     * @example
     * // Get one Plans
     * const plans = await prisma.plans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plansFindUniqueArgs>(args: SelectSubset<T, plansFindUniqueArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plansFindUniqueOrThrowArgs} args - Arguments to find a Plans
     * @example
     * // Get one Plans
     * const plans = await prisma.plans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plansFindUniqueOrThrowArgs>(args: SelectSubset<T, plansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plansFindFirstArgs} args - Arguments to find a Plans
     * @example
     * // Get one Plans
     * const plans = await prisma.plans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plansFindFirstArgs>(args?: SelectSubset<T, plansFindFirstArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plansFindFirstOrThrowArgs} args - Arguments to find a Plans
     * @example
     * // Get one Plans
     * const plans = await prisma.plans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plansFindFirstOrThrowArgs>(args?: SelectSubset<T, plansFindFirstOrThrowArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plans.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plansWithIdOnly = await prisma.plans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plansFindManyArgs>(args?: SelectSubset<T, plansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plans.
     * @param {plansCreateArgs} args - Arguments to create a Plans.
     * @example
     * // Create one Plans
     * const Plans = await prisma.plans.create({
     *   data: {
     *     // ... data to create a Plans
     *   }
     * })
     * 
     */
    create<T extends plansCreateArgs>(args: SelectSubset<T, plansCreateArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {plansCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plans = await prisma.plans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plansCreateManyArgs>(args?: SelectSubset<T, plansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {plansCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plans = await prisma.plans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const plansWithIdOnly = await prisma.plans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends plansCreateManyAndReturnArgs>(args?: SelectSubset<T, plansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plans.
     * @param {plansDeleteArgs} args - Arguments to delete one Plans.
     * @example
     * // Delete one Plans
     * const Plans = await prisma.plans.delete({
     *   where: {
     *     // ... filter to delete one Plans
     *   }
     * })
     * 
     */
    delete<T extends plansDeleteArgs>(args: SelectSubset<T, plansDeleteArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plans.
     * @param {plansUpdateArgs} args - Arguments to update one Plans.
     * @example
     * // Update one Plans
     * const plans = await prisma.plans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plansUpdateArgs>(args: SelectSubset<T, plansUpdateArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {plansDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plansDeleteManyArgs>(args?: SelectSubset<T, plansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plans = await prisma.plans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plansUpdateManyArgs>(args: SelectSubset<T, plansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {plansUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plans = await prisma.plans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const plansWithIdOnly = await prisma.plans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends plansUpdateManyAndReturnArgs>(args: SelectSubset<T, plansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plans.
     * @param {plansUpsertArgs} args - Arguments to update or create a Plans.
     * @example
     * // Update or create a Plans
     * const plans = await prisma.plans.upsert({
     *   create: {
     *     // ... data to create a Plans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plans we want to update
     *   }
     * })
     */
    upsert<T extends plansUpsertArgs>(args: SelectSubset<T, plansUpsertArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plansCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plans.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends plansCountArgs>(
      args?: Subset<T, plansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlansAggregateArgs>(args: Subset<T, PlansAggregateArgs>): Prisma.PrismaPromise<GetPlansAggregateType<T>>

    /**
     * Group by Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plansGroupByArgs['orderBy'] }
        : { orderBy?: plansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plans model
   */
  readonly fields: plansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice_items<T extends plans$invoice_itemsArgs<ExtArgs> = {}>(args?: Subset<T, plans$invoice_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plan_addresses<T extends plans$plan_addressesArgs<ExtArgs> = {}>(args?: Subset<T, plans$plan_addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_addressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plan_features<T extends plans$plan_featuresArgs<ExtArgs> = {}>(args?: Subset<T, plans$plan_featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_featuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branches<T extends plans$branchesArgs<ExtArgs> = {}>(args?: Subset<T, plans$branchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends plans$usersArgs<ExtArgs> = {}>(args?: Subset<T, plans$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plans model
   */ 
  interface plansFieldRefs {
    readonly id: FieldRef<"plans", 'String'>
    readonly created_at: FieldRef<"plans", 'DateTime'>
    readonly updated_at: FieldRef<"plans", 'DateTime'>
    readonly name: FieldRef<"plans", 'String'>
    readonly description: FieldRef<"plans", 'String'>
    readonly price: FieldRef<"plans", 'Decimal'>
    readonly billing_cycle: FieldRef<"plans", 'String'>
    readonly color: FieldRef<"plans", 'String'>
    readonly is_active: FieldRef<"plans", 'Boolean'>
    readonly branch_id: FieldRef<"plans", 'String'>
    readonly trial_period_days: FieldRef<"plans", 'Int'>
    readonly setup_fee: FieldRef<"plans", 'Decimal'>
    readonly max_users: FieldRef<"plans", 'Int'>
    readonly discounts: FieldRef<"plans", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * plans findUnique
   */
  export type plansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * Filter, which plans to fetch.
     */
    where: plansWhereUniqueInput
  }

  /**
   * plans findUniqueOrThrow
   */
  export type plansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * Filter, which plans to fetch.
     */
    where: plansWhereUniqueInput
  }

  /**
   * plans findFirst
   */
  export type plansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * Filter, which plans to fetch.
     */
    where?: plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: plansOrderByWithRelationInput | plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plans.
     */
    cursor?: plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plans.
     */
    distinct?: PlansScalarFieldEnum | PlansScalarFieldEnum[]
  }

  /**
   * plans findFirstOrThrow
   */
  export type plansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * Filter, which plans to fetch.
     */
    where?: plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: plansOrderByWithRelationInput | plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plans.
     */
    cursor?: plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plans.
     */
    distinct?: PlansScalarFieldEnum | PlansScalarFieldEnum[]
  }

  /**
   * plans findMany
   */
  export type plansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * Filter, which plans to fetch.
     */
    where?: plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: plansOrderByWithRelationInput | plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plans.
     */
    cursor?: plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    distinct?: PlansScalarFieldEnum | PlansScalarFieldEnum[]
  }

  /**
   * plans create
   */
  export type plansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * The data needed to create a plans.
     */
    data: XOR<plansCreateInput, plansUncheckedCreateInput>
  }

  /**
   * plans createMany
   */
  export type plansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plans.
     */
    data: plansCreateManyInput | plansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plans createManyAndReturn
   */
  export type plansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * The data used to create many plans.
     */
    data: plansCreateManyInput | plansCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * plans update
   */
  export type plansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * The data needed to update a plans.
     */
    data: XOR<plansUpdateInput, plansUncheckedUpdateInput>
    /**
     * Choose, which plans to update.
     */
    where: plansWhereUniqueInput
  }

  /**
   * plans updateMany
   */
  export type plansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plans.
     */
    data: XOR<plansUpdateManyMutationInput, plansUncheckedUpdateManyInput>
    /**
     * Filter which plans to update
     */
    where?: plansWhereInput
    /**
     * Limit how many plans to update.
     */
    limit?: number
  }

  /**
   * plans updateManyAndReturn
   */
  export type plansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * The data used to update plans.
     */
    data: XOR<plansUpdateManyMutationInput, plansUncheckedUpdateManyInput>
    /**
     * Filter which plans to update
     */
    where?: plansWhereInput
    /**
     * Limit how many plans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * plans upsert
   */
  export type plansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * The filter to search for the plans to update in case it exists.
     */
    where: plansWhereUniqueInput
    /**
     * In case the plans found by the `where` argument doesn't exist, create a new plans with this data.
     */
    create: XOR<plansCreateInput, plansUncheckedCreateInput>
    /**
     * In case the plans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plansUpdateInput, plansUncheckedUpdateInput>
  }

  /**
   * plans delete
   */
  export type plansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    /**
     * Filter which plans to delete.
     */
    where: plansWhereUniqueInput
  }

  /**
   * plans deleteMany
   */
  export type plansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plans to delete
     */
    where?: plansWhereInput
    /**
     * Limit how many plans to delete.
     */
    limit?: number
  }

  /**
   * plans.invoice_items
   */
  export type plans$invoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    where?: invoice_itemsWhereInput
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    cursor?: invoice_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * plans.plan_addresses
   */
  export type plans$plan_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_addresses
     */
    select?: plan_addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_addresses
     */
    omit?: plan_addressesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_addressesInclude<ExtArgs> | null
    where?: plan_addressesWhereInput
    orderBy?: plan_addressesOrderByWithRelationInput | plan_addressesOrderByWithRelationInput[]
    cursor?: plan_addressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Plan_addressesScalarFieldEnum | Plan_addressesScalarFieldEnum[]
  }

  /**
   * plans.plan_features
   */
  export type plans$plan_featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_features
     */
    select?: plan_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_features
     */
    omit?: plan_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_featuresInclude<ExtArgs> | null
    where?: plan_featuresWhereInput
    orderBy?: plan_featuresOrderByWithRelationInput | plan_featuresOrderByWithRelationInput[]
    cursor?: plan_featuresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Plan_featuresScalarFieldEnum | Plan_featuresScalarFieldEnum[]
  }

  /**
   * plans.branches
   */
  export type plans$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * plans.users
   */
  export type plans$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * plans without action
   */
  export type plansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    price: Decimal | null
    sale_price: Decimal | null
    stock_quantity: number | null
    weight: Decimal | null
    min_stock_alert: number | null
    tax_rate: Decimal | null
  }

  export type ProductsSumAggregateOutputType = {
    price: Decimal | null
    sale_price: Decimal | null
    stock_quantity: number | null
    weight: Decimal | null
    min_stock_alert: number | null
    tax_rate: Decimal | null
  }

  export type ProductsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    price: Decimal | null
    sale_price: Decimal | null
    sku: string | null
    barcode: string | null
    stock_quantity: number | null
    is_active: boolean | null
    status: $Enums.product_status_enum | null
    category_id: string | null
    branch_id: string | null
    weight: Decimal | null
    min_stock_alert: number | null
    manufacturer: string | null
    tax_rate: Decimal | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    price: Decimal | null
    sale_price: Decimal | null
    sku: string | null
    barcode: string | null
    stock_quantity: number | null
    is_active: boolean | null
    status: $Enums.product_status_enum | null
    category_id: string | null
    branch_id: string | null
    weight: Decimal | null
    min_stock_alert: number | null
    manufacturer: string | null
    tax_rate: Decimal | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    description: number
    price: number
    sale_price: number
    sku: number
    barcode: number
    stock_quantity: number
    is_active: number
    status: number
    category_id: number
    branch_id: number
    weight: number
    dimensions: number
    images: number
    tags: number
    min_stock_alert: number
    manufacturer: number
    tax_rate: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    price?: true
    sale_price?: true
    stock_quantity?: true
    weight?: true
    min_stock_alert?: true
    tax_rate?: true
  }

  export type ProductsSumAggregateInputType = {
    price?: true
    sale_price?: true
    stock_quantity?: true
    weight?: true
    min_stock_alert?: true
    tax_rate?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    price?: true
    sale_price?: true
    sku?: true
    barcode?: true
    stock_quantity?: true
    is_active?: true
    status?: true
    category_id?: true
    branch_id?: true
    weight?: true
    min_stock_alert?: true
    manufacturer?: true
    tax_rate?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    price?: true
    sale_price?: true
    sku?: true
    barcode?: true
    stock_quantity?: true
    is_active?: true
    status?: true
    category_id?: true
    branch_id?: true
    weight?: true
    min_stock_alert?: true
    manufacturer?: true
    tax_rate?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    price?: true
    sale_price?: true
    sku?: true
    barcode?: true
    stock_quantity?: true
    is_active?: true
    status?: true
    category_id?: true
    branch_id?: true
    weight?: true
    dimensions?: true
    images?: true
    tags?: true
    min_stock_alert?: true
    manufacturer?: true
    tax_rate?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    name: string
    description: string | null
    price: Decimal
    sale_price: Decimal | null
    sku: string | null
    barcode: string | null
    stock_quantity: number | null
    is_active: boolean | null
    status: $Enums.product_status_enum | null
    category_id: string | null
    branch_id: string | null
    weight: Decimal | null
    dimensions: JsonValue | null
    images: string[]
    tags: string[]
    min_stock_alert: number | null
    manufacturer: string | null
    tax_rate: Decimal | null
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sale_price?: boolean
    sku?: boolean
    barcode?: boolean
    stock_quantity?: boolean
    is_active?: boolean
    status?: boolean
    category_id?: boolean
    branch_id?: boolean
    weight?: boolean
    dimensions?: boolean
    images?: boolean
    tags?: boolean
    min_stock_alert?: boolean
    manufacturer?: boolean
    tax_rate?: boolean
    invoice_items?: boolean | products$invoice_itemsArgs<ExtArgs>
    branches?: boolean | products$branchesArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sale_price?: boolean
    sku?: boolean
    barcode?: boolean
    stock_quantity?: boolean
    is_active?: boolean
    status?: boolean
    category_id?: boolean
    branch_id?: boolean
    weight?: boolean
    dimensions?: boolean
    images?: boolean
    tags?: boolean
    min_stock_alert?: boolean
    manufacturer?: boolean
    tax_rate?: boolean
    branches?: boolean | products$branchesArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sale_price?: boolean
    sku?: boolean
    barcode?: boolean
    stock_quantity?: boolean
    is_active?: boolean
    status?: boolean
    category_id?: boolean
    branch_id?: boolean
    weight?: boolean
    dimensions?: boolean
    images?: boolean
    tags?: boolean
    min_stock_alert?: boolean
    manufacturer?: boolean
    tax_rate?: boolean
    branches?: boolean | products$branchesArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sale_price?: boolean
    sku?: boolean
    barcode?: boolean
    stock_quantity?: boolean
    is_active?: boolean
    status?: boolean
    category_id?: boolean
    branch_id?: boolean
    weight?: boolean
    dimensions?: boolean
    images?: boolean
    tags?: boolean
    min_stock_alert?: boolean
    manufacturer?: boolean
    tax_rate?: boolean
  }

  export type productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "description" | "price" | "sale_price" | "sku" | "barcode" | "stock_quantity" | "is_active" | "status" | "category_id" | "branch_id" | "weight" | "dimensions" | "images" | "tags" | "min_stock_alert" | "manufacturer" | "tax_rate", ExtArgs["result"]["products"]>
  export type productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_items?: boolean | products$invoice_itemsArgs<ExtArgs>
    branches?: boolean | products$branchesArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | products$branchesArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
  }
  export type productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | products$branchesArgs<ExtArgs>
    categories?: boolean | products$categoriesArgs<ExtArgs>
  }

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {
      invoice_items: Prisma.$invoice_itemsPayload<ExtArgs>[]
      branches: Prisma.$branchesPayload<ExtArgs> | null
      categories: Prisma.$categoriesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      name: string
      description: string | null
      price: Prisma.Decimal
      sale_price: Prisma.Decimal | null
      sku: string | null
      barcode: string | null
      stock_quantity: number | null
      is_active: boolean | null
      status: $Enums.product_status_enum | null
      category_id: string | null
      branch_id: string | null
      weight: Prisma.Decimal | null
      dimensions: Prisma.JsonValue | null
      images: string[]
      tags: string[]
      min_stock_alert: number | null
      manufacturer: string | null
      tax_rate: Prisma.Decimal | null
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productsCreateManyAndReturnArgs>(args?: SelectSubset<T, productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productsUpdateManyAndReturnArgs>(args: SelectSubset<T, productsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice_items<T extends products$invoice_itemsArgs<ExtArgs> = {}>(args?: Subset<T, products$invoice_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branches<T extends products$branchesArgs<ExtArgs> = {}>(args?: Subset<T, products$branchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    categories<T extends products$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, products$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */ 
  interface productsFieldRefs {
    readonly id: FieldRef<"products", 'String'>
    readonly created_at: FieldRef<"products", 'DateTime'>
    readonly updated_at: FieldRef<"products", 'DateTime'>
    readonly name: FieldRef<"products", 'String'>
    readonly description: FieldRef<"products", 'String'>
    readonly price: FieldRef<"products", 'Decimal'>
    readonly sale_price: FieldRef<"products", 'Decimal'>
    readonly sku: FieldRef<"products", 'String'>
    readonly barcode: FieldRef<"products", 'String'>
    readonly stock_quantity: FieldRef<"products", 'Int'>
    readonly is_active: FieldRef<"products", 'Boolean'>
    readonly status: FieldRef<"products", 'product_status_enum'>
    readonly category_id: FieldRef<"products", 'String'>
    readonly branch_id: FieldRef<"products", 'String'>
    readonly weight: FieldRef<"products", 'Decimal'>
    readonly dimensions: FieldRef<"products", 'Json'>
    readonly images: FieldRef<"products", 'String[]'>
    readonly tags: FieldRef<"products", 'String[]'>
    readonly min_stock_alert: FieldRef<"products", 'Int'>
    readonly manufacturer: FieldRef<"products", 'String'>
    readonly tax_rate: FieldRef<"products", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products createManyAndReturn
   */
  export type productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * products updateManyAndReturn
   */
  export type productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * products.invoice_items
   */
  export type products$invoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    where?: invoice_itemsWhereInput
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    cursor?: invoice_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * products.branches
   */
  export type products$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * products.categories
   */
  export type products$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
  }


  /**
   * Model type_users
   */

  export type AggregateType_users = {
    _count: Type_usersCountAggregateOutputType | null
    _min: Type_usersMinAggregateOutputType | null
    _max: Type_usersMaxAggregateOutputType | null
  }

  export type Type_usersMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    code: string | null
    description: string | null
    name: string | null
  }

  export type Type_usersMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    code: string | null
    description: string | null
    name: string | null
  }

  export type Type_usersCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    code: number
    description: number
    name: number
    permissions: number
    _all: number
  }


  export type Type_usersMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    description?: true
    name?: true
  }

  export type Type_usersMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    description?: true
    name?: true
  }

  export type Type_usersCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    description?: true
    name?: true
    permissions?: true
    _all?: true
  }

  export type Type_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type_users to aggregate.
     */
    where?: type_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_users to fetch.
     */
    orderBy?: type_usersOrderByWithRelationInput | type_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: type_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned type_users
    **/
    _count?: true | Type_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Type_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Type_usersMaxAggregateInputType
  }

  export type GetType_usersAggregateType<T extends Type_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateType_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType_users[P]>
      : GetScalarType<T[P], AggregateType_users[P]>
  }




  export type type_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: type_usersWhereInput
    orderBy?: type_usersOrderByWithAggregationInput | type_usersOrderByWithAggregationInput[]
    by: Type_usersScalarFieldEnum[] | Type_usersScalarFieldEnum
    having?: type_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Type_usersCountAggregateInputType | true
    _min?: Type_usersMinAggregateInputType
    _max?: Type_usersMaxAggregateInputType
  }

  export type Type_usersGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    code: string | null
    description: string | null
    name: string
    permissions: JsonValue | null
    _count: Type_usersCountAggregateOutputType | null
    _min: Type_usersMinAggregateOutputType | null
    _max: Type_usersMaxAggregateOutputType | null
  }

  type GetType_usersGroupByPayload<T extends type_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Type_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Type_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Type_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Type_usersGroupByOutputType[P]>
        }
      >
    >


  export type type_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    description?: boolean
    name?: boolean
    permissions?: boolean
    users?: boolean | type_users$usersArgs<ExtArgs>
    _count?: boolean | Type_usersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type_users"]>

  export type type_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    description?: boolean
    name?: boolean
    permissions?: boolean
  }, ExtArgs["result"]["type_users"]>

  export type type_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    description?: boolean
    name?: boolean
    permissions?: boolean
  }, ExtArgs["result"]["type_users"]>

  export type type_usersSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    description?: boolean
    name?: boolean
    permissions?: boolean
  }

  export type type_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "code" | "description" | "name" | "permissions", ExtArgs["result"]["type_users"]>
  export type type_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | type_users$usersArgs<ExtArgs>
    _count?: boolean | Type_usersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type type_usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type type_usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $type_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "type_users"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      code: string | null
      description: string | null
      name: string
      permissions: Prisma.JsonValue | null
    }, ExtArgs["result"]["type_users"]>
    composites: {}
  }

  type type_usersGetPayload<S extends boolean | null | undefined | type_usersDefaultArgs> = $Result.GetResult<Prisma.$type_usersPayload, S>

  type type_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<type_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Type_usersCountAggregateInputType | true
    }

  export interface type_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['type_users'], meta: { name: 'type_users' } }
    /**
     * Find zero or one Type_users that matches the filter.
     * @param {type_usersFindUniqueArgs} args - Arguments to find a Type_users
     * @example
     * // Get one Type_users
     * const type_users = await prisma.type_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends type_usersFindUniqueArgs>(args: SelectSubset<T, type_usersFindUniqueArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Type_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {type_usersFindUniqueOrThrowArgs} args - Arguments to find a Type_users
     * @example
     * // Get one Type_users
     * const type_users = await prisma.type_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends type_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, type_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_usersFindFirstArgs} args - Arguments to find a Type_users
     * @example
     * // Get one Type_users
     * const type_users = await prisma.type_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends type_usersFindFirstArgs>(args?: SelectSubset<T, type_usersFindFirstArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_usersFindFirstOrThrowArgs} args - Arguments to find a Type_users
     * @example
     * // Get one Type_users
     * const type_users = await prisma.type_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends type_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, type_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Type_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Type_users
     * const type_users = await prisma.type_users.findMany()
     * 
     * // Get first 10 Type_users
     * const type_users = await prisma.type_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const type_usersWithIdOnly = await prisma.type_users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends type_usersFindManyArgs>(args?: SelectSubset<T, type_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Type_users.
     * @param {type_usersCreateArgs} args - Arguments to create a Type_users.
     * @example
     * // Create one Type_users
     * const Type_users = await prisma.type_users.create({
     *   data: {
     *     // ... data to create a Type_users
     *   }
     * })
     * 
     */
    create<T extends type_usersCreateArgs>(args: SelectSubset<T, type_usersCreateArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Type_users.
     * @param {type_usersCreateManyArgs} args - Arguments to create many Type_users.
     * @example
     * // Create many Type_users
     * const type_users = await prisma.type_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends type_usersCreateManyArgs>(args?: SelectSubset<T, type_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Type_users and returns the data saved in the database.
     * @param {type_usersCreateManyAndReturnArgs} args - Arguments to create many Type_users.
     * @example
     * // Create many Type_users
     * const type_users = await prisma.type_users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Type_users and only return the `id`
     * const type_usersWithIdOnly = await prisma.type_users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends type_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, type_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Type_users.
     * @param {type_usersDeleteArgs} args - Arguments to delete one Type_users.
     * @example
     * // Delete one Type_users
     * const Type_users = await prisma.type_users.delete({
     *   where: {
     *     // ... filter to delete one Type_users
     *   }
     * })
     * 
     */
    delete<T extends type_usersDeleteArgs>(args: SelectSubset<T, type_usersDeleteArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Type_users.
     * @param {type_usersUpdateArgs} args - Arguments to update one Type_users.
     * @example
     * // Update one Type_users
     * const type_users = await prisma.type_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends type_usersUpdateArgs>(args: SelectSubset<T, type_usersUpdateArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Type_users.
     * @param {type_usersDeleteManyArgs} args - Arguments to filter Type_users to delete.
     * @example
     * // Delete a few Type_users
     * const { count } = await prisma.type_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends type_usersDeleteManyArgs>(args?: SelectSubset<T, type_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Type_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Type_users
     * const type_users = await prisma.type_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends type_usersUpdateManyArgs>(args: SelectSubset<T, type_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Type_users and returns the data updated in the database.
     * @param {type_usersUpdateManyAndReturnArgs} args - Arguments to update many Type_users.
     * @example
     * // Update many Type_users
     * const type_users = await prisma.type_users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Type_users and only return the `id`
     * const type_usersWithIdOnly = await prisma.type_users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends type_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, type_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Type_users.
     * @param {type_usersUpsertArgs} args - Arguments to update or create a Type_users.
     * @example
     * // Update or create a Type_users
     * const type_users = await prisma.type_users.upsert({
     *   create: {
     *     // ... data to create a Type_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type_users we want to update
     *   }
     * })
     */
    upsert<T extends type_usersUpsertArgs>(args: SelectSubset<T, type_usersUpsertArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Type_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_usersCountArgs} args - Arguments to filter Type_users to count.
     * @example
     * // Count the number of Type_users
     * const count = await prisma.type_users.count({
     *   where: {
     *     // ... the filter for the Type_users we want to count
     *   }
     * })
    **/
    count<T extends type_usersCountArgs>(
      args?: Subset<T, type_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Type_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Type_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Type_usersAggregateArgs>(args: Subset<T, Type_usersAggregateArgs>): Prisma.PrismaPromise<GetType_usersAggregateType<T>>

    /**
     * Group by Type_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends type_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: type_usersGroupByArgs['orderBy'] }
        : { orderBy?: type_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, type_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetType_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the type_users model
   */
  readonly fields: type_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for type_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__type_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends type_users$usersArgs<ExtArgs> = {}>(args?: Subset<T, type_users$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the type_users model
   */ 
  interface type_usersFieldRefs {
    readonly id: FieldRef<"type_users", 'String'>
    readonly created_at: FieldRef<"type_users", 'DateTime'>
    readonly updated_at: FieldRef<"type_users", 'DateTime'>
    readonly code: FieldRef<"type_users", 'String'>
    readonly description: FieldRef<"type_users", 'String'>
    readonly name: FieldRef<"type_users", 'String'>
    readonly permissions: FieldRef<"type_users", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * type_users findUnique
   */
  export type type_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * Filter, which type_users to fetch.
     */
    where: type_usersWhereUniqueInput
  }

  /**
   * type_users findUniqueOrThrow
   */
  export type type_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * Filter, which type_users to fetch.
     */
    where: type_usersWhereUniqueInput
  }

  /**
   * type_users findFirst
   */
  export type type_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * Filter, which type_users to fetch.
     */
    where?: type_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_users to fetch.
     */
    orderBy?: type_usersOrderByWithRelationInput | type_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_users.
     */
    cursor?: type_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_users.
     */
    distinct?: Type_usersScalarFieldEnum | Type_usersScalarFieldEnum[]
  }

  /**
   * type_users findFirstOrThrow
   */
  export type type_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * Filter, which type_users to fetch.
     */
    where?: type_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_users to fetch.
     */
    orderBy?: type_usersOrderByWithRelationInput | type_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_users.
     */
    cursor?: type_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_users.
     */
    distinct?: Type_usersScalarFieldEnum | Type_usersScalarFieldEnum[]
  }

  /**
   * type_users findMany
   */
  export type type_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * Filter, which type_users to fetch.
     */
    where?: type_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_users to fetch.
     */
    orderBy?: type_usersOrderByWithRelationInput | type_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing type_users.
     */
    cursor?: type_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_users.
     */
    skip?: number
    distinct?: Type_usersScalarFieldEnum | Type_usersScalarFieldEnum[]
  }

  /**
   * type_users create
   */
  export type type_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * The data needed to create a type_users.
     */
    data: XOR<type_usersCreateInput, type_usersUncheckedCreateInput>
  }

  /**
   * type_users createMany
   */
  export type type_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many type_users.
     */
    data: type_usersCreateManyInput | type_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * type_users createManyAndReturn
   */
  export type type_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * The data used to create many type_users.
     */
    data: type_usersCreateManyInput | type_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * type_users update
   */
  export type type_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * The data needed to update a type_users.
     */
    data: XOR<type_usersUpdateInput, type_usersUncheckedUpdateInput>
    /**
     * Choose, which type_users to update.
     */
    where: type_usersWhereUniqueInput
  }

  /**
   * type_users updateMany
   */
  export type type_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update type_users.
     */
    data: XOR<type_usersUpdateManyMutationInput, type_usersUncheckedUpdateManyInput>
    /**
     * Filter which type_users to update
     */
    where?: type_usersWhereInput
    /**
     * Limit how many type_users to update.
     */
    limit?: number
  }

  /**
   * type_users updateManyAndReturn
   */
  export type type_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * The data used to update type_users.
     */
    data: XOR<type_usersUpdateManyMutationInput, type_usersUncheckedUpdateManyInput>
    /**
     * Filter which type_users to update
     */
    where?: type_usersWhereInput
    /**
     * Limit how many type_users to update.
     */
    limit?: number
  }

  /**
   * type_users upsert
   */
  export type type_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * The filter to search for the type_users to update in case it exists.
     */
    where: type_usersWhereUniqueInput
    /**
     * In case the type_users found by the `where` argument doesn't exist, create a new type_users with this data.
     */
    create: XOR<type_usersCreateInput, type_usersUncheckedCreateInput>
    /**
     * In case the type_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<type_usersUpdateInput, type_usersUncheckedUpdateInput>
  }

  /**
   * type_users delete
   */
  export type type_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    /**
     * Filter which type_users to delete.
     */
    where: type_usersWhereUniqueInput
  }

  /**
   * type_users deleteMany
   */
  export type type_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type_users to delete
     */
    where?: type_usersWhereInput
    /**
     * Limit how many type_users to delete.
     */
    limit?: number
  }

  /**
   * type_users.users
   */
  export type type_users$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * type_users without action
   */
  export type type_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    account_status: boolean | null
    birth_date: Date | null
    branch_id: string | null
    email: string | null
    first_name: string | null
    is_email_verified: boolean | null
    is_online: boolean | null
    is_verified: boolean | null
    last_name: string | null
    last_seen: Date | null
    phone: string | null
    photo_url: string | null
    plan_id: string | null
    type_user_id: string | null
    shipping_insurance: boolean | null
    is_business: boolean | null
    ruc: string | null
    company_name: string | null
    referral_source_id: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    account_status: boolean | null
    birth_date: Date | null
    branch_id: string | null
    email: string | null
    first_name: string | null
    is_email_verified: boolean | null
    is_online: boolean | null
    is_verified: boolean | null
    last_name: string | null
    last_seen: Date | null
    phone: string | null
    photo_url: string | null
    plan_id: string | null
    type_user_id: string | null
    shipping_insurance: boolean | null
    is_business: boolean | null
    ruc: string | null
    company_name: string | null
    referral_source_id: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    account_status: number
    birth_date: number
    branch_id: number
    email: number
    first_name: number
    is_email_verified: number
    is_online: number
    is_verified: number
    last_name: number
    last_seen: number
    phone: number
    photo_url: number
    plan_id: number
    type_user_id: number
    shipping_insurance: number
    is_business: number
    ruc: number
    company_name: number
    referral_source_id: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    account_status?: true
    birth_date?: true
    branch_id?: true
    email?: true
    first_name?: true
    is_email_verified?: true
    is_online?: true
    is_verified?: true
    last_name?: true
    last_seen?: true
    phone?: true
    photo_url?: true
    plan_id?: true
    type_user_id?: true
    shipping_insurance?: true
    is_business?: true
    ruc?: true
    company_name?: true
    referral_source_id?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    account_status?: true
    birth_date?: true
    branch_id?: true
    email?: true
    first_name?: true
    is_email_verified?: true
    is_online?: true
    is_verified?: true
    last_name?: true
    last_seen?: true
    phone?: true
    photo_url?: true
    plan_id?: true
    type_user_id?: true
    shipping_insurance?: true
    is_business?: true
    ruc?: true
    company_name?: true
    referral_source_id?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    account_status?: true
    birth_date?: true
    branch_id?: true
    email?: true
    first_name?: true
    is_email_verified?: true
    is_online?: true
    is_verified?: true
    last_name?: true
    last_seen?: true
    phone?: true
    photo_url?: true
    plan_id?: true
    type_user_id?: true
    shipping_insurance?: true
    is_business?: true
    ruc?: true
    company_name?: true
    referral_source_id?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    account_status: boolean | null
    birth_date: Date | null
    branch_id: string | null
    email: string | null
    first_name: string | null
    is_email_verified: boolean | null
    is_online: boolean | null
    is_verified: boolean | null
    last_name: string | null
    last_seen: Date | null
    phone: string | null
    photo_url: string | null
    plan_id: string | null
    type_user_id: string | null
    shipping_insurance: boolean
    is_business: boolean | null
    ruc: string | null
    company_name: string | null
    referral_source_id: string | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_status?: boolean
    birth_date?: boolean
    branch_id?: boolean
    email?: boolean
    first_name?: boolean
    is_email_verified?: boolean
    is_online?: boolean
    is_verified?: boolean
    last_name?: boolean
    last_seen?: boolean
    phone?: boolean
    photo_url?: boolean
    plan_id?: boolean
    type_user_id?: boolean
    shipping_insurance?: boolean
    is_business?: boolean
    ruc?: boolean
    company_name?: boolean
    referral_source_id?: boolean
    email_campaigns?: boolean | users$email_campaignsArgs<ExtArgs>
    invoices?: boolean | users$invoicesArgs<ExtArgs>
    notification_preferences?: boolean | users$notification_preferencesArgs<ExtArgs>
    notification_users?: boolean | users$notification_usersArgs<ExtArgs>
    packages?: boolean | users$packagesArgs<ExtArgs>
    saved_cards?: boolean | users$saved_cardsArgs<ExtArgs>
    branches?: boolean | users$branchesArgs<ExtArgs>
    plans?: boolean | users$plansArgs<ExtArgs>
    referral_sources?: boolean | users$referral_sourcesArgs<ExtArgs>
    type_users?: boolean | users$type_usersArgs<ExtArgs>
    wallets?: boolean | users$walletsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_status?: boolean
    birth_date?: boolean
    branch_id?: boolean
    email?: boolean
    first_name?: boolean
    is_email_verified?: boolean
    is_online?: boolean
    is_verified?: boolean
    last_name?: boolean
    last_seen?: boolean
    phone?: boolean
    photo_url?: boolean
    plan_id?: boolean
    type_user_id?: boolean
    shipping_insurance?: boolean
    is_business?: boolean
    ruc?: boolean
    company_name?: boolean
    referral_source_id?: boolean
    branches?: boolean | users$branchesArgs<ExtArgs>
    plans?: boolean | users$plansArgs<ExtArgs>
    referral_sources?: boolean | users$referral_sourcesArgs<ExtArgs>
    type_users?: boolean | users$type_usersArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_status?: boolean
    birth_date?: boolean
    branch_id?: boolean
    email?: boolean
    first_name?: boolean
    is_email_verified?: boolean
    is_online?: boolean
    is_verified?: boolean
    last_name?: boolean
    last_seen?: boolean
    phone?: boolean
    photo_url?: boolean
    plan_id?: boolean
    type_user_id?: boolean
    shipping_insurance?: boolean
    is_business?: boolean
    ruc?: boolean
    company_name?: boolean
    referral_source_id?: boolean
    branches?: boolean | users$branchesArgs<ExtArgs>
    plans?: boolean | users$plansArgs<ExtArgs>
    referral_sources?: boolean | users$referral_sourcesArgs<ExtArgs>
    type_users?: boolean | users$type_usersArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    account_status?: boolean
    birth_date?: boolean
    branch_id?: boolean
    email?: boolean
    first_name?: boolean
    is_email_verified?: boolean
    is_online?: boolean
    is_verified?: boolean
    last_name?: boolean
    last_seen?: boolean
    phone?: boolean
    photo_url?: boolean
    plan_id?: boolean
    type_user_id?: boolean
    shipping_insurance?: boolean
    is_business?: boolean
    ruc?: boolean
    company_name?: boolean
    referral_source_id?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "account_status" | "birth_date" | "branch_id" | "email" | "first_name" | "is_email_verified" | "is_online" | "is_verified" | "last_name" | "last_seen" | "phone" | "photo_url" | "plan_id" | "type_user_id" | "shipping_insurance" | "is_business" | "ruc" | "company_name" | "referral_source_id", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email_campaigns?: boolean | users$email_campaignsArgs<ExtArgs>
    invoices?: boolean | users$invoicesArgs<ExtArgs>
    notification_preferences?: boolean | users$notification_preferencesArgs<ExtArgs>
    notification_users?: boolean | users$notification_usersArgs<ExtArgs>
    packages?: boolean | users$packagesArgs<ExtArgs>
    saved_cards?: boolean | users$saved_cardsArgs<ExtArgs>
    branches?: boolean | users$branchesArgs<ExtArgs>
    plans?: boolean | users$plansArgs<ExtArgs>
    referral_sources?: boolean | users$referral_sourcesArgs<ExtArgs>
    type_users?: boolean | users$type_usersArgs<ExtArgs>
    wallets?: boolean | users$walletsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | users$branchesArgs<ExtArgs>
    plans?: boolean | users$plansArgs<ExtArgs>
    referral_sources?: boolean | users$referral_sourcesArgs<ExtArgs>
    type_users?: boolean | users$type_usersArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | users$branchesArgs<ExtArgs>
    plans?: boolean | users$plansArgs<ExtArgs>
    referral_sources?: boolean | users$referral_sourcesArgs<ExtArgs>
    type_users?: boolean | users$type_usersArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      email_campaigns: Prisma.$email_campaignsPayload<ExtArgs>[]
      invoices: Prisma.$invoicesPayload<ExtArgs>[]
      notification_preferences: Prisma.$notification_preferencesPayload<ExtArgs>[]
      notification_users: Prisma.$notification_usersPayload<ExtArgs>[]
      packages: Prisma.$packagesPayload<ExtArgs>[]
      saved_cards: Prisma.$saved_cardsPayload<ExtArgs>[]
      branches: Prisma.$branchesPayload<ExtArgs> | null
      plans: Prisma.$plansPayload<ExtArgs> | null
      referral_sources: Prisma.$referral_sourcesPayload<ExtArgs> | null
      type_users: Prisma.$type_usersPayload<ExtArgs> | null
      wallets: Prisma.$walletsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      account_status: boolean | null
      birth_date: Date | null
      branch_id: string | null
      email: string | null
      first_name: string | null
      is_email_verified: boolean | null
      is_online: boolean | null
      is_verified: boolean | null
      last_name: string | null
      last_seen: Date | null
      phone: string | null
      photo_url: string | null
      plan_id: string | null
      type_user_id: string | null
      shipping_insurance: boolean
      is_business: boolean | null
      ruc: string | null
      company_name: string | null
      referral_source_id: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email_campaigns<T extends users$email_campaignsArgs<ExtArgs> = {}>(args?: Subset<T, users$email_campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_campaignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends users$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, users$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification_preferences<T extends users$notification_preferencesArgs<ExtArgs> = {}>(args?: Subset<T, users$notification_preferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification_users<T extends users$notification_usersArgs<ExtArgs> = {}>(args?: Subset<T, users$notification_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packages<T extends users$packagesArgs<ExtArgs> = {}>(args?: Subset<T, users$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saved_cards<T extends users$saved_cardsArgs<ExtArgs> = {}>(args?: Subset<T, users$saved_cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branches<T extends users$branchesArgs<ExtArgs> = {}>(args?: Subset<T, users$branchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    plans<T extends users$plansArgs<ExtArgs> = {}>(args?: Subset<T, users$plansArgs<ExtArgs>>): Prisma__plansClient<$Result.GetResult<Prisma.$plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    referral_sources<T extends users$referral_sourcesArgs<ExtArgs> = {}>(args?: Subset<T, users$referral_sourcesArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    type_users<T extends users$type_usersArgs<ExtArgs> = {}>(args?: Subset<T, users$type_usersArgs<ExtArgs>>): Prisma__type_usersClient<$Result.GetResult<Prisma.$type_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wallets<T extends users$walletsArgs<ExtArgs> = {}>(args?: Subset<T, users$walletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly account_status: FieldRef<"users", 'Boolean'>
    readonly birth_date: FieldRef<"users", 'DateTime'>
    readonly branch_id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly is_email_verified: FieldRef<"users", 'Boolean'>
    readonly is_online: FieldRef<"users", 'Boolean'>
    readonly is_verified: FieldRef<"users", 'Boolean'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly last_seen: FieldRef<"users", 'DateTime'>
    readonly phone: FieldRef<"users", 'String'>
    readonly photo_url: FieldRef<"users", 'String'>
    readonly plan_id: FieldRef<"users", 'String'>
    readonly type_user_id: FieldRef<"users", 'String'>
    readonly shipping_insurance: FieldRef<"users", 'Boolean'>
    readonly is_business: FieldRef<"users", 'Boolean'>
    readonly ruc: FieldRef<"users", 'String'>
    readonly company_name: FieldRef<"users", 'String'>
    readonly referral_source_id: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data?: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.email_campaigns
   */
  export type users$email_campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_campaigns
     */
    select?: email_campaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_campaigns
     */
    omit?: email_campaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: email_campaignsInclude<ExtArgs> | null
    where?: email_campaignsWhereInput
    orderBy?: email_campaignsOrderByWithRelationInput | email_campaignsOrderByWithRelationInput[]
    cursor?: email_campaignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Email_campaignsScalarFieldEnum | Email_campaignsScalarFieldEnum[]
  }

  /**
   * users.invoices
   */
  export type users$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    cursor?: invoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * users.notification_preferences
   */
  export type users$notification_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    where?: notification_preferencesWhereInput
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    cursor?: notification_preferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Notification_preferencesScalarFieldEnum | Notification_preferencesScalarFieldEnum[]
  }

  /**
   * users.notification_users
   */
  export type users$notification_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_users
     */
    select?: notification_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_users
     */
    omit?: notification_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_usersInclude<ExtArgs> | null
    where?: notification_usersWhereInput
    orderBy?: notification_usersOrderByWithRelationInput | notification_usersOrderByWithRelationInput[]
    cursor?: notification_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Notification_usersScalarFieldEnum | Notification_usersScalarFieldEnum[]
  }

  /**
   * users.packages
   */
  export type users$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    where?: packagesWhereInput
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    cursor?: packagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * users.saved_cards
   */
  export type users$saved_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    where?: saved_cardsWhereInput
    orderBy?: saved_cardsOrderByWithRelationInput | saved_cardsOrderByWithRelationInput[]
    cursor?: saved_cardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Saved_cardsScalarFieldEnum | Saved_cardsScalarFieldEnum[]
  }

  /**
   * users.branches
   */
  export type users$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * users.plans
   */
  export type users$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plans
     */
    select?: plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plans
     */
    omit?: plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plansInclude<ExtArgs> | null
    where?: plansWhereInput
  }

  /**
   * users.referral_sources
   */
  export type users$referral_sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    where?: referral_sourcesWhereInput
  }

  /**
   * users.type_users
   */
  export type users$type_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_users
     */
    select?: type_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_users
     */
    omit?: type_usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: type_usersInclude<ExtArgs> | null
    where?: type_usersWhereInput
  }

  /**
   * users.wallets
   */
  export type users$walletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    where?: walletsWhereInput
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    cursor?: walletsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model vehicles
   */

  export type AggregateVehicles = {
    _count: VehiclesCountAggregateOutputType | null
    _avg: VehiclesAvgAggregateOutputType | null
    _sum: VehiclesSumAggregateOutputType | null
    _min: VehiclesMinAggregateOutputType | null
    _max: VehiclesMaxAggregateOutputType | null
  }

  export type VehiclesAvgAggregateOutputType = {
    year: number | null
    mileage: number | null
  }

  export type VehiclesSumAggregateOutputType = {
    year: number | null
    mileage: number | null
  }

  export type VehiclesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    make: string | null
    model: string | null
    year: number | null
    license_plate: string | null
    status: string | null
    branch_id: string | null
    color: string | null
    vin: string | null
    purchase_date: Date | null
    last_maintenance_date: Date | null
    mileage: number | null
    fuel_type: string | null
  }

  export type VehiclesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    make: string | null
    model: string | null
    year: number | null
    license_plate: string | null
    status: string | null
    branch_id: string | null
    color: string | null
    vin: string | null
    purchase_date: Date | null
    last_maintenance_date: Date | null
    mileage: number | null
    fuel_type: string | null
  }

  export type VehiclesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    make: number
    model: number
    year: number
    license_plate: number
    status: number
    branch_id: number
    color: number
    vin: number
    purchase_date: number
    last_maintenance_date: number
    mileage: number
    fuel_type: number
    insurance_info: number
    technical_specs: number
    _all: number
  }


  export type VehiclesAvgAggregateInputType = {
    year?: true
    mileage?: true
  }

  export type VehiclesSumAggregateInputType = {
    year?: true
    mileage?: true
  }

  export type VehiclesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    make?: true
    model?: true
    year?: true
    license_plate?: true
    status?: true
    branch_id?: true
    color?: true
    vin?: true
    purchase_date?: true
    last_maintenance_date?: true
    mileage?: true
    fuel_type?: true
  }

  export type VehiclesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    make?: true
    model?: true
    year?: true
    license_plate?: true
    status?: true
    branch_id?: true
    color?: true
    vin?: true
    purchase_date?: true
    last_maintenance_date?: true
    mileage?: true
    fuel_type?: true
  }

  export type VehiclesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    make?: true
    model?: true
    year?: true
    license_plate?: true
    status?: true
    branch_id?: true
    color?: true
    vin?: true
    purchase_date?: true
    last_maintenance_date?: true
    mileage?: true
    fuel_type?: true
    insurance_info?: true
    technical_specs?: true
    _all?: true
  }

  export type VehiclesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to aggregate.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicles
    **/
    _count?: true | VehiclesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehiclesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehiclesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehiclesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehiclesMaxAggregateInputType
  }

  export type GetVehiclesAggregateType<T extends VehiclesAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicles[P]>
      : GetScalarType<T[P], AggregateVehicles[P]>
  }




  export type vehiclesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehiclesWhereInput
    orderBy?: vehiclesOrderByWithAggregationInput | vehiclesOrderByWithAggregationInput[]
    by: VehiclesScalarFieldEnum[] | VehiclesScalarFieldEnum
    having?: vehiclesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehiclesCountAggregateInputType | true
    _avg?: VehiclesAvgAggregateInputType
    _sum?: VehiclesSumAggregateInputType
    _min?: VehiclesMinAggregateInputType
    _max?: VehiclesMaxAggregateInputType
  }

  export type VehiclesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    make: string
    model: string
    year: number | null
    license_plate: string
    status: string
    branch_id: string | null
    color: string | null
    vin: string | null
    purchase_date: Date | null
    last_maintenance_date: Date | null
    mileage: number | null
    fuel_type: string | null
    insurance_info: JsonValue | null
    technical_specs: JsonValue | null
    _count: VehiclesCountAggregateOutputType | null
    _avg: VehiclesAvgAggregateOutputType | null
    _sum: VehiclesSumAggregateOutputType | null
    _min: VehiclesMinAggregateOutputType | null
    _max: VehiclesMaxAggregateOutputType | null
  }

  type GetVehiclesGroupByPayload<T extends vehiclesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehiclesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehiclesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehiclesGroupByOutputType[P]>
            : GetScalarType<T[P], VehiclesGroupByOutputType[P]>
        }
      >
    >


  export type vehiclesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    license_plate?: boolean
    status?: boolean
    branch_id?: boolean
    color?: boolean
    vin?: boolean
    purchase_date?: boolean
    last_maintenance_date?: boolean
    mileage?: boolean
    fuel_type?: boolean
    insurance_info?: boolean
    technical_specs?: boolean
    branches?: boolean | vehicles$branchesArgs<ExtArgs>
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    license_plate?: boolean
    status?: boolean
    branch_id?: boolean
    color?: boolean
    vin?: boolean
    purchase_date?: boolean
    last_maintenance_date?: boolean
    mileage?: boolean
    fuel_type?: boolean
    insurance_info?: boolean
    technical_specs?: boolean
    branches?: boolean | vehicles$branchesArgs<ExtArgs>
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    license_plate?: boolean
    status?: boolean
    branch_id?: boolean
    color?: boolean
    vin?: boolean
    purchase_date?: boolean
    last_maintenance_date?: boolean
    mileage?: boolean
    fuel_type?: boolean
    insurance_info?: boolean
    technical_specs?: boolean
    branches?: boolean | vehicles$branchesArgs<ExtArgs>
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    license_plate?: boolean
    status?: boolean
    branch_id?: boolean
    color?: boolean
    vin?: boolean
    purchase_date?: boolean
    last_maintenance_date?: boolean
    mileage?: boolean
    fuel_type?: boolean
    insurance_info?: boolean
    technical_specs?: boolean
  }

  export type vehiclesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "make" | "model" | "year" | "license_plate" | "status" | "branch_id" | "color" | "vin" | "purchase_date" | "last_maintenance_date" | "mileage" | "fuel_type" | "insurance_info" | "technical_specs", ExtArgs["result"]["vehicles"]>
  export type vehiclesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | vehicles$branchesArgs<ExtArgs>
  }
  export type vehiclesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | vehicles$branchesArgs<ExtArgs>
  }
  export type vehiclesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | vehicles$branchesArgs<ExtArgs>
  }

  export type $vehiclesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicles"
    objects: {
      branches: Prisma.$branchesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      make: string
      model: string
      year: number | null
      license_plate: string
      status: string
      branch_id: string | null
      color: string | null
      vin: string | null
      purchase_date: Date | null
      last_maintenance_date: Date | null
      mileage: number | null
      fuel_type: string | null
      insurance_info: Prisma.JsonValue | null
      technical_specs: Prisma.JsonValue | null
    }, ExtArgs["result"]["vehicles"]>
    composites: {}
  }

  type vehiclesGetPayload<S extends boolean | null | undefined | vehiclesDefaultArgs> = $Result.GetResult<Prisma.$vehiclesPayload, S>

  type vehiclesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehiclesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehiclesCountAggregateInputType | true
    }

  export interface vehiclesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicles'], meta: { name: 'vehicles' } }
    /**
     * Find zero or one Vehicles that matches the filter.
     * @param {vehiclesFindUniqueArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehiclesFindUniqueArgs>(args: SelectSubset<T, vehiclesFindUniqueArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehiclesFindUniqueOrThrowArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehiclesFindUniqueOrThrowArgs>(args: SelectSubset<T, vehiclesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindFirstArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehiclesFindFirstArgs>(args?: SelectSubset<T, vehiclesFindFirstArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindFirstOrThrowArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehiclesFindFirstOrThrowArgs>(args?: SelectSubset<T, vehiclesFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicles.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehiclesFindManyArgs>(args?: SelectSubset<T, vehiclesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicles.
     * @param {vehiclesCreateArgs} args - Arguments to create a Vehicles.
     * @example
     * // Create one Vehicles
     * const Vehicles = await prisma.vehicles.create({
     *   data: {
     *     // ... data to create a Vehicles
     *   }
     * })
     * 
     */
    create<T extends vehiclesCreateArgs>(args: SelectSubset<T, vehiclesCreateArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {vehiclesCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicles = await prisma.vehicles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehiclesCreateManyArgs>(args?: SelectSubset<T, vehiclesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {vehiclesCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicles = await prisma.vehicles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehiclesCreateManyAndReturnArgs>(args?: SelectSubset<T, vehiclesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicles.
     * @param {vehiclesDeleteArgs} args - Arguments to delete one Vehicles.
     * @example
     * // Delete one Vehicles
     * const Vehicles = await prisma.vehicles.delete({
     *   where: {
     *     // ... filter to delete one Vehicles
     *   }
     * })
     * 
     */
    delete<T extends vehiclesDeleteArgs>(args: SelectSubset<T, vehiclesDeleteArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicles.
     * @param {vehiclesUpdateArgs} args - Arguments to update one Vehicles.
     * @example
     * // Update one Vehicles
     * const vehicles = await prisma.vehicles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehiclesUpdateArgs>(args: SelectSubset<T, vehiclesUpdateArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {vehiclesDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehiclesDeleteManyArgs>(args?: SelectSubset<T, vehiclesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicles = await prisma.vehicles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehiclesUpdateManyArgs>(args: SelectSubset<T, vehiclesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {vehiclesUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicles = await prisma.vehicles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends vehiclesUpdateManyAndReturnArgs>(args: SelectSubset<T, vehiclesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicles.
     * @param {vehiclesUpsertArgs} args - Arguments to update or create a Vehicles.
     * @example
     * // Update or create a Vehicles
     * const vehicles = await prisma.vehicles.upsert({
     *   create: {
     *     // ... data to create a Vehicles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicles we want to update
     *   }
     * })
     */
    upsert<T extends vehiclesUpsertArgs>(args: SelectSubset<T, vehiclesUpsertArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicles.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends vehiclesCountArgs>(
      args?: Subset<T, vehiclesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehiclesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehiclesAggregateArgs>(args: Subset<T, VehiclesAggregateArgs>): Prisma.PrismaPromise<GetVehiclesAggregateType<T>>

    /**
     * Group by Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehiclesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehiclesGroupByArgs['orderBy'] }
        : { orderBy?: vehiclesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehiclesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehiclesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicles model
   */
  readonly fields: vehiclesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehiclesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends vehicles$branchesArgs<ExtArgs> = {}>(args?: Subset<T, vehicles$branchesArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicles model
   */ 
  interface vehiclesFieldRefs {
    readonly id: FieldRef<"vehicles", 'String'>
    readonly created_at: FieldRef<"vehicles", 'DateTime'>
    readonly updated_at: FieldRef<"vehicles", 'DateTime'>
    readonly make: FieldRef<"vehicles", 'String'>
    readonly model: FieldRef<"vehicles", 'String'>
    readonly year: FieldRef<"vehicles", 'Int'>
    readonly license_plate: FieldRef<"vehicles", 'String'>
    readonly status: FieldRef<"vehicles", 'String'>
    readonly branch_id: FieldRef<"vehicles", 'String'>
    readonly color: FieldRef<"vehicles", 'String'>
    readonly vin: FieldRef<"vehicles", 'String'>
    readonly purchase_date: FieldRef<"vehicles", 'DateTime'>
    readonly last_maintenance_date: FieldRef<"vehicles", 'DateTime'>
    readonly mileage: FieldRef<"vehicles", 'Int'>
    readonly fuel_type: FieldRef<"vehicles", 'String'>
    readonly insurance_info: FieldRef<"vehicles", 'Json'>
    readonly technical_specs: FieldRef<"vehicles", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * vehicles findUnique
   */
  export type vehiclesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles findUniqueOrThrow
   */
  export type vehiclesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles findFirst
   */
  export type vehiclesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles findFirstOrThrow
   */
  export type vehiclesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles findMany
   */
  export type vehiclesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles create
   */
  export type vehiclesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicles.
     */
    data: XOR<vehiclesCreateInput, vehiclesUncheckedCreateInput>
  }

  /**
   * vehicles createMany
   */
  export type vehiclesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicles.
     */
    data: vehiclesCreateManyInput | vehiclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicles createManyAndReturn
   */
  export type vehiclesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The data used to create many vehicles.
     */
    data: vehiclesCreateManyInput | vehiclesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * vehicles update
   */
  export type vehiclesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicles.
     */
    data: XOR<vehiclesUpdateInput, vehiclesUncheckedUpdateInput>
    /**
     * Choose, which vehicles to update.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles updateMany
   */
  export type vehiclesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicles.
     */
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which vehicles to update
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to update.
     */
    limit?: number
  }

  /**
   * vehicles updateManyAndReturn
   */
  export type vehiclesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The data used to update vehicles.
     */
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which vehicles to update
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * vehicles upsert
   */
  export type vehiclesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicles to update in case it exists.
     */
    where: vehiclesWhereUniqueInput
    /**
     * In case the vehicles found by the `where` argument doesn't exist, create a new vehicles with this data.
     */
    create: XOR<vehiclesCreateInput, vehiclesUncheckedCreateInput>
    /**
     * In case the vehicles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehiclesUpdateInput, vehiclesUncheckedUpdateInput>
  }

  /**
   * vehicles delete
   */
  export type vehiclesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter which vehicles to delete.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles deleteMany
   */
  export type vehiclesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to delete
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to delete.
     */
    limit?: number
  }

  /**
   * vehicles.branches
   */
  export type vehicles$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * vehicles without action
   */
  export type vehiclesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
  }


  /**
   * Model wallets
   */

  export type AggregateWallets = {
    _count: WalletsCountAggregateOutputType | null
    _avg: WalletsAvgAggregateOutputType | null
    _sum: WalletsSumAggregateOutputType | null
    _min: WalletsMinAggregateOutputType | null
    _max: WalletsMaxAggregateOutputType | null
  }

  export type WalletsAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type WalletsSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type WalletsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    balance: Decimal | null
    currency: string | null
    is_active: boolean | null
    last_transaction_date: Date | null
    user_id: string | null
  }

  export type WalletsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    balance: Decimal | null
    currency: string | null
    is_active: boolean | null
    last_transaction_date: Date | null
    user_id: string | null
  }

  export type WalletsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    balance: number
    currency: number
    is_active: number
    last_transaction_date: number
    user_id: number
    _all: number
  }


  export type WalletsAvgAggregateInputType = {
    balance?: true
  }

  export type WalletsSumAggregateInputType = {
    balance?: true
  }

  export type WalletsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    balance?: true
    currency?: true
    is_active?: true
    last_transaction_date?: true
    user_id?: true
  }

  export type WalletsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    balance?: true
    currency?: true
    is_active?: true
    last_transaction_date?: true
    user_id?: true
  }

  export type WalletsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    balance?: true
    currency?: true
    is_active?: true
    last_transaction_date?: true
    user_id?: true
    _all?: true
  }

  export type WalletsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to aggregate.
     */
    where?: walletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallets
    **/
    _count?: true | WalletsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletsMaxAggregateInputType
  }

  export type GetWalletsAggregateType<T extends WalletsAggregateArgs> = {
        [P in keyof T & keyof AggregateWallets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallets[P]>
      : GetScalarType<T[P], AggregateWallets[P]>
  }




  export type walletsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletsWhereInput
    orderBy?: walletsOrderByWithAggregationInput | walletsOrderByWithAggregationInput[]
    by: WalletsScalarFieldEnum[] | WalletsScalarFieldEnum
    having?: walletsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletsCountAggregateInputType | true
    _avg?: WalletsAvgAggregateInputType
    _sum?: WalletsSumAggregateInputType
    _min?: WalletsMinAggregateInputType
    _max?: WalletsMaxAggregateInputType
  }

  export type WalletsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date | null
    balance: Decimal | null
    currency: string | null
    is_active: boolean | null
    last_transaction_date: Date | null
    user_id: string | null
    _count: WalletsCountAggregateOutputType | null
    _avg: WalletsAvgAggregateOutputType | null
    _sum: WalletsSumAggregateOutputType | null
    _min: WalletsMinAggregateOutputType | null
    _max: WalletsMaxAggregateOutputType | null
  }

  type GetWalletsGroupByPayload<T extends walletsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletsGroupByOutputType[P]>
            : GetScalarType<T[P], WalletsGroupByOutputType[P]>
        }
      >
    >


  export type walletsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    balance?: boolean
    currency?: boolean
    is_active?: boolean
    last_transaction_date?: boolean
    user_id?: boolean
    users?: boolean | wallets$usersArgs<ExtArgs>
  }, ExtArgs["result"]["wallets"]>

  export type walletsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    balance?: boolean
    currency?: boolean
    is_active?: boolean
    last_transaction_date?: boolean
    user_id?: boolean
    users?: boolean | wallets$usersArgs<ExtArgs>
  }, ExtArgs["result"]["wallets"]>

  export type walletsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    balance?: boolean
    currency?: boolean
    is_active?: boolean
    last_transaction_date?: boolean
    user_id?: boolean
    users?: boolean | wallets$usersArgs<ExtArgs>
  }, ExtArgs["result"]["wallets"]>

  export type walletsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    balance?: boolean
    currency?: boolean
    is_active?: boolean
    last_transaction_date?: boolean
    user_id?: boolean
  }

  export type walletsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "balance" | "currency" | "is_active" | "last_transaction_date" | "user_id", ExtArgs["result"]["wallets"]>
  export type walletsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | wallets$usersArgs<ExtArgs>
  }
  export type walletsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | wallets$usersArgs<ExtArgs>
  }
  export type walletsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | wallets$usersArgs<ExtArgs>
  }

  export type $walletsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallets"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date | null
      balance: Prisma.Decimal | null
      currency: string | null
      is_active: boolean | null
      last_transaction_date: Date | null
      user_id: string | null
    }, ExtArgs["result"]["wallets"]>
    composites: {}
  }

  type walletsGetPayload<S extends boolean | null | undefined | walletsDefaultArgs> = $Result.GetResult<Prisma.$walletsPayload, S>

  type walletsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<walletsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletsCountAggregateInputType | true
    }

  export interface walletsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallets'], meta: { name: 'wallets' } }
    /**
     * Find zero or one Wallets that matches the filter.
     * @param {walletsFindUniqueArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends walletsFindUniqueArgs>(args: SelectSubset<T, walletsFindUniqueArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {walletsFindUniqueOrThrowArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends walletsFindUniqueOrThrowArgs>(args: SelectSubset<T, walletsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsFindFirstArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends walletsFindFirstArgs>(args?: SelectSubset<T, walletsFindFirstArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsFindFirstOrThrowArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends walletsFindFirstOrThrowArgs>(args?: SelectSubset<T, walletsFindFirstOrThrowArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallets.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletsWithIdOnly = await prisma.wallets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends walletsFindManyArgs>(args?: SelectSubset<T, walletsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallets.
     * @param {walletsCreateArgs} args - Arguments to create a Wallets.
     * @example
     * // Create one Wallets
     * const Wallets = await prisma.wallets.create({
     *   data: {
     *     // ... data to create a Wallets
     *   }
     * })
     * 
     */
    create<T extends walletsCreateArgs>(args: SelectSubset<T, walletsCreateArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {walletsCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallets = await prisma.wallets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends walletsCreateManyArgs>(args?: SelectSubset<T, walletsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {walletsCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallets = await prisma.wallets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletsWithIdOnly = await prisma.wallets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends walletsCreateManyAndReturnArgs>(args?: SelectSubset<T, walletsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallets.
     * @param {walletsDeleteArgs} args - Arguments to delete one Wallets.
     * @example
     * // Delete one Wallets
     * const Wallets = await prisma.wallets.delete({
     *   where: {
     *     // ... filter to delete one Wallets
     *   }
     * })
     * 
     */
    delete<T extends walletsDeleteArgs>(args: SelectSubset<T, walletsDeleteArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallets.
     * @param {walletsUpdateArgs} args - Arguments to update one Wallets.
     * @example
     * // Update one Wallets
     * const wallets = await prisma.wallets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends walletsUpdateArgs>(args: SelectSubset<T, walletsUpdateArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {walletsDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends walletsDeleteManyArgs>(args?: SelectSubset<T, walletsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallets = await prisma.wallets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends walletsUpdateManyArgs>(args: SelectSubset<T, walletsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {walletsUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallets = await prisma.wallets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletsWithIdOnly = await prisma.wallets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends walletsUpdateManyAndReturnArgs>(args: SelectSubset<T, walletsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallets.
     * @param {walletsUpsertArgs} args - Arguments to update or create a Wallets.
     * @example
     * // Update or create a Wallets
     * const wallets = await prisma.wallets.upsert({
     *   create: {
     *     // ... data to create a Wallets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallets we want to update
     *   }
     * })
     */
    upsert<T extends walletsUpsertArgs>(args: SelectSubset<T, walletsUpsertArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallets.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends walletsCountArgs>(
      args?: Subset<T, walletsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletsAggregateArgs>(args: Subset<T, WalletsAggregateArgs>): Prisma.PrismaPromise<GetWalletsAggregateType<T>>

    /**
     * Group by Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletsGroupByArgs['orderBy'] }
        : { orderBy?: walletsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallets model
   */
  readonly fields: walletsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__walletsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends wallets$usersArgs<ExtArgs> = {}>(args?: Subset<T, wallets$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallets model
   */ 
  interface walletsFieldRefs {
    readonly id: FieldRef<"wallets", 'String'>
    readonly created_at: FieldRef<"wallets", 'DateTime'>
    readonly updated_at: FieldRef<"wallets", 'DateTime'>
    readonly balance: FieldRef<"wallets", 'Decimal'>
    readonly currency: FieldRef<"wallets", 'String'>
    readonly is_active: FieldRef<"wallets", 'Boolean'>
    readonly last_transaction_date: FieldRef<"wallets", 'DateTime'>
    readonly user_id: FieldRef<"wallets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * wallets findUnique
   */
  export type walletsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where: walletsWhereUniqueInput
  }

  /**
   * wallets findUniqueOrThrow
   */
  export type walletsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where: walletsWhereUniqueInput
  }

  /**
   * wallets findFirst
   */
  export type walletsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * wallets findFirstOrThrow
   */
  export type walletsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * wallets findMany
   */
  export type walletsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallets.
     */
    cursor?: walletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * wallets create
   */
  export type walletsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * The data needed to create a wallets.
     */
    data?: XOR<walletsCreateInput, walletsUncheckedCreateInput>
  }

  /**
   * wallets createMany
   */
  export type walletsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallets.
     */
    data: walletsCreateManyInput | walletsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallets createManyAndReturn
   */
  export type walletsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * The data used to create many wallets.
     */
    data: walletsCreateManyInput | walletsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * wallets update
   */
  export type walletsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * The data needed to update a wallets.
     */
    data: XOR<walletsUpdateInput, walletsUncheckedUpdateInput>
    /**
     * Choose, which wallets to update.
     */
    where: walletsWhereUniqueInput
  }

  /**
   * wallets updateMany
   */
  export type walletsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallets.
     */
    data: XOR<walletsUpdateManyMutationInput, walletsUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletsWhereInput
    /**
     * Limit how many wallets to update.
     */
    limit?: number
  }

  /**
   * wallets updateManyAndReturn
   */
  export type walletsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * The data used to update wallets.
     */
    data: XOR<walletsUpdateManyMutationInput, walletsUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletsWhereInput
    /**
     * Limit how many wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * wallets upsert
   */
  export type walletsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * The filter to search for the wallets to update in case it exists.
     */
    where: walletsWhereUniqueInput
    /**
     * In case the wallets found by the `where` argument doesn't exist, create a new wallets with this data.
     */
    create: XOR<walletsCreateInput, walletsUncheckedCreateInput>
    /**
     * In case the wallets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletsUpdateInput, walletsUncheckedUpdateInput>
  }

  /**
   * wallets delete
   */
  export type walletsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter which wallets to delete.
     */
    where: walletsWhereUniqueInput
  }

  /**
   * wallets deleteMany
   */
  export type walletsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to delete
     */
    where?: walletsWhereInput
    /**
     * Limit how many wallets to delete.
     */
    limit?: number
  }

  /**
   * wallets.users
   */
  export type wallets$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * wallets without action
   */
  export type walletsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
  }


  /**
   * Model saved_cards
   */

  export type AggregateSaved_cards = {
    _count: Saved_cardsCountAggregateOutputType | null
    _avg: Saved_cardsAvgAggregateOutputType | null
    _sum: Saved_cardsSumAggregateOutputType | null
    _min: Saved_cardsMinAggregateOutputType | null
    _max: Saved_cardsMaxAggregateOutputType | null
  }

  export type Saved_cardsAvgAggregateOutputType = {
    id: number | null
    expiry_month: number | null
    expiry_year: number | null
  }

  export type Saved_cardsSumAggregateOutputType = {
    id: number | null
    expiry_month: number | null
    expiry_year: number | null
  }

  export type Saved_cardsMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    card_token: string | null
    card_type: string | null
    cardholder_name: string | null
    expiry_month: number | null
    expiry_year: number | null
    brand: string | null
    last_four_digits: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    nick_name: string | null
  }

  export type Saved_cardsMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    card_token: string | null
    card_type: string | null
    cardholder_name: string | null
    expiry_month: number | null
    expiry_year: number | null
    brand: string | null
    last_four_digits: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    nick_name: string | null
  }

  export type Saved_cardsCountAggregateOutputType = {
    id: number
    user_id: number
    card_token: number
    card_type: number
    cardholder_name: number
    expiry_month: number
    expiry_year: number
    brand: number
    last_four_digits: number
    is_default: number
    created_at: number
    updated_at: number
    nick_name: number
    _all: number
  }


  export type Saved_cardsAvgAggregateInputType = {
    id?: true
    expiry_month?: true
    expiry_year?: true
  }

  export type Saved_cardsSumAggregateInputType = {
    id?: true
    expiry_month?: true
    expiry_year?: true
  }

  export type Saved_cardsMinAggregateInputType = {
    id?: true
    user_id?: true
    card_token?: true
    card_type?: true
    cardholder_name?: true
    expiry_month?: true
    expiry_year?: true
    brand?: true
    last_four_digits?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    nick_name?: true
  }

  export type Saved_cardsMaxAggregateInputType = {
    id?: true
    user_id?: true
    card_token?: true
    card_type?: true
    cardholder_name?: true
    expiry_month?: true
    expiry_year?: true
    brand?: true
    last_four_digits?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    nick_name?: true
  }

  export type Saved_cardsCountAggregateInputType = {
    id?: true
    user_id?: true
    card_token?: true
    card_type?: true
    cardholder_name?: true
    expiry_month?: true
    expiry_year?: true
    brand?: true
    last_four_digits?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    nick_name?: true
    _all?: true
  }

  export type Saved_cardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saved_cards to aggregate.
     */
    where?: saved_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saved_cards to fetch.
     */
    orderBy?: saved_cardsOrderByWithRelationInput | saved_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saved_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saved_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saved_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saved_cards
    **/
    _count?: true | Saved_cardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Saved_cardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Saved_cardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Saved_cardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Saved_cardsMaxAggregateInputType
  }

  export type GetSaved_cardsAggregateType<T extends Saved_cardsAggregateArgs> = {
        [P in keyof T & keyof AggregateSaved_cards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaved_cards[P]>
      : GetScalarType<T[P], AggregateSaved_cards[P]>
  }




  export type saved_cardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saved_cardsWhereInput
    orderBy?: saved_cardsOrderByWithAggregationInput | saved_cardsOrderByWithAggregationInput[]
    by: Saved_cardsScalarFieldEnum[] | Saved_cardsScalarFieldEnum
    having?: saved_cardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Saved_cardsCountAggregateInputType | true
    _avg?: Saved_cardsAvgAggregateInputType
    _sum?: Saved_cardsSumAggregateInputType
    _min?: Saved_cardsMinAggregateInputType
    _max?: Saved_cardsMaxAggregateInputType
  }

  export type Saved_cardsGroupByOutputType = {
    id: number
    user_id: string
    card_token: string
    card_type: string | null
    cardholder_name: string | null
    expiry_month: number
    expiry_year: number
    brand: string | null
    last_four_digits: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    nick_name: string | null
    _count: Saved_cardsCountAggregateOutputType | null
    _avg: Saved_cardsAvgAggregateOutputType | null
    _sum: Saved_cardsSumAggregateOutputType | null
    _min: Saved_cardsMinAggregateOutputType | null
    _max: Saved_cardsMaxAggregateOutputType | null
  }

  type GetSaved_cardsGroupByPayload<T extends saved_cardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Saved_cardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Saved_cardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Saved_cardsGroupByOutputType[P]>
            : GetScalarType<T[P], Saved_cardsGroupByOutputType[P]>
        }
      >
    >


  export type saved_cardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    card_token?: boolean
    card_type?: boolean
    cardholder_name?: boolean
    expiry_month?: boolean
    expiry_year?: boolean
    brand?: boolean
    last_four_digits?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    nick_name?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saved_cards"]>

  export type saved_cardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    card_token?: boolean
    card_type?: boolean
    cardholder_name?: boolean
    expiry_month?: boolean
    expiry_year?: boolean
    brand?: boolean
    last_four_digits?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    nick_name?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saved_cards"]>

  export type saved_cardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    card_token?: boolean
    card_type?: boolean
    cardholder_name?: boolean
    expiry_month?: boolean
    expiry_year?: boolean
    brand?: boolean
    last_four_digits?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    nick_name?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saved_cards"]>

  export type saved_cardsSelectScalar = {
    id?: boolean
    user_id?: boolean
    card_token?: boolean
    card_type?: boolean
    cardholder_name?: boolean
    expiry_month?: boolean
    expiry_year?: boolean
    brand?: boolean
    last_four_digits?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    nick_name?: boolean
  }

  export type saved_cardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "card_token" | "card_type" | "cardholder_name" | "expiry_month" | "expiry_year" | "brand" | "last_four_digits" | "is_default" | "created_at" | "updated_at" | "nick_name", ExtArgs["result"]["saved_cards"]>
  export type saved_cardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type saved_cardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type saved_cardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $saved_cardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saved_cards"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      card_token: string
      card_type: string | null
      cardholder_name: string | null
      expiry_month: number
      expiry_year: number
      brand: string | null
      last_four_digits: string | null
      is_default: boolean | null
      created_at: Date | null
      updated_at: Date | null
      nick_name: string | null
    }, ExtArgs["result"]["saved_cards"]>
    composites: {}
  }

  type saved_cardsGetPayload<S extends boolean | null | undefined | saved_cardsDefaultArgs> = $Result.GetResult<Prisma.$saved_cardsPayload, S>

  type saved_cardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saved_cardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Saved_cardsCountAggregateInputType | true
    }

  export interface saved_cardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saved_cards'], meta: { name: 'saved_cards' } }
    /**
     * Find zero or one Saved_cards that matches the filter.
     * @param {saved_cardsFindUniqueArgs} args - Arguments to find a Saved_cards
     * @example
     * // Get one Saved_cards
     * const saved_cards = await prisma.saved_cards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saved_cardsFindUniqueArgs>(args: SelectSubset<T, saved_cardsFindUniqueArgs<ExtArgs>>): Prisma__saved_cardsClient<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Saved_cards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saved_cardsFindUniqueOrThrowArgs} args - Arguments to find a Saved_cards
     * @example
     * // Get one Saved_cards
     * const saved_cards = await prisma.saved_cards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saved_cardsFindUniqueOrThrowArgs>(args: SelectSubset<T, saved_cardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saved_cardsClient<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saved_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_cardsFindFirstArgs} args - Arguments to find a Saved_cards
     * @example
     * // Get one Saved_cards
     * const saved_cards = await prisma.saved_cards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saved_cardsFindFirstArgs>(args?: SelectSubset<T, saved_cardsFindFirstArgs<ExtArgs>>): Prisma__saved_cardsClient<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saved_cards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_cardsFindFirstOrThrowArgs} args - Arguments to find a Saved_cards
     * @example
     * // Get one Saved_cards
     * const saved_cards = await prisma.saved_cards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saved_cardsFindFirstOrThrowArgs>(args?: SelectSubset<T, saved_cardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__saved_cardsClient<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Saved_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_cardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saved_cards
     * const saved_cards = await prisma.saved_cards.findMany()
     * 
     * // Get first 10 Saved_cards
     * const saved_cards = await prisma.saved_cards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saved_cardsWithIdOnly = await prisma.saved_cards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saved_cardsFindManyArgs>(args?: SelectSubset<T, saved_cardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Saved_cards.
     * @param {saved_cardsCreateArgs} args - Arguments to create a Saved_cards.
     * @example
     * // Create one Saved_cards
     * const Saved_cards = await prisma.saved_cards.create({
     *   data: {
     *     // ... data to create a Saved_cards
     *   }
     * })
     * 
     */
    create<T extends saved_cardsCreateArgs>(args: SelectSubset<T, saved_cardsCreateArgs<ExtArgs>>): Prisma__saved_cardsClient<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Saved_cards.
     * @param {saved_cardsCreateManyArgs} args - Arguments to create many Saved_cards.
     * @example
     * // Create many Saved_cards
     * const saved_cards = await prisma.saved_cards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saved_cardsCreateManyArgs>(args?: SelectSubset<T, saved_cardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Saved_cards and returns the data saved in the database.
     * @param {saved_cardsCreateManyAndReturnArgs} args - Arguments to create many Saved_cards.
     * @example
     * // Create many Saved_cards
     * const saved_cards = await prisma.saved_cards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Saved_cards and only return the `id`
     * const saved_cardsWithIdOnly = await prisma.saved_cards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saved_cardsCreateManyAndReturnArgs>(args?: SelectSubset<T, saved_cardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Saved_cards.
     * @param {saved_cardsDeleteArgs} args - Arguments to delete one Saved_cards.
     * @example
     * // Delete one Saved_cards
     * const Saved_cards = await prisma.saved_cards.delete({
     *   where: {
     *     // ... filter to delete one Saved_cards
     *   }
     * })
     * 
     */
    delete<T extends saved_cardsDeleteArgs>(args: SelectSubset<T, saved_cardsDeleteArgs<ExtArgs>>): Prisma__saved_cardsClient<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Saved_cards.
     * @param {saved_cardsUpdateArgs} args - Arguments to update one Saved_cards.
     * @example
     * // Update one Saved_cards
     * const saved_cards = await prisma.saved_cards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saved_cardsUpdateArgs>(args: SelectSubset<T, saved_cardsUpdateArgs<ExtArgs>>): Prisma__saved_cardsClient<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Saved_cards.
     * @param {saved_cardsDeleteManyArgs} args - Arguments to filter Saved_cards to delete.
     * @example
     * // Delete a few Saved_cards
     * const { count } = await prisma.saved_cards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saved_cardsDeleteManyArgs>(args?: SelectSubset<T, saved_cardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saved_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_cardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saved_cards
     * const saved_cards = await prisma.saved_cards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saved_cardsUpdateManyArgs>(args: SelectSubset<T, saved_cardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saved_cards and returns the data updated in the database.
     * @param {saved_cardsUpdateManyAndReturnArgs} args - Arguments to update many Saved_cards.
     * @example
     * // Update many Saved_cards
     * const saved_cards = await prisma.saved_cards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Saved_cards and only return the `id`
     * const saved_cardsWithIdOnly = await prisma.saved_cards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saved_cardsUpdateManyAndReturnArgs>(args: SelectSubset<T, saved_cardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Saved_cards.
     * @param {saved_cardsUpsertArgs} args - Arguments to update or create a Saved_cards.
     * @example
     * // Update or create a Saved_cards
     * const saved_cards = await prisma.saved_cards.upsert({
     *   create: {
     *     // ... data to create a Saved_cards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saved_cards we want to update
     *   }
     * })
     */
    upsert<T extends saved_cardsUpsertArgs>(args: SelectSubset<T, saved_cardsUpsertArgs<ExtArgs>>): Prisma__saved_cardsClient<$Result.GetResult<Prisma.$saved_cardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Saved_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_cardsCountArgs} args - Arguments to filter Saved_cards to count.
     * @example
     * // Count the number of Saved_cards
     * const count = await prisma.saved_cards.count({
     *   where: {
     *     // ... the filter for the Saved_cards we want to count
     *   }
     * })
    **/
    count<T extends saved_cardsCountArgs>(
      args?: Subset<T, saved_cardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Saved_cardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saved_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Saved_cardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Saved_cardsAggregateArgs>(args: Subset<T, Saved_cardsAggregateArgs>): Prisma.PrismaPromise<GetSaved_cardsAggregateType<T>>

    /**
     * Group by Saved_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saved_cardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saved_cardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saved_cardsGroupByArgs['orderBy'] }
        : { orderBy?: saved_cardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saved_cardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaved_cardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saved_cards model
   */
  readonly fields: saved_cardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saved_cards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saved_cardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saved_cards model
   */ 
  interface saved_cardsFieldRefs {
    readonly id: FieldRef<"saved_cards", 'Int'>
    readonly user_id: FieldRef<"saved_cards", 'String'>
    readonly card_token: FieldRef<"saved_cards", 'String'>
    readonly card_type: FieldRef<"saved_cards", 'String'>
    readonly cardholder_name: FieldRef<"saved_cards", 'String'>
    readonly expiry_month: FieldRef<"saved_cards", 'Int'>
    readonly expiry_year: FieldRef<"saved_cards", 'Int'>
    readonly brand: FieldRef<"saved_cards", 'String'>
    readonly last_four_digits: FieldRef<"saved_cards", 'String'>
    readonly is_default: FieldRef<"saved_cards", 'Boolean'>
    readonly created_at: FieldRef<"saved_cards", 'DateTime'>
    readonly updated_at: FieldRef<"saved_cards", 'DateTime'>
    readonly nick_name: FieldRef<"saved_cards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * saved_cards findUnique
   */
  export type saved_cardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * Filter, which saved_cards to fetch.
     */
    where: saved_cardsWhereUniqueInput
  }

  /**
   * saved_cards findUniqueOrThrow
   */
  export type saved_cardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * Filter, which saved_cards to fetch.
     */
    where: saved_cardsWhereUniqueInput
  }

  /**
   * saved_cards findFirst
   */
  export type saved_cardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * Filter, which saved_cards to fetch.
     */
    where?: saved_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saved_cards to fetch.
     */
    orderBy?: saved_cardsOrderByWithRelationInput | saved_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saved_cards.
     */
    cursor?: saved_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saved_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saved_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saved_cards.
     */
    distinct?: Saved_cardsScalarFieldEnum | Saved_cardsScalarFieldEnum[]
  }

  /**
   * saved_cards findFirstOrThrow
   */
  export type saved_cardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * Filter, which saved_cards to fetch.
     */
    where?: saved_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saved_cards to fetch.
     */
    orderBy?: saved_cardsOrderByWithRelationInput | saved_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saved_cards.
     */
    cursor?: saved_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saved_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saved_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saved_cards.
     */
    distinct?: Saved_cardsScalarFieldEnum | Saved_cardsScalarFieldEnum[]
  }

  /**
   * saved_cards findMany
   */
  export type saved_cardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * Filter, which saved_cards to fetch.
     */
    where?: saved_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saved_cards to fetch.
     */
    orderBy?: saved_cardsOrderByWithRelationInput | saved_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saved_cards.
     */
    cursor?: saved_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saved_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saved_cards.
     */
    skip?: number
    distinct?: Saved_cardsScalarFieldEnum | Saved_cardsScalarFieldEnum[]
  }

  /**
   * saved_cards create
   */
  export type saved_cardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * The data needed to create a saved_cards.
     */
    data: XOR<saved_cardsCreateInput, saved_cardsUncheckedCreateInput>
  }

  /**
   * saved_cards createMany
   */
  export type saved_cardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saved_cards.
     */
    data: saved_cardsCreateManyInput | saved_cardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saved_cards createManyAndReturn
   */
  export type saved_cardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * The data used to create many saved_cards.
     */
    data: saved_cardsCreateManyInput | saved_cardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * saved_cards update
   */
  export type saved_cardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * The data needed to update a saved_cards.
     */
    data: XOR<saved_cardsUpdateInput, saved_cardsUncheckedUpdateInput>
    /**
     * Choose, which saved_cards to update.
     */
    where: saved_cardsWhereUniqueInput
  }

  /**
   * saved_cards updateMany
   */
  export type saved_cardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saved_cards.
     */
    data: XOR<saved_cardsUpdateManyMutationInput, saved_cardsUncheckedUpdateManyInput>
    /**
     * Filter which saved_cards to update
     */
    where?: saved_cardsWhereInput
    /**
     * Limit how many saved_cards to update.
     */
    limit?: number
  }

  /**
   * saved_cards updateManyAndReturn
   */
  export type saved_cardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * The data used to update saved_cards.
     */
    data: XOR<saved_cardsUpdateManyMutationInput, saved_cardsUncheckedUpdateManyInput>
    /**
     * Filter which saved_cards to update
     */
    where?: saved_cardsWhereInput
    /**
     * Limit how many saved_cards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * saved_cards upsert
   */
  export type saved_cardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * The filter to search for the saved_cards to update in case it exists.
     */
    where: saved_cardsWhereUniqueInput
    /**
     * In case the saved_cards found by the `where` argument doesn't exist, create a new saved_cards with this data.
     */
    create: XOR<saved_cardsCreateInput, saved_cardsUncheckedCreateInput>
    /**
     * In case the saved_cards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saved_cardsUpdateInput, saved_cardsUncheckedUpdateInput>
  }

  /**
   * saved_cards delete
   */
  export type saved_cardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
    /**
     * Filter which saved_cards to delete.
     */
    where: saved_cardsWhereUniqueInput
  }

  /**
   * saved_cards deleteMany
   */
  export type saved_cardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saved_cards to delete
     */
    where?: saved_cardsWhereInput
    /**
     * Limit how many saved_cards to delete.
     */
    limit?: number
  }

  /**
   * saved_cards without action
   */
  export type saved_cardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saved_cards
     */
    select?: saved_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saved_cards
     */
    omit?: saved_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saved_cardsInclude<ExtArgs> | null
  }


  /**
   * Model payment_methods
   */

  export type AggregatePayment_methods = {
    _count: Payment_methodsCountAggregateOutputType | null
    _avg: Payment_methodsAvgAggregateOutputType | null
    _sum: Payment_methodsSumAggregateOutputType | null
    _min: Payment_methodsMinAggregateOutputType | null
    _max: Payment_methodsMaxAggregateOutputType | null
  }

  export type Payment_methodsAvgAggregateOutputType = {
    payment_type_id: number | null
  }

  export type Payment_methodsSumAggregateOutputType = {
    payment_type_id: number | null
  }

  export type Payment_methodsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    is_active: boolean | null
    payment_type_id: number | null
  }

  export type Payment_methodsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    is_active: boolean | null
    payment_type_id: number | null
  }

  export type Payment_methodsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    is_active: number
    details: number
    payment_type_id: number
    _all: number
  }


  export type Payment_methodsAvgAggregateInputType = {
    payment_type_id?: true
  }

  export type Payment_methodsSumAggregateInputType = {
    payment_type_id?: true
  }

  export type Payment_methodsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    is_active?: true
    payment_type_id?: true
  }

  export type Payment_methodsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    is_active?: true
    payment_type_id?: true
  }

  export type Payment_methodsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    is_active?: true
    details?: true
    payment_type_id?: true
    _all?: true
  }

  export type Payment_methodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_methods to aggregate.
     */
    where?: payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_methods
    **/
    _count?: true | Payment_methodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_methodsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_methodsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_methodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_methodsMaxAggregateInputType
  }

  export type GetPayment_methodsAggregateType<T extends Payment_methodsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_methods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_methods[P]>
      : GetScalarType<T[P], AggregatePayment_methods[P]>
  }




  export type payment_methodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_methodsWhereInput
    orderBy?: payment_methodsOrderByWithAggregationInput | payment_methodsOrderByWithAggregationInput[]
    by: Payment_methodsScalarFieldEnum[] | Payment_methodsScalarFieldEnum
    having?: payment_methodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_methodsCountAggregateInputType | true
    _avg?: Payment_methodsAvgAggregateInputType
    _sum?: Payment_methodsSumAggregateInputType
    _min?: Payment_methodsMinAggregateInputType
    _max?: Payment_methodsMaxAggregateInputType
  }

  export type Payment_methodsGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    name: string
    is_active: boolean | null
    details: JsonValue | null
    payment_type_id: number | null
    _count: Payment_methodsCountAggregateOutputType | null
    _avg: Payment_methodsAvgAggregateOutputType | null
    _sum: Payment_methodsSumAggregateOutputType | null
    _min: Payment_methodsMinAggregateOutputType | null
    _max: Payment_methodsMaxAggregateOutputType | null
  }

  type GetPayment_methodsGroupByPayload<T extends payment_methodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_methodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_methodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_methodsGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_methodsGroupByOutputType[P]>
        }
      >
    >


  export type payment_methodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    is_active?: boolean
    details?: boolean
    payment_type_id?: boolean
    payment_types?: boolean | payment_methods$payment_typesArgs<ExtArgs>
    payments?: boolean | payment_methods$paymentsArgs<ExtArgs>
    transactions?: boolean | payment_methods$transactionsArgs<ExtArgs>
    _count?: boolean | Payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_methods"]>

  export type payment_methodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    is_active?: boolean
    details?: boolean
    payment_type_id?: boolean
    payment_types?: boolean | payment_methods$payment_typesArgs<ExtArgs>
  }, ExtArgs["result"]["payment_methods"]>

  export type payment_methodsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    is_active?: boolean
    details?: boolean
    payment_type_id?: boolean
    payment_types?: boolean | payment_methods$payment_typesArgs<ExtArgs>
  }, ExtArgs["result"]["payment_methods"]>

  export type payment_methodsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    is_active?: boolean
    details?: boolean
    payment_type_id?: boolean
  }

  export type payment_methodsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "is_active" | "details" | "payment_type_id", ExtArgs["result"]["payment_methods"]>
  export type payment_methodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_types?: boolean | payment_methods$payment_typesArgs<ExtArgs>
    payments?: boolean | payment_methods$paymentsArgs<ExtArgs>
    transactions?: boolean | payment_methods$transactionsArgs<ExtArgs>
    _count?: boolean | Payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payment_methodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_types?: boolean | payment_methods$payment_typesArgs<ExtArgs>
  }
  export type payment_methodsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_types?: boolean | payment_methods$payment_typesArgs<ExtArgs>
  }

  export type $payment_methodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_methods"
    objects: {
      payment_types: Prisma.$payment_typesPayload<ExtArgs> | null
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date | null
      updated_at: Date | null
      name: string
      is_active: boolean | null
      details: Prisma.JsonValue | null
      payment_type_id: number | null
    }, ExtArgs["result"]["payment_methods"]>
    composites: {}
  }

  type payment_methodsGetPayload<S extends boolean | null | undefined | payment_methodsDefaultArgs> = $Result.GetResult<Prisma.$payment_methodsPayload, S>

  type payment_methodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_methodsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_methodsCountAggregateInputType | true
    }

  export interface payment_methodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_methods'], meta: { name: 'payment_methods' } }
    /**
     * Find zero or one Payment_methods that matches the filter.
     * @param {payment_methodsFindUniqueArgs} args - Arguments to find a Payment_methods
     * @example
     * // Get one Payment_methods
     * const payment_methods = await prisma.payment_methods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_methodsFindUniqueArgs>(args: SelectSubset<T, payment_methodsFindUniqueArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_methods that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_methodsFindUniqueOrThrowArgs} args - Arguments to find a Payment_methods
     * @example
     * // Get one Payment_methods
     * const payment_methods = await prisma.payment_methods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_methodsFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_methodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsFindFirstArgs} args - Arguments to find a Payment_methods
     * @example
     * // Get one Payment_methods
     * const payment_methods = await prisma.payment_methods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_methodsFindFirstArgs>(args?: SelectSubset<T, payment_methodsFindFirstArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_methods that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsFindFirstOrThrowArgs} args - Arguments to find a Payment_methods
     * @example
     * // Get one Payment_methods
     * const payment_methods = await prisma.payment_methods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_methodsFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_methodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_methods
     * const payment_methods = await prisma.payment_methods.findMany()
     * 
     * // Get first 10 Payment_methods
     * const payment_methods = await prisma.payment_methods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_methodsWithIdOnly = await prisma.payment_methods.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_methodsFindManyArgs>(args?: SelectSubset<T, payment_methodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_methods.
     * @param {payment_methodsCreateArgs} args - Arguments to create a Payment_methods.
     * @example
     * // Create one Payment_methods
     * const Payment_methods = await prisma.payment_methods.create({
     *   data: {
     *     // ... data to create a Payment_methods
     *   }
     * })
     * 
     */
    create<T extends payment_methodsCreateArgs>(args: SelectSubset<T, payment_methodsCreateArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_methods.
     * @param {payment_methodsCreateManyArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_methods = await prisma.payment_methods.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_methodsCreateManyArgs>(args?: SelectSubset<T, payment_methodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_methods and returns the data saved in the database.
     * @param {payment_methodsCreateManyAndReturnArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_methods = await prisma.payment_methods.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_methods and only return the `id`
     * const payment_methodsWithIdOnly = await prisma.payment_methods.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_methodsCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_methodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_methods.
     * @param {payment_methodsDeleteArgs} args - Arguments to delete one Payment_methods.
     * @example
     * // Delete one Payment_methods
     * const Payment_methods = await prisma.payment_methods.delete({
     *   where: {
     *     // ... filter to delete one Payment_methods
     *   }
     * })
     * 
     */
    delete<T extends payment_methodsDeleteArgs>(args: SelectSubset<T, payment_methodsDeleteArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_methods.
     * @param {payment_methodsUpdateArgs} args - Arguments to update one Payment_methods.
     * @example
     * // Update one Payment_methods
     * const payment_methods = await prisma.payment_methods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_methodsUpdateArgs>(args: SelectSubset<T, payment_methodsUpdateArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_methods.
     * @param {payment_methodsDeleteManyArgs} args - Arguments to filter Payment_methods to delete.
     * @example
     * // Delete a few Payment_methods
     * const { count } = await prisma.payment_methods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_methodsDeleteManyArgs>(args?: SelectSubset<T, payment_methodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_methods
     * const payment_methods = await prisma.payment_methods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_methodsUpdateManyArgs>(args: SelectSubset<T, payment_methodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods and returns the data updated in the database.
     * @param {payment_methodsUpdateManyAndReturnArgs} args - Arguments to update many Payment_methods.
     * @example
     * // Update many Payment_methods
     * const payment_methods = await prisma.payment_methods.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_methods and only return the `id`
     * const payment_methodsWithIdOnly = await prisma.payment_methods.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_methodsUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_methodsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_methods.
     * @param {payment_methodsUpsertArgs} args - Arguments to update or create a Payment_methods.
     * @example
     * // Update or create a Payment_methods
     * const payment_methods = await prisma.payment_methods.upsert({
     *   create: {
     *     // ... data to create a Payment_methods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_methods we want to update
     *   }
     * })
     */
    upsert<T extends payment_methodsUpsertArgs>(args: SelectSubset<T, payment_methodsUpsertArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsCountArgs} args - Arguments to filter Payment_methods to count.
     * @example
     * // Count the number of Payment_methods
     * const count = await prisma.payment_methods.count({
     *   where: {
     *     // ... the filter for the Payment_methods we want to count
     *   }
     * })
    **/
    count<T extends payment_methodsCountArgs>(
      args?: Subset<T, payment_methodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_methodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_methodsAggregateArgs>(args: Subset<T, Payment_methodsAggregateArgs>): Prisma.PrismaPromise<GetPayment_methodsAggregateType<T>>

    /**
     * Group by Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_methodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_methodsGroupByArgs['orderBy'] }
        : { orderBy?: payment_methodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_methodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_methodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_methods model
   */
  readonly fields: payment_methodsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_methods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_methodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment_types<T extends payment_methods$payment_typesArgs<ExtArgs> = {}>(args?: Subset<T, payment_methods$payment_typesArgs<ExtArgs>>): Prisma__payment_typesClient<$Result.GetResult<Prisma.$payment_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends payment_methods$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, payment_methods$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends payment_methods$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, payment_methods$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_methods model
   */ 
  interface payment_methodsFieldRefs {
    readonly id: FieldRef<"payment_methods", 'String'>
    readonly created_at: FieldRef<"payment_methods", 'DateTime'>
    readonly updated_at: FieldRef<"payment_methods", 'DateTime'>
    readonly name: FieldRef<"payment_methods", 'String'>
    readonly is_active: FieldRef<"payment_methods", 'Boolean'>
    readonly details: FieldRef<"payment_methods", 'Json'>
    readonly payment_type_id: FieldRef<"payment_methods", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * payment_methods findUnique
   */
  export type payment_methodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where: payment_methodsWhereUniqueInput
  }

  /**
   * payment_methods findUniqueOrThrow
   */
  export type payment_methodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where: payment_methodsWhereUniqueInput
  }

  /**
   * payment_methods findFirst
   */
  export type payment_methodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodsScalarFieldEnum | Payment_methodsScalarFieldEnum[]
  }

  /**
   * payment_methods findFirstOrThrow
   */
  export type payment_methodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodsScalarFieldEnum | Payment_methodsScalarFieldEnum[]
  }

  /**
   * payment_methods findMany
   */
  export type payment_methodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_methods.
     */
    cursor?: payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    distinct?: Payment_methodsScalarFieldEnum | Payment_methodsScalarFieldEnum[]
  }

  /**
   * payment_methods create
   */
  export type payment_methodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_methods.
     */
    data: XOR<payment_methodsCreateInput, payment_methodsUncheckedCreateInput>
  }

  /**
   * payment_methods createMany
   */
  export type payment_methodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodsCreateManyInput | payment_methodsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_methods createManyAndReturn
   */
  export type payment_methodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodsCreateManyInput | payment_methodsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_methods update
   */
  export type payment_methodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_methods.
     */
    data: XOR<payment_methodsUpdateInput, payment_methodsUncheckedUpdateInput>
    /**
     * Choose, which payment_methods to update.
     */
    where: payment_methodsWhereUniqueInput
  }

  /**
   * payment_methods updateMany
   */
  export type payment_methodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodsUpdateManyMutationInput, payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodsWhereInput
    /**
     * Limit how many payment_methods to update.
     */
    limit?: number
  }

  /**
   * payment_methods updateManyAndReturn
   */
  export type payment_methodsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodsUpdateManyMutationInput, payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodsWhereInput
    /**
     * Limit how many payment_methods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_methods upsert
   */
  export type payment_methodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_methods to update in case it exists.
     */
    where: payment_methodsWhereUniqueInput
    /**
     * In case the payment_methods found by the `where` argument doesn't exist, create a new payment_methods with this data.
     */
    create: XOR<payment_methodsCreateInput, payment_methodsUncheckedCreateInput>
    /**
     * In case the payment_methods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_methodsUpdateInput, payment_methodsUncheckedUpdateInput>
  }

  /**
   * payment_methods delete
   */
  export type payment_methodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter which payment_methods to delete.
     */
    where: payment_methodsWhereUniqueInput
  }

  /**
   * payment_methods deleteMany
   */
  export type payment_methodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_methods to delete
     */
    where?: payment_methodsWhereInput
    /**
     * Limit how many payment_methods to delete.
     */
    limit?: number
  }

  /**
   * payment_methods.payment_types
   */
  export type payment_methods$payment_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_types
     */
    select?: payment_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_types
     */
    omit?: payment_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_typesInclude<ExtArgs> | null
    where?: payment_typesWhereInput
  }

  /**
   * payment_methods.payments
   */
  export type payment_methods$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payment_methods.transactions
   */
  export type payment_methods$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * payment_methods without action
   */
  export type payment_methodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
  }


  /**
   * Model transaction_categories
   */

  export type AggregateTransaction_categories = {
    _count: Transaction_categoriesCountAggregateOutputType | null
    _min: Transaction_categoriesMinAggregateOutputType | null
    _max: Transaction_categoriesMaxAggregateOutputType | null
  }

  export type Transaction_categoriesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    parent_id: string | null
    is_active: boolean | null
  }

  export type Transaction_categoriesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
    parent_id: string | null
    is_active: boolean | null
  }

  export type Transaction_categoriesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    description: number
    parent_id: number
    is_active: number
    _all: number
  }


  export type Transaction_categoriesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    parent_id?: true
    is_active?: true
  }

  export type Transaction_categoriesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    parent_id?: true
    is_active?: true
  }

  export type Transaction_categoriesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    parent_id?: true
    is_active?: true
    _all?: true
  }

  export type Transaction_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction_categories to aggregate.
     */
    where?: transaction_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_categories to fetch.
     */
    orderBy?: transaction_categoriesOrderByWithRelationInput | transaction_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaction_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaction_categories
    **/
    _count?: true | Transaction_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Transaction_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Transaction_categoriesMaxAggregateInputType
  }

  export type GetTransaction_categoriesAggregateType<T extends Transaction_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction_categories[P]>
      : GetScalarType<T[P], AggregateTransaction_categories[P]>
  }




  export type transaction_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaction_categoriesWhereInput
    orderBy?: transaction_categoriesOrderByWithAggregationInput | transaction_categoriesOrderByWithAggregationInput[]
    by: Transaction_categoriesScalarFieldEnum[] | Transaction_categoriesScalarFieldEnum
    having?: transaction_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Transaction_categoriesCountAggregateInputType | true
    _min?: Transaction_categoriesMinAggregateInputType
    _max?: Transaction_categoriesMaxAggregateInputType
  }

  export type Transaction_categoriesGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    name: string
    description: string | null
    parent_id: string | null
    is_active: boolean | null
    _count: Transaction_categoriesCountAggregateOutputType | null
    _min: Transaction_categoriesMinAggregateOutputType | null
    _max: Transaction_categoriesMaxAggregateOutputType | null
  }

  type GetTransaction_categoriesGroupByPayload<T extends transaction_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Transaction_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Transaction_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Transaction_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Transaction_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type transaction_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    parent_id?: boolean
    is_active?: boolean
    transaction_categories?: boolean | transaction_categories$transaction_categoriesArgs<ExtArgs>
    other_transaction_categories?: boolean | transaction_categories$other_transaction_categoriesArgs<ExtArgs>
    transactions?: boolean | transaction_categories$transactionsArgs<ExtArgs>
    _count?: boolean | Transaction_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction_categories"]>

  export type transaction_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    parent_id?: boolean
    is_active?: boolean
    transaction_categories?: boolean | transaction_categories$transaction_categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["transaction_categories"]>

  export type transaction_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    parent_id?: boolean
    is_active?: boolean
    transaction_categories?: boolean | transaction_categories$transaction_categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["transaction_categories"]>

  export type transaction_categoriesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    parent_id?: boolean
    is_active?: boolean
  }

  export type transaction_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "name" | "description" | "parent_id" | "is_active", ExtArgs["result"]["transaction_categories"]>
  export type transaction_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction_categories?: boolean | transaction_categories$transaction_categoriesArgs<ExtArgs>
    other_transaction_categories?: boolean | transaction_categories$other_transaction_categoriesArgs<ExtArgs>
    transactions?: boolean | transaction_categories$transactionsArgs<ExtArgs>
    _count?: boolean | Transaction_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type transaction_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction_categories?: boolean | transaction_categories$transaction_categoriesArgs<ExtArgs>
  }
  export type transaction_categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction_categories?: boolean | transaction_categories$transaction_categoriesArgs<ExtArgs>
  }

  export type $transaction_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction_categories"
    objects: {
      transaction_categories: Prisma.$transaction_categoriesPayload<ExtArgs> | null
      other_transaction_categories: Prisma.$transaction_categoriesPayload<ExtArgs>[]
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date | null
      updated_at: Date | null
      name: string
      description: string | null
      parent_id: string | null
      is_active: boolean | null
    }, ExtArgs["result"]["transaction_categories"]>
    composites: {}
  }

  type transaction_categoriesGetPayload<S extends boolean | null | undefined | transaction_categoriesDefaultArgs> = $Result.GetResult<Prisma.$transaction_categoriesPayload, S>

  type transaction_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transaction_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Transaction_categoriesCountAggregateInputType | true
    }

  export interface transaction_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction_categories'], meta: { name: 'transaction_categories' } }
    /**
     * Find zero or one Transaction_categories that matches the filter.
     * @param {transaction_categoriesFindUniqueArgs} args - Arguments to find a Transaction_categories
     * @example
     * // Get one Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaction_categoriesFindUniqueArgs>(args: SelectSubset<T, transaction_categoriesFindUniqueArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transaction_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Transaction_categories
     * @example
     * // Get one Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaction_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, transaction_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_categoriesFindFirstArgs} args - Arguments to find a Transaction_categories
     * @example
     * // Get one Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaction_categoriesFindFirstArgs>(args?: SelectSubset<T, transaction_categoriesFindFirstArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_categoriesFindFirstOrThrowArgs} args - Arguments to find a Transaction_categories
     * @example
     * // Get one Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaction_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, transaction_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transaction_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.findMany()
     * 
     * // Get first 10 Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaction_categoriesWithIdOnly = await prisma.transaction_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaction_categoriesFindManyArgs>(args?: SelectSubset<T, transaction_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction_categories.
     * @param {transaction_categoriesCreateArgs} args - Arguments to create a Transaction_categories.
     * @example
     * // Create one Transaction_categories
     * const Transaction_categories = await prisma.transaction_categories.create({
     *   data: {
     *     // ... data to create a Transaction_categories
     *   }
     * })
     * 
     */
    create<T extends transaction_categoriesCreateArgs>(args: SelectSubset<T, transaction_categoriesCreateArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transaction_categories.
     * @param {transaction_categoriesCreateManyArgs} args - Arguments to create many Transaction_categories.
     * @example
     * // Create many Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaction_categoriesCreateManyArgs>(args?: SelectSubset<T, transaction_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transaction_categories and returns the data saved in the database.
     * @param {transaction_categoriesCreateManyAndReturnArgs} args - Arguments to create many Transaction_categories.
     * @example
     * // Create many Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transaction_categories and only return the `id`
     * const transaction_categoriesWithIdOnly = await prisma.transaction_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transaction_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, transaction_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction_categories.
     * @param {transaction_categoriesDeleteArgs} args - Arguments to delete one Transaction_categories.
     * @example
     * // Delete one Transaction_categories
     * const Transaction_categories = await prisma.transaction_categories.delete({
     *   where: {
     *     // ... filter to delete one Transaction_categories
     *   }
     * })
     * 
     */
    delete<T extends transaction_categoriesDeleteArgs>(args: SelectSubset<T, transaction_categoriesDeleteArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction_categories.
     * @param {transaction_categoriesUpdateArgs} args - Arguments to update one Transaction_categories.
     * @example
     * // Update one Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaction_categoriesUpdateArgs>(args: SelectSubset<T, transaction_categoriesUpdateArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transaction_categories.
     * @param {transaction_categoriesDeleteManyArgs} args - Arguments to filter Transaction_categories to delete.
     * @example
     * // Delete a few Transaction_categories
     * const { count } = await prisma.transaction_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaction_categoriesDeleteManyArgs>(args?: SelectSubset<T, transaction_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaction_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaction_categoriesUpdateManyArgs>(args: SelectSubset<T, transaction_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaction_categories and returns the data updated in the database.
     * @param {transaction_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Transaction_categories.
     * @example
     * // Update many Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transaction_categories and only return the `id`
     * const transaction_categoriesWithIdOnly = await prisma.transaction_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transaction_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, transaction_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction_categories.
     * @param {transaction_categoriesUpsertArgs} args - Arguments to update or create a Transaction_categories.
     * @example
     * // Update or create a Transaction_categories
     * const transaction_categories = await prisma.transaction_categories.upsert({
     *   create: {
     *     // ... data to create a Transaction_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction_categories we want to update
     *   }
     * })
     */
    upsert<T extends transaction_categoriesUpsertArgs>(args: SelectSubset<T, transaction_categoriesUpsertArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transaction_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_categoriesCountArgs} args - Arguments to filter Transaction_categories to count.
     * @example
     * // Count the number of Transaction_categories
     * const count = await prisma.transaction_categories.count({
     *   where: {
     *     // ... the filter for the Transaction_categories we want to count
     *   }
     * })
    **/
    count<T extends transaction_categoriesCountArgs>(
      args?: Subset<T, transaction_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Transaction_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Transaction_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Transaction_categoriesAggregateArgs>(args: Subset<T, Transaction_categoriesAggregateArgs>): Prisma.PrismaPromise<GetTransaction_categoriesAggregateType<T>>

    /**
     * Group by Transaction_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaction_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaction_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: transaction_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaction_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaction_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction_categories model
   */
  readonly fields: transaction_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaction_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction_categories<T extends transaction_categories$transaction_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, transaction_categories$transaction_categoriesArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_transaction_categories<T extends transaction_categories$other_transaction_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, transaction_categories$other_transaction_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends transaction_categories$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, transaction_categories$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaction_categories model
   */ 
  interface transaction_categoriesFieldRefs {
    readonly id: FieldRef<"transaction_categories", 'String'>
    readonly created_at: FieldRef<"transaction_categories", 'DateTime'>
    readonly updated_at: FieldRef<"transaction_categories", 'DateTime'>
    readonly name: FieldRef<"transaction_categories", 'String'>
    readonly description: FieldRef<"transaction_categories", 'String'>
    readonly parent_id: FieldRef<"transaction_categories", 'String'>
    readonly is_active: FieldRef<"transaction_categories", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * transaction_categories findUnique
   */
  export type transaction_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_categories to fetch.
     */
    where: transaction_categoriesWhereUniqueInput
  }

  /**
   * transaction_categories findUniqueOrThrow
   */
  export type transaction_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_categories to fetch.
     */
    where: transaction_categoriesWhereUniqueInput
  }

  /**
   * transaction_categories findFirst
   */
  export type transaction_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_categories to fetch.
     */
    where?: transaction_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_categories to fetch.
     */
    orderBy?: transaction_categoriesOrderByWithRelationInput | transaction_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaction_categories.
     */
    cursor?: transaction_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaction_categories.
     */
    distinct?: Transaction_categoriesScalarFieldEnum | Transaction_categoriesScalarFieldEnum[]
  }

  /**
   * transaction_categories findFirstOrThrow
   */
  export type transaction_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_categories to fetch.
     */
    where?: transaction_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_categories to fetch.
     */
    orderBy?: transaction_categoriesOrderByWithRelationInput | transaction_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaction_categories.
     */
    cursor?: transaction_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaction_categories.
     */
    distinct?: Transaction_categoriesScalarFieldEnum | Transaction_categoriesScalarFieldEnum[]
  }

  /**
   * transaction_categories findMany
   */
  export type transaction_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_categories to fetch.
     */
    where?: transaction_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_categories to fetch.
     */
    orderBy?: transaction_categoriesOrderByWithRelationInput | transaction_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaction_categories.
     */
    cursor?: transaction_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_categories.
     */
    skip?: number
    distinct?: Transaction_categoriesScalarFieldEnum | Transaction_categoriesScalarFieldEnum[]
  }

  /**
   * transaction_categories create
   */
  export type transaction_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction_categories.
     */
    data: XOR<transaction_categoriesCreateInput, transaction_categoriesUncheckedCreateInput>
  }

  /**
   * transaction_categories createMany
   */
  export type transaction_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaction_categories.
     */
    data: transaction_categoriesCreateManyInput | transaction_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction_categories createManyAndReturn
   */
  export type transaction_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many transaction_categories.
     */
    data: transaction_categoriesCreateManyInput | transaction_categoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction_categories update
   */
  export type transaction_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction_categories.
     */
    data: XOR<transaction_categoriesUpdateInput, transaction_categoriesUncheckedUpdateInput>
    /**
     * Choose, which transaction_categories to update.
     */
    where: transaction_categoriesWhereUniqueInput
  }

  /**
   * transaction_categories updateMany
   */
  export type transaction_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaction_categories.
     */
    data: XOR<transaction_categoriesUpdateManyMutationInput, transaction_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which transaction_categories to update
     */
    where?: transaction_categoriesWhereInput
    /**
     * Limit how many transaction_categories to update.
     */
    limit?: number
  }

  /**
   * transaction_categories updateManyAndReturn
   */
  export type transaction_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update transaction_categories.
     */
    data: XOR<transaction_categoriesUpdateManyMutationInput, transaction_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which transaction_categories to update
     */
    where?: transaction_categoriesWhereInput
    /**
     * Limit how many transaction_categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction_categories upsert
   */
  export type transaction_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction_categories to update in case it exists.
     */
    where: transaction_categoriesWhereUniqueInput
    /**
     * In case the transaction_categories found by the `where` argument doesn't exist, create a new transaction_categories with this data.
     */
    create: XOR<transaction_categoriesCreateInput, transaction_categoriesUncheckedCreateInput>
    /**
     * In case the transaction_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaction_categoriesUpdateInput, transaction_categoriesUncheckedUpdateInput>
  }

  /**
   * transaction_categories delete
   */
  export type transaction_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    /**
     * Filter which transaction_categories to delete.
     */
    where: transaction_categoriesWhereUniqueInput
  }

  /**
   * transaction_categories deleteMany
   */
  export type transaction_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction_categories to delete
     */
    where?: transaction_categoriesWhereInput
    /**
     * Limit how many transaction_categories to delete.
     */
    limit?: number
  }

  /**
   * transaction_categories.transaction_categories
   */
  export type transaction_categories$transaction_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    where?: transaction_categoriesWhereInput
  }

  /**
   * transaction_categories.other_transaction_categories
   */
  export type transaction_categories$other_transaction_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    where?: transaction_categoriesWhereInput
    orderBy?: transaction_categoriesOrderByWithRelationInput | transaction_categoriesOrderByWithRelationInput[]
    cursor?: transaction_categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Transaction_categoriesScalarFieldEnum | Transaction_categoriesScalarFieldEnum[]
  }

  /**
   * transaction_categories.transactions
   */
  export type transaction_categories$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transaction_categories without action
   */
  export type transaction_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionsSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    description: string | null
    status: string | null
    transaction_date: Date | null
    transaction_type: string | null
    reference_id: string | null
    entity_type: string | null
    entity_id: string | null
    payment_method_id: string | null
    category_id: string | null
    transaction_type_id: string | null
    amount: Decimal | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    description: string | null
    status: string | null
    transaction_date: Date | null
    transaction_type: string | null
    reference_id: string | null
    entity_type: string | null
    entity_id: string | null
    payment_method_id: string | null
    category_id: string | null
    transaction_type_id: string | null
    amount: Decimal | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    description: number
    status: number
    transaction_date: number
    transaction_type: number
    reference_id: number
    entity_type: number
    entity_id: number
    payment_method_id: number
    metadata: number
    category_id: number
    transaction_type_id: number
    amount: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionsSumAggregateInputType = {
    amount?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    description?: true
    status?: true
    transaction_date?: true
    transaction_type?: true
    reference_id?: true
    entity_type?: true
    entity_id?: true
    payment_method_id?: true
    category_id?: true
    transaction_type_id?: true
    amount?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    description?: true
    status?: true
    transaction_date?: true
    transaction_type?: true
    reference_id?: true
    entity_type?: true
    entity_id?: true
    payment_method_id?: true
    category_id?: true
    transaction_type_id?: true
    amount?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    description?: true
    status?: true
    transaction_date?: true
    transaction_type?: true
    reference_id?: true
    entity_type?: true
    entity_id?: true
    payment_method_id?: true
    metadata?: true
    category_id?: true
    transaction_type_id?: true
    amount?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to aggregate.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithAggregationInput | transactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    description: string | null
    status: string
    transaction_date: Date | null
    transaction_type: string
    reference_id: string | null
    entity_type: string | null
    entity_id: string | null
    payment_method_id: string | null
    metadata: JsonValue | null
    category_id: string | null
    transaction_type_id: string | null
    amount: Decimal | null
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    status?: boolean
    transaction_date?: boolean
    transaction_type?: boolean
    reference_id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    payment_method_id?: boolean
    metadata?: boolean
    category_id?: boolean
    transaction_type_id?: boolean
    amount?: boolean
    payments?: boolean | transactions$paymentsArgs<ExtArgs>
    transaction_categories?: boolean | transactions$transaction_categoriesArgs<ExtArgs>
    payment_methods?: boolean | transactions$payment_methodsArgs<ExtArgs>
    transaction_types?: boolean | transactions$transaction_typesArgs<ExtArgs>
    _count?: boolean | TransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    status?: boolean
    transaction_date?: boolean
    transaction_type?: boolean
    reference_id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    payment_method_id?: boolean
    metadata?: boolean
    category_id?: boolean
    transaction_type_id?: boolean
    amount?: boolean
    transaction_categories?: boolean | transactions$transaction_categoriesArgs<ExtArgs>
    payment_methods?: boolean | transactions$payment_methodsArgs<ExtArgs>
    transaction_types?: boolean | transactions$transaction_typesArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    status?: boolean
    transaction_date?: boolean
    transaction_type?: boolean
    reference_id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    payment_method_id?: boolean
    metadata?: boolean
    category_id?: boolean
    transaction_type_id?: boolean
    amount?: boolean
    transaction_categories?: boolean | transactions$transaction_categoriesArgs<ExtArgs>
    payment_methods?: boolean | transactions$payment_methodsArgs<ExtArgs>
    transaction_types?: boolean | transactions$transaction_typesArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    status?: boolean
    transaction_date?: boolean
    transaction_type?: boolean
    reference_id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    payment_method_id?: boolean
    metadata?: boolean
    category_id?: boolean
    transaction_type_id?: boolean
    amount?: boolean
  }

  export type transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "description" | "status" | "transaction_date" | "transaction_type" | "reference_id" | "entity_type" | "entity_id" | "payment_method_id" | "metadata" | "category_id" | "transaction_type_id" | "amount", ExtArgs["result"]["transactions"]>
  export type transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | transactions$paymentsArgs<ExtArgs>
    transaction_categories?: boolean | transactions$transaction_categoriesArgs<ExtArgs>
    payment_methods?: boolean | transactions$payment_methodsArgs<ExtArgs>
    transaction_types?: boolean | transactions$transaction_typesArgs<ExtArgs>
    _count?: boolean | TransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction_categories?: boolean | transactions$transaction_categoriesArgs<ExtArgs>
    payment_methods?: boolean | transactions$payment_methodsArgs<ExtArgs>
    transaction_types?: boolean | transactions$transaction_typesArgs<ExtArgs>
  }
  export type transactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction_categories?: boolean | transactions$transaction_categoriesArgs<ExtArgs>
    payment_methods?: boolean | transactions$payment_methodsArgs<ExtArgs>
    transaction_types?: boolean | transactions$transaction_typesArgs<ExtArgs>
  }

  export type $transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactions"
    objects: {
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      transaction_categories: Prisma.$transaction_categoriesPayload<ExtArgs> | null
      payment_methods: Prisma.$payment_methodsPayload<ExtArgs> | null
      transaction_types: Prisma.$transaction_typesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date | null
      updated_at: Date | null
      description: string | null
      status: string
      transaction_date: Date | null
      transaction_type: string
      reference_id: string | null
      entity_type: string | null
      entity_id: string | null
      payment_method_id: string | null
      metadata: Prisma.JsonValue | null
      category_id: string | null
      transaction_type_id: string | null
      amount: Prisma.Decimal | null
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type transactionsGetPayload<S extends boolean | null | undefined | transactionsDefaultArgs> = $Result.GetResult<Prisma.$transactionsPayload, S>

  type transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactions'], meta: { name: 'transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {transactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionsFindUniqueArgs>(args: SelectSubset<T, transactionsFindUniqueArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionsFindFirstArgs>(args?: SelectSubset<T, transactionsFindFirstArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionsFindManyArgs>(args?: SelectSubset<T, transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {transactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends transactionsCreateArgs>(args: SelectSubset<T, transactionsCreateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionsCreateManyArgs>(args?: SelectSubset<T, transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {transactionsCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transactions.
     * @param {transactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends transactionsDeleteArgs>(args: SelectSubset<T, transactionsDeleteArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {transactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionsUpdateArgs>(args: SelectSubset<T, transactionsUpdateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionsDeleteManyArgs>(args?: SelectSubset<T, transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionsUpdateManyArgs>(args: SelectSubset<T, transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {transactionsUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, transactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transactions.
     * @param {transactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends transactionsUpsertArgs>(args: SelectSubset<T, transactionsUpsertArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionsCountArgs>(
      args?: Subset<T, transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionsGroupByArgs['orderBy'] }
        : { orderBy?: transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactions model
   */
  readonly fields: transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends transactions$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, transactions$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transaction_categories<T extends transactions$transaction_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, transactions$transaction_categoriesArgs<ExtArgs>>): Prisma__transaction_categoriesClient<$Result.GetResult<Prisma.$transaction_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment_methods<T extends transactions$payment_methodsArgs<ExtArgs> = {}>(args?: Subset<T, transactions$payment_methodsArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction_types<T extends transactions$transaction_typesArgs<ExtArgs> = {}>(args?: Subset<T, transactions$transaction_typesArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactions model
   */ 
  interface transactionsFieldRefs {
    readonly id: FieldRef<"transactions", 'String'>
    readonly created_at: FieldRef<"transactions", 'DateTime'>
    readonly updated_at: FieldRef<"transactions", 'DateTime'>
    readonly description: FieldRef<"transactions", 'String'>
    readonly status: FieldRef<"transactions", 'String'>
    readonly transaction_date: FieldRef<"transactions", 'DateTime'>
    readonly transaction_type: FieldRef<"transactions", 'String'>
    readonly reference_id: FieldRef<"transactions", 'String'>
    readonly entity_type: FieldRef<"transactions", 'String'>
    readonly entity_id: FieldRef<"transactions", 'String'>
    readonly payment_method_id: FieldRef<"transactions", 'String'>
    readonly metadata: FieldRef<"transactions", 'Json'>
    readonly category_id: FieldRef<"transactions", 'String'>
    readonly transaction_type_id: FieldRef<"transactions", 'String'>
    readonly amount: FieldRef<"transactions", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * transactions findUnique
   */
  export type transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findUniqueOrThrow
   */
  export type transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findFirst
   */
  export type transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findFirstOrThrow
   */
  export type transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findMany
   */
  export type transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions create
   */
  export type transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a transactions.
     */
    data: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
  }

  /**
   * transactions createMany
   */
  export type transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactions createManyAndReturn
   */
  export type transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transactions update
   */
  export type transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a transactions.
     */
    data: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
    /**
     * Choose, which transactions to update.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions updateMany
   */
  export type transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transactions updateManyAndReturn
   */
  export type transactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transactions upsert
   */
  export type transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the transactions to update in case it exists.
     */
    where: transactionsWhereUniqueInput
    /**
     * In case the transactions found by the `where` argument doesn't exist, create a new transactions with this data.
     */
    create: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
    /**
     * In case the transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
  }

  /**
   * transactions delete
   */
  export type transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter which transactions to delete.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions deleteMany
   */
  export type transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transactions.payments
   */
  export type transactions$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * transactions.transaction_categories
   */
  export type transactions$transaction_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_categories
     */
    select?: transaction_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_categories
     */
    omit?: transaction_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_categoriesInclude<ExtArgs> | null
    where?: transaction_categoriesWhereInput
  }

  /**
   * transactions.payment_methods
   */
  export type transactions$payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_methods
     */
    omit?: payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    where?: payment_methodsWhereInput
  }

  /**
   * transactions.transaction_types
   */
  export type transactions$transaction_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    where?: transaction_typesWhereInput
  }

  /**
   * transactions without action
   */
  export type transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
  }


  /**
   * Model transaction_types
   */

  export type AggregateTransaction_types = {
    _count: Transaction_typesCountAggregateOutputType | null
    _min: Transaction_typesMinAggregateOutputType | null
    _max: Transaction_typesMaxAggregateOutputType | null
  }

  export type Transaction_typesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    code: string | null
    name: string | null
    description: string | null
    affects_balance: string | null
    is_active: boolean | null
  }

  export type Transaction_typesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    code: string | null
    name: string | null
    description: string | null
    affects_balance: string | null
    is_active: boolean | null
  }

  export type Transaction_typesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    code: number
    name: number
    description: number
    affects_balance: number
    is_active: number
    _all: number
  }


  export type Transaction_typesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    name?: true
    description?: true
    affects_balance?: true
    is_active?: true
  }

  export type Transaction_typesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    name?: true
    description?: true
    affects_balance?: true
    is_active?: true
  }

  export type Transaction_typesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    code?: true
    name?: true
    description?: true
    affects_balance?: true
    is_active?: true
    _all?: true
  }

  export type Transaction_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction_types to aggregate.
     */
    where?: transaction_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_types to fetch.
     */
    orderBy?: transaction_typesOrderByWithRelationInput | transaction_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaction_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaction_types
    **/
    _count?: true | Transaction_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Transaction_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Transaction_typesMaxAggregateInputType
  }

  export type GetTransaction_typesAggregateType<T extends Transaction_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction_types[P]>
      : GetScalarType<T[P], AggregateTransaction_types[P]>
  }




  export type transaction_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaction_typesWhereInput
    orderBy?: transaction_typesOrderByWithAggregationInput | transaction_typesOrderByWithAggregationInput[]
    by: Transaction_typesScalarFieldEnum[] | Transaction_typesScalarFieldEnum
    having?: transaction_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Transaction_typesCountAggregateInputType | true
    _min?: Transaction_typesMinAggregateInputType
    _max?: Transaction_typesMaxAggregateInputType
  }

  export type Transaction_typesGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    code: string
    name: string
    description: string | null
    affects_balance: string
    is_active: boolean | null
    _count: Transaction_typesCountAggregateOutputType | null
    _min: Transaction_typesMinAggregateOutputType | null
    _max: Transaction_typesMaxAggregateOutputType | null
  }

  type GetTransaction_typesGroupByPayload<T extends transaction_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Transaction_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Transaction_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Transaction_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Transaction_typesGroupByOutputType[P]>
        }
      >
    >


  export type transaction_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    affects_balance?: boolean
    is_active?: boolean
    transactions?: boolean | transaction_types$transactionsArgs<ExtArgs>
    _count?: boolean | Transaction_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction_types"]>

  export type transaction_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    affects_balance?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["transaction_types"]>

  export type transaction_typesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    affects_balance?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["transaction_types"]>

  export type transaction_typesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    affects_balance?: boolean
    is_active?: boolean
  }

  export type transaction_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "code" | "name" | "description" | "affects_balance" | "is_active", ExtArgs["result"]["transaction_types"]>
  export type transaction_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | transaction_types$transactionsArgs<ExtArgs>
    _count?: boolean | Transaction_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type transaction_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type transaction_typesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $transaction_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction_types"
    objects: {
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date | null
      updated_at: Date | null
      code: string
      name: string
      description: string | null
      affects_balance: string
      is_active: boolean | null
    }, ExtArgs["result"]["transaction_types"]>
    composites: {}
  }

  type transaction_typesGetPayload<S extends boolean | null | undefined | transaction_typesDefaultArgs> = $Result.GetResult<Prisma.$transaction_typesPayload, S>

  type transaction_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transaction_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Transaction_typesCountAggregateInputType | true
    }

  export interface transaction_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction_types'], meta: { name: 'transaction_types' } }
    /**
     * Find zero or one Transaction_types that matches the filter.
     * @param {transaction_typesFindUniqueArgs} args - Arguments to find a Transaction_types
     * @example
     * // Get one Transaction_types
     * const transaction_types = await prisma.transaction_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaction_typesFindUniqueArgs>(args: SelectSubset<T, transaction_typesFindUniqueArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transaction_typesFindUniqueOrThrowArgs} args - Arguments to find a Transaction_types
     * @example
     * // Get one Transaction_types
     * const transaction_types = await prisma.transaction_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaction_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, transaction_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesFindFirstArgs} args - Arguments to find a Transaction_types
     * @example
     * // Get one Transaction_types
     * const transaction_types = await prisma.transaction_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaction_typesFindFirstArgs>(args?: SelectSubset<T, transaction_typesFindFirstArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesFindFirstOrThrowArgs} args - Arguments to find a Transaction_types
     * @example
     * // Get one Transaction_types
     * const transaction_types = await prisma.transaction_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaction_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, transaction_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transaction_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaction_types
     * const transaction_types = await prisma.transaction_types.findMany()
     * 
     * // Get first 10 Transaction_types
     * const transaction_types = await prisma.transaction_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaction_typesWithIdOnly = await prisma.transaction_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaction_typesFindManyArgs>(args?: SelectSubset<T, transaction_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction_types.
     * @param {transaction_typesCreateArgs} args - Arguments to create a Transaction_types.
     * @example
     * // Create one Transaction_types
     * const Transaction_types = await prisma.transaction_types.create({
     *   data: {
     *     // ... data to create a Transaction_types
     *   }
     * })
     * 
     */
    create<T extends transaction_typesCreateArgs>(args: SelectSubset<T, transaction_typesCreateArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transaction_types.
     * @param {transaction_typesCreateManyArgs} args - Arguments to create many Transaction_types.
     * @example
     * // Create many Transaction_types
     * const transaction_types = await prisma.transaction_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaction_typesCreateManyArgs>(args?: SelectSubset<T, transaction_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transaction_types and returns the data saved in the database.
     * @param {transaction_typesCreateManyAndReturnArgs} args - Arguments to create many Transaction_types.
     * @example
     * // Create many Transaction_types
     * const transaction_types = await prisma.transaction_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transaction_types and only return the `id`
     * const transaction_typesWithIdOnly = await prisma.transaction_types.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transaction_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, transaction_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction_types.
     * @param {transaction_typesDeleteArgs} args - Arguments to delete one Transaction_types.
     * @example
     * // Delete one Transaction_types
     * const Transaction_types = await prisma.transaction_types.delete({
     *   where: {
     *     // ... filter to delete one Transaction_types
     *   }
     * })
     * 
     */
    delete<T extends transaction_typesDeleteArgs>(args: SelectSubset<T, transaction_typesDeleteArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction_types.
     * @param {transaction_typesUpdateArgs} args - Arguments to update one Transaction_types.
     * @example
     * // Update one Transaction_types
     * const transaction_types = await prisma.transaction_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaction_typesUpdateArgs>(args: SelectSubset<T, transaction_typesUpdateArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transaction_types.
     * @param {transaction_typesDeleteManyArgs} args - Arguments to filter Transaction_types to delete.
     * @example
     * // Delete a few Transaction_types
     * const { count } = await prisma.transaction_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaction_typesDeleteManyArgs>(args?: SelectSubset<T, transaction_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaction_types
     * const transaction_types = await prisma.transaction_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaction_typesUpdateManyArgs>(args: SelectSubset<T, transaction_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaction_types and returns the data updated in the database.
     * @param {transaction_typesUpdateManyAndReturnArgs} args - Arguments to update many Transaction_types.
     * @example
     * // Update many Transaction_types
     * const transaction_types = await prisma.transaction_types.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transaction_types and only return the `id`
     * const transaction_typesWithIdOnly = await prisma.transaction_types.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transaction_typesUpdateManyAndReturnArgs>(args: SelectSubset<T, transaction_typesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction_types.
     * @param {transaction_typesUpsertArgs} args - Arguments to update or create a Transaction_types.
     * @example
     * // Update or create a Transaction_types
     * const transaction_types = await prisma.transaction_types.upsert({
     *   create: {
     *     // ... data to create a Transaction_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction_types we want to update
     *   }
     * })
     */
    upsert<T extends transaction_typesUpsertArgs>(args: SelectSubset<T, transaction_typesUpsertArgs<ExtArgs>>): Prisma__transaction_typesClient<$Result.GetResult<Prisma.$transaction_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesCountArgs} args - Arguments to filter Transaction_types to count.
     * @example
     * // Count the number of Transaction_types
     * const count = await prisma.transaction_types.count({
     *   where: {
     *     // ... the filter for the Transaction_types we want to count
     *   }
     * })
    **/
    count<T extends transaction_typesCountArgs>(
      args?: Subset<T, transaction_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Transaction_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Transaction_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Transaction_typesAggregateArgs>(args: Subset<T, Transaction_typesAggregateArgs>): Prisma.PrismaPromise<GetTransaction_typesAggregateType<T>>

    /**
     * Group by Transaction_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaction_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaction_typesGroupByArgs['orderBy'] }
        : { orderBy?: transaction_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaction_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaction_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction_types model
   */
  readonly fields: transaction_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaction_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends transaction_types$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, transaction_types$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaction_types model
   */ 
  interface transaction_typesFieldRefs {
    readonly id: FieldRef<"transaction_types", 'String'>
    readonly created_at: FieldRef<"transaction_types", 'DateTime'>
    readonly updated_at: FieldRef<"transaction_types", 'DateTime'>
    readonly code: FieldRef<"transaction_types", 'String'>
    readonly name: FieldRef<"transaction_types", 'String'>
    readonly description: FieldRef<"transaction_types", 'String'>
    readonly affects_balance: FieldRef<"transaction_types", 'String'>
    readonly is_active: FieldRef<"transaction_types", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * transaction_types findUnique
   */
  export type transaction_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where: transaction_typesWhereUniqueInput
  }

  /**
   * transaction_types findUniqueOrThrow
   */
  export type transaction_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where: transaction_typesWhereUniqueInput
  }

  /**
   * transaction_types findFirst
   */
  export type transaction_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where?: transaction_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_types to fetch.
     */
    orderBy?: transaction_typesOrderByWithRelationInput | transaction_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaction_types.
     */
    cursor?: transaction_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaction_types.
     */
    distinct?: Transaction_typesScalarFieldEnum | Transaction_typesScalarFieldEnum[]
  }

  /**
   * transaction_types findFirstOrThrow
   */
  export type transaction_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where?: transaction_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_types to fetch.
     */
    orderBy?: transaction_typesOrderByWithRelationInput | transaction_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaction_types.
     */
    cursor?: transaction_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaction_types.
     */
    distinct?: Transaction_typesScalarFieldEnum | Transaction_typesScalarFieldEnum[]
  }

  /**
   * transaction_types findMany
   */
  export type transaction_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * Filter, which transaction_types to fetch.
     */
    where?: transaction_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_types to fetch.
     */
    orderBy?: transaction_typesOrderByWithRelationInput | transaction_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaction_types.
     */
    cursor?: transaction_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_types.
     */
    skip?: number
    distinct?: Transaction_typesScalarFieldEnum | Transaction_typesScalarFieldEnum[]
  }

  /**
   * transaction_types create
   */
  export type transaction_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction_types.
     */
    data: XOR<transaction_typesCreateInput, transaction_typesUncheckedCreateInput>
  }

  /**
   * transaction_types createMany
   */
  export type transaction_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaction_types.
     */
    data: transaction_typesCreateManyInput | transaction_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction_types createManyAndReturn
   */
  export type transaction_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * The data used to create many transaction_types.
     */
    data: transaction_typesCreateManyInput | transaction_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction_types update
   */
  export type transaction_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction_types.
     */
    data: XOR<transaction_typesUpdateInput, transaction_typesUncheckedUpdateInput>
    /**
     * Choose, which transaction_types to update.
     */
    where: transaction_typesWhereUniqueInput
  }

  /**
   * transaction_types updateMany
   */
  export type transaction_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaction_types.
     */
    data: XOR<transaction_typesUpdateManyMutationInput, transaction_typesUncheckedUpdateManyInput>
    /**
     * Filter which transaction_types to update
     */
    where?: transaction_typesWhereInput
    /**
     * Limit how many transaction_types to update.
     */
    limit?: number
  }

  /**
   * transaction_types updateManyAndReturn
   */
  export type transaction_typesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * The data used to update transaction_types.
     */
    data: XOR<transaction_typesUpdateManyMutationInput, transaction_typesUncheckedUpdateManyInput>
    /**
     * Filter which transaction_types to update
     */
    where?: transaction_typesWhereInput
    /**
     * Limit how many transaction_types to update.
     */
    limit?: number
  }

  /**
   * transaction_types upsert
   */
  export type transaction_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction_types to update in case it exists.
     */
    where: transaction_typesWhereUniqueInput
    /**
     * In case the transaction_types found by the `where` argument doesn't exist, create a new transaction_types with this data.
     */
    create: XOR<transaction_typesCreateInput, transaction_typesUncheckedCreateInput>
    /**
     * In case the transaction_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaction_typesUpdateInput, transaction_typesUncheckedUpdateInput>
  }

  /**
   * transaction_types delete
   */
  export type transaction_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
    /**
     * Filter which transaction_types to delete.
     */
    where: transaction_typesWhereUniqueInput
  }

  /**
   * transaction_types deleteMany
   */
  export type transaction_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction_types to delete
     */
    where?: transaction_typesWhereInput
    /**
     * Limit how many transaction_types to delete.
     */
    limit?: number
  }

  /**
   * transaction_types.transactions
   */
  export type transaction_types$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transaction_types without action
   */
  export type transaction_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_types
     */
    select?: transaction_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_types
     */
    omit?: transaction_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_typesInclude<ExtArgs> | null
  }


  /**
   * Model referral_sources
   */

  export type AggregateReferral_sources = {
    _count: Referral_sourcesCountAggregateOutputType | null
    _min: Referral_sourcesMinAggregateOutputType | null
    _max: Referral_sourcesMaxAggregateOutputType | null
  }

  export type Referral_sourcesMinAggregateOutputType = {
    id: string | null
    source_name: string | null
  }

  export type Referral_sourcesMaxAggregateOutputType = {
    id: string | null
    source_name: string | null
  }

  export type Referral_sourcesCountAggregateOutputType = {
    id: number
    source_name: number
    _all: number
  }


  export type Referral_sourcesMinAggregateInputType = {
    id?: true
    source_name?: true
  }

  export type Referral_sourcesMaxAggregateInputType = {
    id?: true
    source_name?: true
  }

  export type Referral_sourcesCountAggregateInputType = {
    id?: true
    source_name?: true
    _all?: true
  }

  export type Referral_sourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_sources to aggregate.
     */
    where?: referral_sourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_sources to fetch.
     */
    orderBy?: referral_sourcesOrderByWithRelationInput | referral_sourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referral_sourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned referral_sources
    **/
    _count?: true | Referral_sourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Referral_sourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Referral_sourcesMaxAggregateInputType
  }

  export type GetReferral_sourcesAggregateType<T extends Referral_sourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral_sources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral_sources[P]>
      : GetScalarType<T[P], AggregateReferral_sources[P]>
  }




  export type referral_sourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: referral_sourcesWhereInput
    orderBy?: referral_sourcesOrderByWithAggregationInput | referral_sourcesOrderByWithAggregationInput[]
    by: Referral_sourcesScalarFieldEnum[] | Referral_sourcesScalarFieldEnum
    having?: referral_sourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Referral_sourcesCountAggregateInputType | true
    _min?: Referral_sourcesMinAggregateInputType
    _max?: Referral_sourcesMaxAggregateInputType
  }

  export type Referral_sourcesGroupByOutputType = {
    id: string
    source_name: string
    _count: Referral_sourcesCountAggregateOutputType | null
    _min: Referral_sourcesMinAggregateOutputType | null
    _max: Referral_sourcesMaxAggregateOutputType | null
  }

  type GetReferral_sourcesGroupByPayload<T extends referral_sourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Referral_sourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Referral_sourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Referral_sourcesGroupByOutputType[P]>
            : GetScalarType<T[P], Referral_sourcesGroupByOutputType[P]>
        }
      >
    >


  export type referral_sourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source_name?: boolean
    users?: boolean | referral_sources$usersArgs<ExtArgs>
    _count?: boolean | Referral_sourcesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral_sources"]>

  export type referral_sourcesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source_name?: boolean
  }, ExtArgs["result"]["referral_sources"]>

  export type referral_sourcesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source_name?: boolean
  }, ExtArgs["result"]["referral_sources"]>

  export type referral_sourcesSelectScalar = {
    id?: boolean
    source_name?: boolean
  }

  export type referral_sourcesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "source_name", ExtArgs["result"]["referral_sources"]>
  export type referral_sourcesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | referral_sources$usersArgs<ExtArgs>
    _count?: boolean | Referral_sourcesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type referral_sourcesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type referral_sourcesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $referral_sourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "referral_sources"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source_name: string
    }, ExtArgs["result"]["referral_sources"]>
    composites: {}
  }

  type referral_sourcesGetPayload<S extends boolean | null | undefined | referral_sourcesDefaultArgs> = $Result.GetResult<Prisma.$referral_sourcesPayload, S>

  type referral_sourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<referral_sourcesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Referral_sourcesCountAggregateInputType | true
    }

  export interface referral_sourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['referral_sources'], meta: { name: 'referral_sources' } }
    /**
     * Find zero or one Referral_sources that matches the filter.
     * @param {referral_sourcesFindUniqueArgs} args - Arguments to find a Referral_sources
     * @example
     * // Get one Referral_sources
     * const referral_sources = await prisma.referral_sources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends referral_sourcesFindUniqueArgs>(args: SelectSubset<T, referral_sourcesFindUniqueArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral_sources that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {referral_sourcesFindUniqueOrThrowArgs} args - Arguments to find a Referral_sources
     * @example
     * // Get one Referral_sources
     * const referral_sources = await prisma.referral_sources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends referral_sourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, referral_sourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral_sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_sourcesFindFirstArgs} args - Arguments to find a Referral_sources
     * @example
     * // Get one Referral_sources
     * const referral_sources = await prisma.referral_sources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends referral_sourcesFindFirstArgs>(args?: SelectSubset<T, referral_sourcesFindFirstArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral_sources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_sourcesFindFirstOrThrowArgs} args - Arguments to find a Referral_sources
     * @example
     * // Get one Referral_sources
     * const referral_sources = await prisma.referral_sources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends referral_sourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, referral_sourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referral_sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_sourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referral_sources
     * const referral_sources = await prisma.referral_sources.findMany()
     * 
     * // Get first 10 Referral_sources
     * const referral_sources = await prisma.referral_sources.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referral_sourcesWithIdOnly = await prisma.referral_sources.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends referral_sourcesFindManyArgs>(args?: SelectSubset<T, referral_sourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral_sources.
     * @param {referral_sourcesCreateArgs} args - Arguments to create a Referral_sources.
     * @example
     * // Create one Referral_sources
     * const Referral_sources = await prisma.referral_sources.create({
     *   data: {
     *     // ... data to create a Referral_sources
     *   }
     * })
     * 
     */
    create<T extends referral_sourcesCreateArgs>(args: SelectSubset<T, referral_sourcesCreateArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referral_sources.
     * @param {referral_sourcesCreateManyArgs} args - Arguments to create many Referral_sources.
     * @example
     * // Create many Referral_sources
     * const referral_sources = await prisma.referral_sources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends referral_sourcesCreateManyArgs>(args?: SelectSubset<T, referral_sourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referral_sources and returns the data saved in the database.
     * @param {referral_sourcesCreateManyAndReturnArgs} args - Arguments to create many Referral_sources.
     * @example
     * // Create many Referral_sources
     * const referral_sources = await prisma.referral_sources.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referral_sources and only return the `id`
     * const referral_sourcesWithIdOnly = await prisma.referral_sources.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends referral_sourcesCreateManyAndReturnArgs>(args?: SelectSubset<T, referral_sourcesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral_sources.
     * @param {referral_sourcesDeleteArgs} args - Arguments to delete one Referral_sources.
     * @example
     * // Delete one Referral_sources
     * const Referral_sources = await prisma.referral_sources.delete({
     *   where: {
     *     // ... filter to delete one Referral_sources
     *   }
     * })
     * 
     */
    delete<T extends referral_sourcesDeleteArgs>(args: SelectSubset<T, referral_sourcesDeleteArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral_sources.
     * @param {referral_sourcesUpdateArgs} args - Arguments to update one Referral_sources.
     * @example
     * // Update one Referral_sources
     * const referral_sources = await prisma.referral_sources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends referral_sourcesUpdateArgs>(args: SelectSubset<T, referral_sourcesUpdateArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referral_sources.
     * @param {referral_sourcesDeleteManyArgs} args - Arguments to filter Referral_sources to delete.
     * @example
     * // Delete a few Referral_sources
     * const { count } = await prisma.referral_sources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends referral_sourcesDeleteManyArgs>(args?: SelectSubset<T, referral_sourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_sourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referral_sources
     * const referral_sources = await prisma.referral_sources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends referral_sourcesUpdateManyArgs>(args: SelectSubset<T, referral_sourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_sources and returns the data updated in the database.
     * @param {referral_sourcesUpdateManyAndReturnArgs} args - Arguments to update many Referral_sources.
     * @example
     * // Update many Referral_sources
     * const referral_sources = await prisma.referral_sources.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referral_sources and only return the `id`
     * const referral_sourcesWithIdOnly = await prisma.referral_sources.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends referral_sourcesUpdateManyAndReturnArgs>(args: SelectSubset<T, referral_sourcesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral_sources.
     * @param {referral_sourcesUpsertArgs} args - Arguments to update or create a Referral_sources.
     * @example
     * // Update or create a Referral_sources
     * const referral_sources = await prisma.referral_sources.upsert({
     *   create: {
     *     // ... data to create a Referral_sources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral_sources we want to update
     *   }
     * })
     */
    upsert<T extends referral_sourcesUpsertArgs>(args: SelectSubset<T, referral_sourcesUpsertArgs<ExtArgs>>): Prisma__referral_sourcesClient<$Result.GetResult<Prisma.$referral_sourcesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referral_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_sourcesCountArgs} args - Arguments to filter Referral_sources to count.
     * @example
     * // Count the number of Referral_sources
     * const count = await prisma.referral_sources.count({
     *   where: {
     *     // ... the filter for the Referral_sources we want to count
     *   }
     * })
    **/
    count<T extends referral_sourcesCountArgs>(
      args?: Subset<T, referral_sourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Referral_sourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Referral_sourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Referral_sourcesAggregateArgs>(args: Subset<T, Referral_sourcesAggregateArgs>): Prisma.PrismaPromise<GetReferral_sourcesAggregateType<T>>

    /**
     * Group by Referral_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_sourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referral_sourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referral_sourcesGroupByArgs['orderBy'] }
        : { orderBy?: referral_sourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referral_sourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferral_sourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the referral_sources model
   */
  readonly fields: referral_sourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for referral_sources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__referral_sourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends referral_sources$usersArgs<ExtArgs> = {}>(args?: Subset<T, referral_sources$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the referral_sources model
   */ 
  interface referral_sourcesFieldRefs {
    readonly id: FieldRef<"referral_sources", 'String'>
    readonly source_name: FieldRef<"referral_sources", 'String'>
  }
    

  // Custom InputTypes
  /**
   * referral_sources findUnique
   */
  export type referral_sourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * Filter, which referral_sources to fetch.
     */
    where: referral_sourcesWhereUniqueInput
  }

  /**
   * referral_sources findUniqueOrThrow
   */
  export type referral_sourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * Filter, which referral_sources to fetch.
     */
    where: referral_sourcesWhereUniqueInput
  }

  /**
   * referral_sources findFirst
   */
  export type referral_sourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * Filter, which referral_sources to fetch.
     */
    where?: referral_sourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_sources to fetch.
     */
    orderBy?: referral_sourcesOrderByWithRelationInput | referral_sourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_sources.
     */
    cursor?: referral_sourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_sources.
     */
    distinct?: Referral_sourcesScalarFieldEnum | Referral_sourcesScalarFieldEnum[]
  }

  /**
   * referral_sources findFirstOrThrow
   */
  export type referral_sourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * Filter, which referral_sources to fetch.
     */
    where?: referral_sourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_sources to fetch.
     */
    orderBy?: referral_sourcesOrderByWithRelationInput | referral_sourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_sources.
     */
    cursor?: referral_sourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_sources.
     */
    distinct?: Referral_sourcesScalarFieldEnum | Referral_sourcesScalarFieldEnum[]
  }

  /**
   * referral_sources findMany
   */
  export type referral_sourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * Filter, which referral_sources to fetch.
     */
    where?: referral_sourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_sources to fetch.
     */
    orderBy?: referral_sourcesOrderByWithRelationInput | referral_sourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing referral_sources.
     */
    cursor?: referral_sourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_sources.
     */
    skip?: number
    distinct?: Referral_sourcesScalarFieldEnum | Referral_sourcesScalarFieldEnum[]
  }

  /**
   * referral_sources create
   */
  export type referral_sourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * The data needed to create a referral_sources.
     */
    data: XOR<referral_sourcesCreateInput, referral_sourcesUncheckedCreateInput>
  }

  /**
   * referral_sources createMany
   */
  export type referral_sourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many referral_sources.
     */
    data: referral_sourcesCreateManyInput | referral_sourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * referral_sources createManyAndReturn
   */
  export type referral_sourcesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * The data used to create many referral_sources.
     */
    data: referral_sourcesCreateManyInput | referral_sourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * referral_sources update
   */
  export type referral_sourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * The data needed to update a referral_sources.
     */
    data: XOR<referral_sourcesUpdateInput, referral_sourcesUncheckedUpdateInput>
    /**
     * Choose, which referral_sources to update.
     */
    where: referral_sourcesWhereUniqueInput
  }

  /**
   * referral_sources updateMany
   */
  export type referral_sourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update referral_sources.
     */
    data: XOR<referral_sourcesUpdateManyMutationInput, referral_sourcesUncheckedUpdateManyInput>
    /**
     * Filter which referral_sources to update
     */
    where?: referral_sourcesWhereInput
    /**
     * Limit how many referral_sources to update.
     */
    limit?: number
  }

  /**
   * referral_sources updateManyAndReturn
   */
  export type referral_sourcesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * The data used to update referral_sources.
     */
    data: XOR<referral_sourcesUpdateManyMutationInput, referral_sourcesUncheckedUpdateManyInput>
    /**
     * Filter which referral_sources to update
     */
    where?: referral_sourcesWhereInput
    /**
     * Limit how many referral_sources to update.
     */
    limit?: number
  }

  /**
   * referral_sources upsert
   */
  export type referral_sourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * The filter to search for the referral_sources to update in case it exists.
     */
    where: referral_sourcesWhereUniqueInput
    /**
     * In case the referral_sources found by the `where` argument doesn't exist, create a new referral_sources with this data.
     */
    create: XOR<referral_sourcesCreateInput, referral_sourcesUncheckedCreateInput>
    /**
     * In case the referral_sources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referral_sourcesUpdateInput, referral_sourcesUncheckedUpdateInput>
  }

  /**
   * referral_sources delete
   */
  export type referral_sourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
    /**
     * Filter which referral_sources to delete.
     */
    where: referral_sourcesWhereUniqueInput
  }

  /**
   * referral_sources deleteMany
   */
  export type referral_sourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_sources to delete
     */
    where?: referral_sourcesWhereInput
    /**
     * Limit how many referral_sources to delete.
     */
    limit?: number
  }

  /**
   * referral_sources.users
   */
  export type referral_sources$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * referral_sources without action
   */
  export type referral_sourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_sources
     */
    select?: referral_sourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_sources
     */
    omit?: referral_sourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referral_sourcesInclude<ExtArgs> | null
  }


  /**
   * Model cash_closures
   */

  export type AggregateCash_closures = {
    _count: Cash_closuresCountAggregateOutputType | null
    _avg: Cash_closuresAvgAggregateOutputType | null
    _sum: Cash_closuresSumAggregateOutputType | null
    _min: Cash_closuresMinAggregateOutputType | null
    _max: Cash_closuresMaxAggregateOutputType | null
  }

  export type Cash_closuresAvgAggregateOutputType = {
    total_cash: number | null
    total_yappy: number | null
    total_card: number | null
    total_bank_transfer: number | null
    total_digital_wallet: number | null
    total_internal_wallet: number | null
    total_credits: number | null
    total_debits: number | null
    final_balance: number | null
  }

  export type Cash_closuresSumAggregateOutputType = {
    total_cash: number | null
    total_yappy: number | null
    total_card: number | null
    total_bank_transfer: number | null
    total_digital_wallet: number | null
    total_internal_wallet: number | null
    total_credits: number | null
    total_debits: number | null
    final_balance: number | null
  }

  export type Cash_closuresMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    cash_closures: Date | null
    total_cash: number | null
    total_yappy: number | null
    total_card: number | null
    total_bank_transfer: number | null
    total_digital_wallet: number | null
    total_internal_wallet: number | null
    total_credits: number | null
    total_debits: number | null
    final_balance: number | null
    status: string | null
  }

  export type Cash_closuresMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    cash_closures: Date | null
    total_cash: number | null
    total_yappy: number | null
    total_card: number | null
    total_bank_transfer: number | null
    total_digital_wallet: number | null
    total_internal_wallet: number | null
    total_credits: number | null
    total_debits: number | null
    final_balance: number | null
    status: string | null
  }

  export type Cash_closuresCountAggregateOutputType = {
    id: number
    created_at: number
    cash_closures: number
    total_cash: number
    total_yappy: number
    total_card: number
    total_bank_transfer: number
    total_digital_wallet: number
    total_internal_wallet: number
    total_credits: number
    total_debits: number
    final_balance: number
    status: number
    _all: number
  }


  export type Cash_closuresAvgAggregateInputType = {
    total_cash?: true
    total_yappy?: true
    total_card?: true
    total_bank_transfer?: true
    total_digital_wallet?: true
    total_internal_wallet?: true
    total_credits?: true
    total_debits?: true
    final_balance?: true
  }

  export type Cash_closuresSumAggregateInputType = {
    total_cash?: true
    total_yappy?: true
    total_card?: true
    total_bank_transfer?: true
    total_digital_wallet?: true
    total_internal_wallet?: true
    total_credits?: true
    total_debits?: true
    final_balance?: true
  }

  export type Cash_closuresMinAggregateInputType = {
    id?: true
    created_at?: true
    cash_closures?: true
    total_cash?: true
    total_yappy?: true
    total_card?: true
    total_bank_transfer?: true
    total_digital_wallet?: true
    total_internal_wallet?: true
    total_credits?: true
    total_debits?: true
    final_balance?: true
    status?: true
  }

  export type Cash_closuresMaxAggregateInputType = {
    id?: true
    created_at?: true
    cash_closures?: true
    total_cash?: true
    total_yappy?: true
    total_card?: true
    total_bank_transfer?: true
    total_digital_wallet?: true
    total_internal_wallet?: true
    total_credits?: true
    total_debits?: true
    final_balance?: true
    status?: true
  }

  export type Cash_closuresCountAggregateInputType = {
    id?: true
    created_at?: true
    cash_closures?: true
    total_cash?: true
    total_yappy?: true
    total_card?: true
    total_bank_transfer?: true
    total_digital_wallet?: true
    total_internal_wallet?: true
    total_credits?: true
    total_debits?: true
    final_balance?: true
    status?: true
    _all?: true
  }

  export type Cash_closuresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cash_closures to aggregate.
     */
    where?: cash_closuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_closures to fetch.
     */
    orderBy?: cash_closuresOrderByWithRelationInput | cash_closuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cash_closuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_closures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_closures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cash_closures
    **/
    _count?: true | Cash_closuresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cash_closuresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cash_closuresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cash_closuresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cash_closuresMaxAggregateInputType
  }

  export type GetCash_closuresAggregateType<T extends Cash_closuresAggregateArgs> = {
        [P in keyof T & keyof AggregateCash_closures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCash_closures[P]>
      : GetScalarType<T[P], AggregateCash_closures[P]>
  }




  export type cash_closuresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cash_closuresWhereInput
    orderBy?: cash_closuresOrderByWithAggregationInput | cash_closuresOrderByWithAggregationInput[]
    by: Cash_closuresScalarFieldEnum[] | Cash_closuresScalarFieldEnum
    having?: cash_closuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cash_closuresCountAggregateInputType | true
    _avg?: Cash_closuresAvgAggregateInputType
    _sum?: Cash_closuresSumAggregateInputType
    _min?: Cash_closuresMinAggregateInputType
    _max?: Cash_closuresMaxAggregateInputType
  }

  export type Cash_closuresGroupByOutputType = {
    id: string
    created_at: Date
    cash_closures: Date
    total_cash: number
    total_yappy: number
    total_card: number
    total_bank_transfer: number
    total_digital_wallet: number
    total_internal_wallet: number
    total_credits: number
    total_debits: number
    final_balance: number
    status: string
    _count: Cash_closuresCountAggregateOutputType | null
    _avg: Cash_closuresAvgAggregateOutputType | null
    _sum: Cash_closuresSumAggregateOutputType | null
    _min: Cash_closuresMinAggregateOutputType | null
    _max: Cash_closuresMaxAggregateOutputType | null
  }

  type GetCash_closuresGroupByPayload<T extends cash_closuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cash_closuresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cash_closuresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cash_closuresGroupByOutputType[P]>
            : GetScalarType<T[P], Cash_closuresGroupByOutputType[P]>
        }
      >
    >


  export type cash_closuresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    cash_closures?: boolean
    total_cash?: boolean
    total_yappy?: boolean
    total_card?: boolean
    total_bank_transfer?: boolean
    total_digital_wallet?: boolean
    total_internal_wallet?: boolean
    total_credits?: boolean
    total_debits?: boolean
    final_balance?: boolean
    status?: boolean
  }, ExtArgs["result"]["cash_closures"]>

  export type cash_closuresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    cash_closures?: boolean
    total_cash?: boolean
    total_yappy?: boolean
    total_card?: boolean
    total_bank_transfer?: boolean
    total_digital_wallet?: boolean
    total_internal_wallet?: boolean
    total_credits?: boolean
    total_debits?: boolean
    final_balance?: boolean
    status?: boolean
  }, ExtArgs["result"]["cash_closures"]>

  export type cash_closuresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    cash_closures?: boolean
    total_cash?: boolean
    total_yappy?: boolean
    total_card?: boolean
    total_bank_transfer?: boolean
    total_digital_wallet?: boolean
    total_internal_wallet?: boolean
    total_credits?: boolean
    total_debits?: boolean
    final_balance?: boolean
    status?: boolean
  }, ExtArgs["result"]["cash_closures"]>

  export type cash_closuresSelectScalar = {
    id?: boolean
    created_at?: boolean
    cash_closures?: boolean
    total_cash?: boolean
    total_yappy?: boolean
    total_card?: boolean
    total_bank_transfer?: boolean
    total_digital_wallet?: boolean
    total_internal_wallet?: boolean
    total_credits?: boolean
    total_debits?: boolean
    final_balance?: boolean
    status?: boolean
  }

  export type cash_closuresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "cash_closures" | "total_cash" | "total_yappy" | "total_card" | "total_bank_transfer" | "total_digital_wallet" | "total_internal_wallet" | "total_credits" | "total_debits" | "final_balance" | "status", ExtArgs["result"]["cash_closures"]>

  export type $cash_closuresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cash_closures"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      cash_closures: Date
      total_cash: number
      total_yappy: number
      total_card: number
      total_bank_transfer: number
      total_digital_wallet: number
      total_internal_wallet: number
      total_credits: number
      total_debits: number
      final_balance: number
      status: string
    }, ExtArgs["result"]["cash_closures"]>
    composites: {}
  }

  type cash_closuresGetPayload<S extends boolean | null | undefined | cash_closuresDefaultArgs> = $Result.GetResult<Prisma.$cash_closuresPayload, S>

  type cash_closuresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cash_closuresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cash_closuresCountAggregateInputType | true
    }

  export interface cash_closuresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cash_closures'], meta: { name: 'cash_closures' } }
    /**
     * Find zero or one Cash_closures that matches the filter.
     * @param {cash_closuresFindUniqueArgs} args - Arguments to find a Cash_closures
     * @example
     * // Get one Cash_closures
     * const cash_closures = await prisma.cash_closures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cash_closuresFindUniqueArgs>(args: SelectSubset<T, cash_closuresFindUniqueArgs<ExtArgs>>): Prisma__cash_closuresClient<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cash_closures that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cash_closuresFindUniqueOrThrowArgs} args - Arguments to find a Cash_closures
     * @example
     * // Get one Cash_closures
     * const cash_closures = await prisma.cash_closures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cash_closuresFindUniqueOrThrowArgs>(args: SelectSubset<T, cash_closuresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cash_closuresClient<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cash_closures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_closuresFindFirstArgs} args - Arguments to find a Cash_closures
     * @example
     * // Get one Cash_closures
     * const cash_closures = await prisma.cash_closures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cash_closuresFindFirstArgs>(args?: SelectSubset<T, cash_closuresFindFirstArgs<ExtArgs>>): Prisma__cash_closuresClient<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cash_closures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_closuresFindFirstOrThrowArgs} args - Arguments to find a Cash_closures
     * @example
     * // Get one Cash_closures
     * const cash_closures = await prisma.cash_closures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cash_closuresFindFirstOrThrowArgs>(args?: SelectSubset<T, cash_closuresFindFirstOrThrowArgs<ExtArgs>>): Prisma__cash_closuresClient<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cash_closures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_closuresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cash_closures
     * const cash_closures = await prisma.cash_closures.findMany()
     * 
     * // Get first 10 Cash_closures
     * const cash_closures = await prisma.cash_closures.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cash_closuresWithIdOnly = await prisma.cash_closures.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cash_closuresFindManyArgs>(args?: SelectSubset<T, cash_closuresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cash_closures.
     * @param {cash_closuresCreateArgs} args - Arguments to create a Cash_closures.
     * @example
     * // Create one Cash_closures
     * const Cash_closures = await prisma.cash_closures.create({
     *   data: {
     *     // ... data to create a Cash_closures
     *   }
     * })
     * 
     */
    create<T extends cash_closuresCreateArgs>(args: SelectSubset<T, cash_closuresCreateArgs<ExtArgs>>): Prisma__cash_closuresClient<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cash_closures.
     * @param {cash_closuresCreateManyArgs} args - Arguments to create many Cash_closures.
     * @example
     * // Create many Cash_closures
     * const cash_closures = await prisma.cash_closures.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cash_closuresCreateManyArgs>(args?: SelectSubset<T, cash_closuresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cash_closures and returns the data saved in the database.
     * @param {cash_closuresCreateManyAndReturnArgs} args - Arguments to create many Cash_closures.
     * @example
     * // Create many Cash_closures
     * const cash_closures = await prisma.cash_closures.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cash_closures and only return the `id`
     * const cash_closuresWithIdOnly = await prisma.cash_closures.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cash_closuresCreateManyAndReturnArgs>(args?: SelectSubset<T, cash_closuresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cash_closures.
     * @param {cash_closuresDeleteArgs} args - Arguments to delete one Cash_closures.
     * @example
     * // Delete one Cash_closures
     * const Cash_closures = await prisma.cash_closures.delete({
     *   where: {
     *     // ... filter to delete one Cash_closures
     *   }
     * })
     * 
     */
    delete<T extends cash_closuresDeleteArgs>(args: SelectSubset<T, cash_closuresDeleteArgs<ExtArgs>>): Prisma__cash_closuresClient<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cash_closures.
     * @param {cash_closuresUpdateArgs} args - Arguments to update one Cash_closures.
     * @example
     * // Update one Cash_closures
     * const cash_closures = await prisma.cash_closures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cash_closuresUpdateArgs>(args: SelectSubset<T, cash_closuresUpdateArgs<ExtArgs>>): Prisma__cash_closuresClient<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cash_closures.
     * @param {cash_closuresDeleteManyArgs} args - Arguments to filter Cash_closures to delete.
     * @example
     * // Delete a few Cash_closures
     * const { count } = await prisma.cash_closures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cash_closuresDeleteManyArgs>(args?: SelectSubset<T, cash_closuresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cash_closures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_closuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cash_closures
     * const cash_closures = await prisma.cash_closures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cash_closuresUpdateManyArgs>(args: SelectSubset<T, cash_closuresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cash_closures and returns the data updated in the database.
     * @param {cash_closuresUpdateManyAndReturnArgs} args - Arguments to update many Cash_closures.
     * @example
     * // Update many Cash_closures
     * const cash_closures = await prisma.cash_closures.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cash_closures and only return the `id`
     * const cash_closuresWithIdOnly = await prisma.cash_closures.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cash_closuresUpdateManyAndReturnArgs>(args: SelectSubset<T, cash_closuresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cash_closures.
     * @param {cash_closuresUpsertArgs} args - Arguments to update or create a Cash_closures.
     * @example
     * // Update or create a Cash_closures
     * const cash_closures = await prisma.cash_closures.upsert({
     *   create: {
     *     // ... data to create a Cash_closures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cash_closures we want to update
     *   }
     * })
     */
    upsert<T extends cash_closuresUpsertArgs>(args: SelectSubset<T, cash_closuresUpsertArgs<ExtArgs>>): Prisma__cash_closuresClient<$Result.GetResult<Prisma.$cash_closuresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cash_closures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_closuresCountArgs} args - Arguments to filter Cash_closures to count.
     * @example
     * // Count the number of Cash_closures
     * const count = await prisma.cash_closures.count({
     *   where: {
     *     // ... the filter for the Cash_closures we want to count
     *   }
     * })
    **/
    count<T extends cash_closuresCountArgs>(
      args?: Subset<T, cash_closuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cash_closuresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cash_closures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cash_closuresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cash_closuresAggregateArgs>(args: Subset<T, Cash_closuresAggregateArgs>): Prisma.PrismaPromise<GetCash_closuresAggregateType<T>>

    /**
     * Group by Cash_closures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_closuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cash_closuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cash_closuresGroupByArgs['orderBy'] }
        : { orderBy?: cash_closuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cash_closuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCash_closuresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cash_closures model
   */
  readonly fields: cash_closuresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cash_closures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cash_closuresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cash_closures model
   */ 
  interface cash_closuresFieldRefs {
    readonly id: FieldRef<"cash_closures", 'String'>
    readonly created_at: FieldRef<"cash_closures", 'DateTime'>
    readonly cash_closures: FieldRef<"cash_closures", 'DateTime'>
    readonly total_cash: FieldRef<"cash_closures", 'Float'>
    readonly total_yappy: FieldRef<"cash_closures", 'Float'>
    readonly total_card: FieldRef<"cash_closures", 'Float'>
    readonly total_bank_transfer: FieldRef<"cash_closures", 'Float'>
    readonly total_digital_wallet: FieldRef<"cash_closures", 'Float'>
    readonly total_internal_wallet: FieldRef<"cash_closures", 'Float'>
    readonly total_credits: FieldRef<"cash_closures", 'Float'>
    readonly total_debits: FieldRef<"cash_closures", 'Float'>
    readonly final_balance: FieldRef<"cash_closures", 'Float'>
    readonly status: FieldRef<"cash_closures", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cash_closures findUnique
   */
  export type cash_closuresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * Filter, which cash_closures to fetch.
     */
    where: cash_closuresWhereUniqueInput
  }

  /**
   * cash_closures findUniqueOrThrow
   */
  export type cash_closuresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * Filter, which cash_closures to fetch.
     */
    where: cash_closuresWhereUniqueInput
  }

  /**
   * cash_closures findFirst
   */
  export type cash_closuresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * Filter, which cash_closures to fetch.
     */
    where?: cash_closuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_closures to fetch.
     */
    orderBy?: cash_closuresOrderByWithRelationInput | cash_closuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cash_closures.
     */
    cursor?: cash_closuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_closures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_closures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cash_closures.
     */
    distinct?: Cash_closuresScalarFieldEnum | Cash_closuresScalarFieldEnum[]
  }

  /**
   * cash_closures findFirstOrThrow
   */
  export type cash_closuresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * Filter, which cash_closures to fetch.
     */
    where?: cash_closuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_closures to fetch.
     */
    orderBy?: cash_closuresOrderByWithRelationInput | cash_closuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cash_closures.
     */
    cursor?: cash_closuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_closures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_closures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cash_closures.
     */
    distinct?: Cash_closuresScalarFieldEnum | Cash_closuresScalarFieldEnum[]
  }

  /**
   * cash_closures findMany
   */
  export type cash_closuresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * Filter, which cash_closures to fetch.
     */
    where?: cash_closuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_closures to fetch.
     */
    orderBy?: cash_closuresOrderByWithRelationInput | cash_closuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cash_closures.
     */
    cursor?: cash_closuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_closures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_closures.
     */
    skip?: number
    distinct?: Cash_closuresScalarFieldEnum | Cash_closuresScalarFieldEnum[]
  }

  /**
   * cash_closures create
   */
  export type cash_closuresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * The data needed to create a cash_closures.
     */
    data: XOR<cash_closuresCreateInput, cash_closuresUncheckedCreateInput>
  }

  /**
   * cash_closures createMany
   */
  export type cash_closuresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cash_closures.
     */
    data: cash_closuresCreateManyInput | cash_closuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cash_closures createManyAndReturn
   */
  export type cash_closuresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * The data used to create many cash_closures.
     */
    data: cash_closuresCreateManyInput | cash_closuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cash_closures update
   */
  export type cash_closuresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * The data needed to update a cash_closures.
     */
    data: XOR<cash_closuresUpdateInput, cash_closuresUncheckedUpdateInput>
    /**
     * Choose, which cash_closures to update.
     */
    where: cash_closuresWhereUniqueInput
  }

  /**
   * cash_closures updateMany
   */
  export type cash_closuresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cash_closures.
     */
    data: XOR<cash_closuresUpdateManyMutationInput, cash_closuresUncheckedUpdateManyInput>
    /**
     * Filter which cash_closures to update
     */
    where?: cash_closuresWhereInput
    /**
     * Limit how many cash_closures to update.
     */
    limit?: number
  }

  /**
   * cash_closures updateManyAndReturn
   */
  export type cash_closuresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * The data used to update cash_closures.
     */
    data: XOR<cash_closuresUpdateManyMutationInput, cash_closuresUncheckedUpdateManyInput>
    /**
     * Filter which cash_closures to update
     */
    where?: cash_closuresWhereInput
    /**
     * Limit how many cash_closures to update.
     */
    limit?: number
  }

  /**
   * cash_closures upsert
   */
  export type cash_closuresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * The filter to search for the cash_closures to update in case it exists.
     */
    where: cash_closuresWhereUniqueInput
    /**
     * In case the cash_closures found by the `where` argument doesn't exist, create a new cash_closures with this data.
     */
    create: XOR<cash_closuresCreateInput, cash_closuresUncheckedCreateInput>
    /**
     * In case the cash_closures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cash_closuresUpdateInput, cash_closuresUncheckedUpdateInput>
  }

  /**
   * cash_closures delete
   */
  export type cash_closuresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
    /**
     * Filter which cash_closures to delete.
     */
    where: cash_closuresWhereUniqueInput
  }

  /**
   * cash_closures deleteMany
   */
  export type cash_closuresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cash_closures to delete
     */
    where?: cash_closuresWhereInput
    /**
     * Limit how many cash_closures to delete.
     */
    limit?: number
  }

  /**
   * cash_closures without action
   */
  export type cash_closuresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_closures
     */
    select?: cash_closuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cash_closures
     */
    omit?: cash_closuresOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActivitiesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    action: 'action',
    type: 'type',
    description: 'description',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    status: 'status',
    operator_id: 'operator_id',
    branch_id: 'branch_id',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    old_values: 'old_values',
    new_values: 'new_values',
    metadata: 'metadata'
  };

  export type ActivitiesScalarFieldEnum = (typeof ActivitiesScalarFieldEnum)[keyof typeof ActivitiesScalarFieldEnum]


  export const BranchesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    address: 'address',
    province: 'province',
    city: 'city',
    postal_code: 'postal_code',
    phone: 'phone',
    email: 'email',
    is_active: 'is_active',
    prefix: 'prefix',
    company_id: 'company_id',
    manager_name: 'manager_name',
    opening_hours: 'opening_hours',
    timezone: 'timezone'
  };

  export type BranchesScalarFieldEnum = (typeof BranchesScalarFieldEnum)[keyof typeof BranchesScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    description: 'description',
    icon: 'icon',
    is_active: 'is_active',
    order_position: 'order_position'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    email: 'email',
    phone: 'phone',
    ruc: 'ruc',
    logo_url: 'logo_url',
    website: 'website',
    tax_id: 'tax_id',
    business_type: 'business_type',
    industry: 'industry',
    founded_date: 'founded_date',
    is_active: 'is_active'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const Email_campaignsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    subject: 'subject',
    status: 'status',
    recipients: 'recipients',
    send_to_all: 'send_to_all',
    tracking: 'tracking',
    tracking_id: 'tracking_id',
    stats: 'stats',
    user_id: 'user_id',
    template_id: 'template_id',
    scheduled_for: 'scheduled_for',
    sender_name: 'sender_name',
    sender_email: 'sender_email',
    reply_to: 'reply_to',
    segment_criteria: 'segment_criteria',
    test_recipients: 'test_recipients',
    is_recurring: 'is_recurring',
    recurrence_pattern: 'recurrence_pattern'
  };

  export type Email_campaignsScalarFieldEnum = (typeof Email_campaignsScalarFieldEnum)[keyof typeof Email_campaignsScalarFieldEnum]


  export const Email_templatesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    subject: 'subject',
    body: 'body',
    html_body: 'html_body',
    elements: 'elements',
    editor_settings: 'editor_settings',
    thumbnail: 'thumbnail',
    operator_id: 'operator_id',
    category: 'category',
    variables: 'variables',
    is_default: 'is_default',
    version: 'version'
  };

  export type Email_templatesScalarFieldEnum = (typeof Email_templatesScalarFieldEnum)[keyof typeof Email_templatesScalarFieldEnum]


  export const Gift_cardsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    code: 'code',
    amount: 'amount',
    balance: 'balance',
    status: 'status',
    issue_date: 'issue_date',
    expiry_date: 'expiry_date',
    recipient_name: 'recipient_name',
    recipient_email: 'recipient_email',
    sender_id: 'sender_id',
    redeemed_at: 'redeemed_at',
    message: 'message',
    payment_method: 'payment_method',
    send_date: 'send_date',
    design_template: 'design_template',
    branch_id: 'branch_id',
    is_reloadable: 'is_reloadable',
    access_pin: 'access_pin',
    usage_history: 'usage_history'
  };

  export type Gift_cardsScalarFieldEnum = (typeof Gift_cardsScalarFieldEnum)[keyof typeof Gift_cardsScalarFieldEnum]


  export const Invoice_itemsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    invoice_id: 'invoice_id',
    product_id: 'product_id',
    plan_id: 'plan_id',
    description: 'description',
    quantity: 'quantity',
    unit_price: 'unit_price',
    total_price: 'total_price',
    discount_rate: 'discount_rate',
    tax_rate: 'tax_rate',
    item_order: 'item_order',
    unit_of_measure: 'unit_of_measure',
    is_taxable: 'is_taxable',
    serial_numbers: 'serial_numbers'
  };

  export type Invoice_itemsScalarFieldEnum = (typeof Invoice_itemsScalarFieldEnum)[keyof typeof Invoice_itemsScalarFieldEnum]


  export const Invoice_packagesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    invoice_id: 'invoice_id',
    package_id: 'package_id'
  };

  export type Invoice_packagesScalarFieldEnum = (typeof Invoice_packagesScalarFieldEnum)[keyof typeof Invoice_packagesScalarFieldEnum]


  export const InvoicesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    invoice_number: 'invoice_number',
    issue_date: 'issue_date',
    due_date: 'due_date',
    status: 'status',
    is_paid: 'is_paid',
    total_amount: 'total_amount',
    tax_amount: 'tax_amount',
    discount_amount: 'discount_amount',
    user_id: 'user_id',
    branch_id: 'branch_id',
    operator_id: 'operator_id',
    billing_address: 'billing_address',
    shipping_address: 'shipping_address',
    notes: 'notes',
    payment_terms: 'payment_terms',
    currency: 'currency',
    conversion_rate: 'conversion_rate',
    tracking_number: 'tracking_number',
    shipping_method: 'shipping_method',
    invoice_type: 'invoice_type',
    commission_amount: 'commission_amount',
    marketplace_fee_rate: 'marketplace_fee_rate',
    platform: 'platform',
    external_reference_id: 'external_reference_id',
    tax_details: 'tax_details',
    price_plan: 'price_plan',
    shipping_insurance: 'shipping_insurance',
    paid_amount: 'paid_amount',
    remaining_amount: 'remaining_amount',
    last_payment_date: 'last_payment_date'
  };

  export type InvoicesScalarFieldEnum = (typeof InvoicesScalarFieldEnum)[keyof typeof InvoicesScalarFieldEnum]


  export const Notification_preferencesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    push_enabled: 'push_enabled',
    email_enabled: 'email_enabled',
    sms_enabled: 'sms_enabled',
    news_and_updates: 'news_and_updates',
    order_updates: 'order_updates',
    promotions: 'promotions',
    security_alerts: 'security_alerts',
    quiet_hours_start: 'quiet_hours_start',
    quiet_hours_end: 'quiet_hours_end',
    quiet_hours_enabled: 'quiet_hours_enabled',
    frequency: 'frequency'
  };

  export type Notification_preferencesScalarFieldEnum = (typeof Notification_preferencesScalarFieldEnum)[keyof typeof Notification_preferencesScalarFieldEnum]


  export const Notification_usersScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    title: 'title',
    message: 'message',
    type: 'type',
    is_read: 'is_read',
    is_deleted: 'is_deleted',
    user_id: 'user_id',
    data: 'data',
    priority: 'priority',
    action_url: 'action_url',
    icon: 'icon',
    expiry_date: 'expiry_date',
    requires_action: 'requires_action'
  };

  export type Notification_usersScalarFieldEnum = (typeof Notification_usersScalarFieldEnum)[keyof typeof Notification_usersScalarFieldEnum]


  export const Notifications_operatorScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    title: 'title',
    message: 'message',
    is_read: 'is_read',
    operator_id: 'operator_id',
    data: 'data',
    notification_type: 'notification_type',
    priority: 'priority',
    action_required: 'action_required',
    action_type: 'action_type',
    action_data: 'action_data',
    expiry_date: 'expiry_date'
  };

  export type Notifications_operatorScalarFieldEnum = (typeof Notifications_operatorScalarFieldEnum)[keyof typeof Notifications_operatorScalarFieldEnum]


  export const Operator_typesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    description: 'description',
    permissions: 'permissions'
  };

  export type Operator_typesScalarFieldEnum = (typeof Operator_typesScalarFieldEnum)[keyof typeof Operator_typesScalarFieldEnum]


  export const OperatorsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    email: 'email',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    phone: 'phone',
    photo: 'photo',
    role: 'role',
    status: 'status',
    last_login_at: 'last_login_at',
    branch_id: 'branch_id',
    type_operator_id: 'type_operator_id',
    position: 'position',
    hire_date: 'hire_date',
    birth_date: 'birth_date',
    emergency_contact: 'emergency_contact',
    skills: 'skills',
    personal_id: 'personal_id',
    address: 'address'
  };

  export type OperatorsScalarFieldEnum = (typeof OperatorsScalarFieldEnum)[keyof typeof OperatorsScalarFieldEnum]


  export const PackagesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_reference: 'user_reference',
    package_status: 'package_status',
    tracking_number: 'tracking_number',
    height: 'height',
    width: 'width',
    length: 'length',
    weight: 'weight',
    volumetric_weight: 'volumetric_weight',
    insurance: 'insurance',
    shipping_stages: 'shipping_stages',
    branch_id: 'branch_id',
    notes: 'notes',
    declared_value: 'declared_value',
    customs_information: 'customs_information',
    is_fragile: 'is_fragile',
    estimated_delivery_date: 'estimated_delivery_date',
    operator_id: 'operator_id',
    position: 'position'
  };

  export type PackagesScalarFieldEnum = (typeof PackagesScalarFieldEnum)[keyof typeof PackagesScalarFieldEnum]


  export const Payment_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    is_active: 'is_active',
    processing_fee_percentage: 'processing_fee_percentage',
    processing_fee_fixed: 'processing_fee_fixed',
    requires_approval: 'requires_approval',
    icon: 'icon'
  };

  export type Payment_typesScalarFieldEnum = (typeof Payment_typesScalarFieldEnum)[keyof typeof Payment_typesScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    invoice_id: 'invoice_id',
    amount: 'amount',
    payment_date: 'payment_date',
    payment_method: 'payment_method',
    status: 'status',
    payment_provider: 'payment_provider',
    currency: 'currency',
    exchange_rate: 'exchange_rate',
    fees: 'fees',
    payer_details: 'payer_details',
    receipt_url: 'receipt_url',
    notes: 'notes',
    transaction_id: 'transaction_id',
    payment_method_id: 'payment_method_id'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const Plan_addressesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    plan_id: 'plan_id',
    address_type: 'address_type',
    address_line1: 'address_line1',
    address_line2: 'address_line2',
    city: 'city',
    state: 'state',
    country: 'country',
    postal_code: 'postal_code',
    contact_name: 'contact_name',
    contact_phone: 'contact_phone',
    is_primary: 'is_primary',
    additional_info: 'additional_info'
  };

  export type Plan_addressesScalarFieldEnum = (typeof Plan_addressesScalarFieldEnum)[keyof typeof Plan_addressesScalarFieldEnum]


  export const Plan_featuresScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    plan_id: 'plan_id',
    feature_name: 'feature_name',
    feature_value: 'feature_value',
    is_included: 'is_included',
    limit_quantity: 'limit_quantity',
    description: 'description'
  };

  export type Plan_featuresScalarFieldEnum = (typeof Plan_featuresScalarFieldEnum)[keyof typeof Plan_featuresScalarFieldEnum]


  export const PlansScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    description: 'description',
    price: 'price',
    billing_cycle: 'billing_cycle',
    color: 'color',
    is_active: 'is_active',
    branch_id: 'branch_id',
    trial_period_days: 'trial_period_days',
    setup_fee: 'setup_fee',
    max_users: 'max_users',
    discounts: 'discounts'
  };

  export type PlansScalarFieldEnum = (typeof PlansScalarFieldEnum)[keyof typeof PlansScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    description: 'description',
    price: 'price',
    sale_price: 'sale_price',
    sku: 'sku',
    barcode: 'barcode',
    stock_quantity: 'stock_quantity',
    is_active: 'is_active',
    status: 'status',
    category_id: 'category_id',
    branch_id: 'branch_id',
    weight: 'weight',
    dimensions: 'dimensions',
    images: 'images',
    tags: 'tags',
    min_stock_alert: 'min_stock_alert',
    manufacturer: 'manufacturer',
    tax_rate: 'tax_rate'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const Type_usersScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    code: 'code',
    description: 'description',
    name: 'name',
    permissions: 'permissions'
  };

  export type Type_usersScalarFieldEnum = (typeof Type_usersScalarFieldEnum)[keyof typeof Type_usersScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    account_status: 'account_status',
    birth_date: 'birth_date',
    branch_id: 'branch_id',
    email: 'email',
    first_name: 'first_name',
    is_email_verified: 'is_email_verified',
    is_online: 'is_online',
    is_verified: 'is_verified',
    last_name: 'last_name',
    last_seen: 'last_seen',
    phone: 'phone',
    photo_url: 'photo_url',
    plan_id: 'plan_id',
    type_user_id: 'type_user_id',
    shipping_insurance: 'shipping_insurance',
    is_business: 'is_business',
    ruc: 'ruc',
    company_name: 'company_name',
    referral_source_id: 'referral_source_id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VehiclesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    make: 'make',
    model: 'model',
    year: 'year',
    license_plate: 'license_plate',
    status: 'status',
    branch_id: 'branch_id',
    color: 'color',
    vin: 'vin',
    purchase_date: 'purchase_date',
    last_maintenance_date: 'last_maintenance_date',
    mileage: 'mileage',
    fuel_type: 'fuel_type',
    insurance_info: 'insurance_info',
    technical_specs: 'technical_specs'
  };

  export type VehiclesScalarFieldEnum = (typeof VehiclesScalarFieldEnum)[keyof typeof VehiclesScalarFieldEnum]


  export const WalletsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    balance: 'balance',
    currency: 'currency',
    is_active: 'is_active',
    last_transaction_date: 'last_transaction_date',
    user_id: 'user_id'
  };

  export type WalletsScalarFieldEnum = (typeof WalletsScalarFieldEnum)[keyof typeof WalletsScalarFieldEnum]


  export const Saved_cardsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    card_token: 'card_token',
    card_type: 'card_type',
    cardholder_name: 'cardholder_name',
    expiry_month: 'expiry_month',
    expiry_year: 'expiry_year',
    brand: 'brand',
    last_four_digits: 'last_four_digits',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at',
    nick_name: 'nick_name'
  };

  export type Saved_cardsScalarFieldEnum = (typeof Saved_cardsScalarFieldEnum)[keyof typeof Saved_cardsScalarFieldEnum]


  export const Payment_methodsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    is_active: 'is_active',
    details: 'details',
    payment_type_id: 'payment_type_id'
  };

  export type Payment_methodsScalarFieldEnum = (typeof Payment_methodsScalarFieldEnum)[keyof typeof Payment_methodsScalarFieldEnum]


  export const Transaction_categoriesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    description: 'description',
    parent_id: 'parent_id',
    is_active: 'is_active'
  };

  export type Transaction_categoriesScalarFieldEnum = (typeof Transaction_categoriesScalarFieldEnum)[keyof typeof Transaction_categoriesScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    description: 'description',
    status: 'status',
    transaction_date: 'transaction_date',
    transaction_type: 'transaction_type',
    reference_id: 'reference_id',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    payment_method_id: 'payment_method_id',
    metadata: 'metadata',
    category_id: 'category_id',
    transaction_type_id: 'transaction_type_id',
    amount: 'amount'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const Transaction_typesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    code: 'code',
    name: 'name',
    description: 'description',
    affects_balance: 'affects_balance',
    is_active: 'is_active'
  };

  export type Transaction_typesScalarFieldEnum = (typeof Transaction_typesScalarFieldEnum)[keyof typeof Transaction_typesScalarFieldEnum]


  export const Referral_sourcesScalarFieldEnum: {
    id: 'id',
    source_name: 'source_name'
  };

  export type Referral_sourcesScalarFieldEnum = (typeof Referral_sourcesScalarFieldEnum)[keyof typeof Referral_sourcesScalarFieldEnum]


  export const Cash_closuresScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    cash_closures: 'cash_closures',
    total_cash: 'total_cash',
    total_yappy: 'total_yappy',
    total_card: 'total_card',
    total_bank_transfer: 'total_bank_transfer',
    total_digital_wallet: 'total_digital_wallet',
    total_internal_wallet: 'total_internal_wallet',
    total_credits: 'total_credits',
    total_debits: 'total_debits',
    final_balance: 'final_balance',
    status: 'status'
  };

  export type Cash_closuresScalarFieldEnum = (typeof Cash_closuresScalarFieldEnum)[keyof typeof Cash_closuresScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'activity_type_enum'
   */
  export type Enumactivity_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'activity_type_enum'>
    


  /**
   * Reference to a field of type 'activity_type_enum[]'
   */
  export type ListEnumactivity_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'activity_type_enum[]'>
    


  /**
   * Reference to a field of type 'activity_status_enum'
   */
  export type Enumactivity_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'activity_status_enum'>
    


  /**
   * Reference to a field of type 'activity_status_enum[]'
   */
  export type ListEnumactivity_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'activity_status_enum[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'payment_method_enum'
   */
  export type Enumpayment_method_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_method_enum'>
    


  /**
   * Reference to a field of type 'payment_method_enum[]'
   */
  export type ListEnumpayment_method_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_method_enum[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'invoice_status_enum'
   */
  export type Enuminvoice_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'invoice_status_enum'>
    


  /**
   * Reference to a field of type 'invoice_status_enum[]'
   */
  export type ListEnuminvoice_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'invoice_status_enum[]'>
    


  /**
   * Reference to a field of type 'invoice_type_enum'
   */
  export type Enuminvoice_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'invoice_type_enum'>
    


  /**
   * Reference to a field of type 'invoice_type_enum[]'
   */
  export type ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'invoice_type_enum[]'>
    


  /**
   * Reference to a field of type 'operator_role_enum'
   */
  export type Enumoperator_role_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'operator_role_enum'>
    


  /**
   * Reference to a field of type 'operator_role_enum[]'
   */
  export type ListEnumoperator_role_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'operator_role_enum[]'>
    


  /**
   * Reference to a field of type 'operator_status_enum'
   */
  export type Enumoperator_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'operator_status_enum'>
    


  /**
   * Reference to a field of type 'operator_status_enum[]'
   */
  export type ListEnumoperator_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'operator_status_enum[]'>
    


  /**
   * Reference to a field of type 'package_status_enum'
   */
  export type Enumpackage_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'package_status_enum'>
    


  /**
   * Reference to a field of type 'package_status_enum[]'
   */
  export type ListEnumpackage_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'package_status_enum[]'>
    


  /**
   * Reference to a field of type 'payment_status_enum'
   */
  export type Enumpayment_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_status_enum'>
    


  /**
   * Reference to a field of type 'payment_status_enum[]'
   */
  export type ListEnumpayment_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_status_enum[]'>
    


  /**
   * Reference to a field of type 'product_status_enum'
   */
  export type Enumproduct_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'product_status_enum'>
    


  /**
   * Reference to a field of type 'product_status_enum[]'
   */
  export type ListEnumproduct_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'product_status_enum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type activitiesWhereInput = {
    AND?: activitiesWhereInput | activitiesWhereInput[]
    OR?: activitiesWhereInput[]
    NOT?: activitiesWhereInput | activitiesWhereInput[]
    id?: UuidFilter<"activities"> | string
    created_at?: DateTimeFilter<"activities"> | Date | string
    action?: StringFilter<"activities"> | string
    type?: Enumactivity_type_enumFilter<"activities"> | $Enums.activity_type_enum
    description?: StringNullableFilter<"activities"> | string | null
    ip_address?: StringNullableFilter<"activities"> | string | null
    user_agent?: StringNullableFilter<"activities"> | string | null
    status?: Enumactivity_status_enumNullableFilter<"activities"> | $Enums.activity_status_enum | null
    operator_id?: UuidNullableFilter<"activities"> | string | null
    branch_id?: UuidNullableFilter<"activities"> | string | null
    entity_type?: StringNullableFilter<"activities"> | string | null
    entity_id?: UuidNullableFilter<"activities"> | string | null
    old_values?: JsonNullableFilter<"activities">
    new_values?: JsonNullableFilter<"activities">
    metadata?: JsonNullableFilter<"activities">
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    operators?: XOR<OperatorsNullableScalarRelationFilter, operatorsWhereInput> | null
  }

  export type activitiesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    action?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    entity_id?: SortOrderInput | SortOrder
    old_values?: SortOrderInput | SortOrder
    new_values?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    branches?: branchesOrderByWithRelationInput
    operators?: operatorsOrderByWithRelationInput
  }

  export type activitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: activitiesWhereInput | activitiesWhereInput[]
    OR?: activitiesWhereInput[]
    NOT?: activitiesWhereInput | activitiesWhereInput[]
    created_at?: DateTimeFilter<"activities"> | Date | string
    action?: StringFilter<"activities"> | string
    type?: Enumactivity_type_enumFilter<"activities"> | $Enums.activity_type_enum
    description?: StringNullableFilter<"activities"> | string | null
    ip_address?: StringNullableFilter<"activities"> | string | null
    user_agent?: StringNullableFilter<"activities"> | string | null
    status?: Enumactivity_status_enumNullableFilter<"activities"> | $Enums.activity_status_enum | null
    operator_id?: UuidNullableFilter<"activities"> | string | null
    branch_id?: UuidNullableFilter<"activities"> | string | null
    entity_type?: StringNullableFilter<"activities"> | string | null
    entity_id?: UuidNullableFilter<"activities"> | string | null
    old_values?: JsonNullableFilter<"activities">
    new_values?: JsonNullableFilter<"activities">
    metadata?: JsonNullableFilter<"activities">
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    operators?: XOR<OperatorsNullableScalarRelationFilter, operatorsWhereInput> | null
  }, "id">

  export type activitiesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    action?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    entity_id?: SortOrderInput | SortOrder
    old_values?: SortOrderInput | SortOrder
    new_values?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: activitiesCountOrderByAggregateInput
    _max?: activitiesMaxOrderByAggregateInput
    _min?: activitiesMinOrderByAggregateInput
  }

  export type activitiesScalarWhereWithAggregatesInput = {
    AND?: activitiesScalarWhereWithAggregatesInput | activitiesScalarWhereWithAggregatesInput[]
    OR?: activitiesScalarWhereWithAggregatesInput[]
    NOT?: activitiesScalarWhereWithAggregatesInput | activitiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"activities"> | string
    created_at?: DateTimeWithAggregatesFilter<"activities"> | Date | string
    action?: StringWithAggregatesFilter<"activities"> | string
    type?: Enumactivity_type_enumWithAggregatesFilter<"activities"> | $Enums.activity_type_enum
    description?: StringNullableWithAggregatesFilter<"activities"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"activities"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"activities"> | string | null
    status?: Enumactivity_status_enumNullableWithAggregatesFilter<"activities"> | $Enums.activity_status_enum | null
    operator_id?: UuidNullableWithAggregatesFilter<"activities"> | string | null
    branch_id?: UuidNullableWithAggregatesFilter<"activities"> | string | null
    entity_type?: StringNullableWithAggregatesFilter<"activities"> | string | null
    entity_id?: UuidNullableWithAggregatesFilter<"activities"> | string | null
    old_values?: JsonNullableWithAggregatesFilter<"activities">
    new_values?: JsonNullableWithAggregatesFilter<"activities">
    metadata?: JsonNullableWithAggregatesFilter<"activities">
  }

  export type branchesWhereInput = {
    AND?: branchesWhereInput | branchesWhereInput[]
    OR?: branchesWhereInput[]
    NOT?: branchesWhereInput | branchesWhereInput[]
    id?: UuidFilter<"branches"> | string
    created_at?: DateTimeFilter<"branches"> | Date | string
    updated_at?: DateTimeNullableFilter<"branches"> | Date | string | null
    name?: StringFilter<"branches"> | string
    address?: StringNullableFilter<"branches"> | string | null
    province?: StringNullableFilter<"branches"> | string | null
    city?: StringNullableFilter<"branches"> | string | null
    postal_code?: StringNullableFilter<"branches"> | string | null
    phone?: StringNullableFilter<"branches"> | string | null
    email?: StringNullableFilter<"branches"> | string | null
    is_active?: BoolNullableFilter<"branches"> | boolean | null
    prefix?: StringNullableFilter<"branches"> | string | null
    company_id?: UuidFilter<"branches"> | string
    manager_name?: StringNullableFilter<"branches"> | string | null
    opening_hours?: JsonNullableFilter<"branches">
    timezone?: StringNullableFilter<"branches"> | string | null
    activities?: ActivitiesListRelationFilter
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    gift_cards?: Gift_cardsListRelationFilter
    invoices?: InvoicesListRelationFilter
    operators?: OperatorsListRelationFilter
    packages?: PackagesListRelationFilter
    plans?: PlansListRelationFilter
    products?: ProductsListRelationFilter
    users?: UsersListRelationFilter
    vehicles?: VehiclesListRelationFilter
  }

  export type branchesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    prefix?: SortOrderInput | SortOrder
    company_id?: SortOrder
    manager_name?: SortOrderInput | SortOrder
    opening_hours?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    activities?: activitiesOrderByRelationAggregateInput
    companies?: companiesOrderByWithRelationInput
    gift_cards?: gift_cardsOrderByRelationAggregateInput
    invoices?: invoicesOrderByRelationAggregateInput
    operators?: operatorsOrderByRelationAggregateInput
    packages?: packagesOrderByRelationAggregateInput
    plans?: plansOrderByRelationAggregateInput
    products?: productsOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    vehicles?: vehiclesOrderByRelationAggregateInput
  }

  export type branchesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: branchesWhereInput | branchesWhereInput[]
    OR?: branchesWhereInput[]
    NOT?: branchesWhereInput | branchesWhereInput[]
    created_at?: DateTimeFilter<"branches"> | Date | string
    updated_at?: DateTimeNullableFilter<"branches"> | Date | string | null
    name?: StringFilter<"branches"> | string
    address?: StringNullableFilter<"branches"> | string | null
    province?: StringNullableFilter<"branches"> | string | null
    city?: StringNullableFilter<"branches"> | string | null
    postal_code?: StringNullableFilter<"branches"> | string | null
    phone?: StringNullableFilter<"branches"> | string | null
    email?: StringNullableFilter<"branches"> | string | null
    is_active?: BoolNullableFilter<"branches"> | boolean | null
    prefix?: StringNullableFilter<"branches"> | string | null
    company_id?: UuidFilter<"branches"> | string
    manager_name?: StringNullableFilter<"branches"> | string | null
    opening_hours?: JsonNullableFilter<"branches">
    timezone?: StringNullableFilter<"branches"> | string | null
    activities?: ActivitiesListRelationFilter
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    gift_cards?: Gift_cardsListRelationFilter
    invoices?: InvoicesListRelationFilter
    operators?: OperatorsListRelationFilter
    packages?: PackagesListRelationFilter
    plans?: PlansListRelationFilter
    products?: ProductsListRelationFilter
    users?: UsersListRelationFilter
    vehicles?: VehiclesListRelationFilter
  }, "id">

  export type branchesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    prefix?: SortOrderInput | SortOrder
    company_id?: SortOrder
    manager_name?: SortOrderInput | SortOrder
    opening_hours?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    _count?: branchesCountOrderByAggregateInput
    _max?: branchesMaxOrderByAggregateInput
    _min?: branchesMinOrderByAggregateInput
  }

  export type branchesScalarWhereWithAggregatesInput = {
    AND?: branchesScalarWhereWithAggregatesInput | branchesScalarWhereWithAggregatesInput[]
    OR?: branchesScalarWhereWithAggregatesInput[]
    NOT?: branchesScalarWhereWithAggregatesInput | branchesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"branches"> | string
    created_at?: DateTimeWithAggregatesFilter<"branches"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"branches"> | Date | string | null
    name?: StringWithAggregatesFilter<"branches"> | string
    address?: StringNullableWithAggregatesFilter<"branches"> | string | null
    province?: StringNullableWithAggregatesFilter<"branches"> | string | null
    city?: StringNullableWithAggregatesFilter<"branches"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"branches"> | string | null
    phone?: StringNullableWithAggregatesFilter<"branches"> | string | null
    email?: StringNullableWithAggregatesFilter<"branches"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"branches"> | boolean | null
    prefix?: StringNullableWithAggregatesFilter<"branches"> | string | null
    company_id?: UuidWithAggregatesFilter<"branches"> | string
    manager_name?: StringNullableWithAggregatesFilter<"branches"> | string | null
    opening_hours?: JsonNullableWithAggregatesFilter<"branches">
    timezone?: StringNullableWithAggregatesFilter<"branches"> | string | null
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: UuidFilter<"categories"> | string
    created_at?: DateTimeFilter<"categories"> | Date | string
    updated_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    name?: StringFilter<"categories"> | string
    description?: StringNullableFilter<"categories"> | string | null
    icon?: StringNullableFilter<"categories"> | string | null
    is_active?: BoolNullableFilter<"categories"> | boolean | null
    order_position?: IntNullableFilter<"categories"> | number | null
    products?: ProductsListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    order_position?: SortOrderInput | SortOrder
    products?: productsOrderByRelationAggregateInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    created_at?: DateTimeFilter<"categories"> | Date | string
    updated_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    name?: StringFilter<"categories"> | string
    description?: StringNullableFilter<"categories"> | string | null
    icon?: StringNullableFilter<"categories"> | string | null
    is_active?: BoolNullableFilter<"categories"> | boolean | null
    order_position?: IntNullableFilter<"categories"> | number | null
    products?: ProductsListRelationFilter
  }, "id">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    order_position?: SortOrderInput | SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _avg?: categoriesAvgOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
    _sum?: categoriesSumOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"categories"> | string
    created_at?: DateTimeWithAggregatesFilter<"categories"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"categories"> | Date | string | null
    name?: StringWithAggregatesFilter<"categories"> | string
    description?: StringNullableWithAggregatesFilter<"categories"> | string | null
    icon?: StringNullableWithAggregatesFilter<"categories"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"categories"> | boolean | null
    order_position?: IntNullableWithAggregatesFilter<"categories"> | number | null
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: UuidFilter<"companies"> | string
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    name?: StringFilter<"companies"> | string
    email?: StringNullableFilter<"companies"> | string | null
    phone?: StringNullableFilter<"companies"> | string | null
    ruc?: StringNullableFilter<"companies"> | string | null
    logo_url?: StringNullableFilter<"companies"> | string | null
    website?: StringNullableFilter<"companies"> | string | null
    tax_id?: StringNullableFilter<"companies"> | string | null
    business_type?: StringNullableFilter<"companies"> | string | null
    industry?: StringNullableFilter<"companies"> | string | null
    founded_date?: DateTimeNullableFilter<"companies"> | Date | string | null
    is_active?: BoolNullableFilter<"companies"> | boolean | null
    branches?: BranchesListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    ruc?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    business_type?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    founded_date?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    branches?: branchesOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ruc?: string
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    name?: StringFilter<"companies"> | string
    email?: StringNullableFilter<"companies"> | string | null
    phone?: StringNullableFilter<"companies"> | string | null
    logo_url?: StringNullableFilter<"companies"> | string | null
    website?: StringNullableFilter<"companies"> | string | null
    tax_id?: StringNullableFilter<"companies"> | string | null
    business_type?: StringNullableFilter<"companies"> | string | null
    industry?: StringNullableFilter<"companies"> | string | null
    founded_date?: DateTimeNullableFilter<"companies"> | Date | string | null
    is_active?: BoolNullableFilter<"companies"> | boolean | null
    branches?: BranchesListRelationFilter
  }, "id" | "ruc">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    ruc?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    business_type?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    founded_date?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: companiesCountOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"companies"> | string
    created_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
    name?: StringWithAggregatesFilter<"companies"> | string
    email?: StringNullableWithAggregatesFilter<"companies"> | string | null
    phone?: StringNullableWithAggregatesFilter<"companies"> | string | null
    ruc?: StringNullableWithAggregatesFilter<"companies"> | string | null
    logo_url?: StringNullableWithAggregatesFilter<"companies"> | string | null
    website?: StringNullableWithAggregatesFilter<"companies"> | string | null
    tax_id?: StringNullableWithAggregatesFilter<"companies"> | string | null
    business_type?: StringNullableWithAggregatesFilter<"companies"> | string | null
    industry?: StringNullableWithAggregatesFilter<"companies"> | string | null
    founded_date?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
    is_active?: BoolNullableWithAggregatesFilter<"companies"> | boolean | null
  }

  export type email_campaignsWhereInput = {
    AND?: email_campaignsWhereInput | email_campaignsWhereInput[]
    OR?: email_campaignsWhereInput[]
    NOT?: email_campaignsWhereInput | email_campaignsWhereInput[]
    id?: UuidFilter<"email_campaigns"> | string
    created_at?: DateTimeFilter<"email_campaigns"> | Date | string
    updated_at?: DateTimeNullableFilter<"email_campaigns"> | Date | string | null
    name?: StringFilter<"email_campaigns"> | string
    subject?: StringFilter<"email_campaigns"> | string
    status?: StringFilter<"email_campaigns"> | string
    recipients?: JsonNullableFilter<"email_campaigns">
    send_to_all?: BoolNullableFilter<"email_campaigns"> | boolean | null
    tracking?: BoolNullableFilter<"email_campaigns"> | boolean | null
    tracking_id?: UuidNullableFilter<"email_campaigns"> | string | null
    stats?: JsonNullableFilter<"email_campaigns">
    user_id?: UuidNullableFilter<"email_campaigns"> | string | null
    template_id?: UuidNullableFilter<"email_campaigns"> | string | null
    scheduled_for?: DateTimeNullableFilter<"email_campaigns"> | Date | string | null
    sender_name?: StringNullableFilter<"email_campaigns"> | string | null
    sender_email?: StringNullableFilter<"email_campaigns"> | string | null
    reply_to?: StringNullableFilter<"email_campaigns"> | string | null
    segment_criteria?: JsonNullableFilter<"email_campaigns">
    test_recipients?: StringNullableListFilter<"email_campaigns">
    is_recurring?: BoolNullableFilter<"email_campaigns"> | boolean | null
    recurrence_pattern?: JsonNullableFilter<"email_campaigns">
    email_templates?: XOR<Email_templatesNullableScalarRelationFilter, email_templatesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type email_campaignsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    recipients?: SortOrderInput | SortOrder
    send_to_all?: SortOrderInput | SortOrder
    tracking?: SortOrderInput | SortOrder
    tracking_id?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    template_id?: SortOrderInput | SortOrder
    scheduled_for?: SortOrderInput | SortOrder
    sender_name?: SortOrderInput | SortOrder
    sender_email?: SortOrderInput | SortOrder
    reply_to?: SortOrderInput | SortOrder
    segment_criteria?: SortOrderInput | SortOrder
    test_recipients?: SortOrder
    is_recurring?: SortOrderInput | SortOrder
    recurrence_pattern?: SortOrderInput | SortOrder
    email_templates?: email_templatesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type email_campaignsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: email_campaignsWhereInput | email_campaignsWhereInput[]
    OR?: email_campaignsWhereInput[]
    NOT?: email_campaignsWhereInput | email_campaignsWhereInput[]
    created_at?: DateTimeFilter<"email_campaigns"> | Date | string
    updated_at?: DateTimeNullableFilter<"email_campaigns"> | Date | string | null
    name?: StringFilter<"email_campaigns"> | string
    subject?: StringFilter<"email_campaigns"> | string
    status?: StringFilter<"email_campaigns"> | string
    recipients?: JsonNullableFilter<"email_campaigns">
    send_to_all?: BoolNullableFilter<"email_campaigns"> | boolean | null
    tracking?: BoolNullableFilter<"email_campaigns"> | boolean | null
    tracking_id?: UuidNullableFilter<"email_campaigns"> | string | null
    stats?: JsonNullableFilter<"email_campaigns">
    user_id?: UuidNullableFilter<"email_campaigns"> | string | null
    template_id?: UuidNullableFilter<"email_campaigns"> | string | null
    scheduled_for?: DateTimeNullableFilter<"email_campaigns"> | Date | string | null
    sender_name?: StringNullableFilter<"email_campaigns"> | string | null
    sender_email?: StringNullableFilter<"email_campaigns"> | string | null
    reply_to?: StringNullableFilter<"email_campaigns"> | string | null
    segment_criteria?: JsonNullableFilter<"email_campaigns">
    test_recipients?: StringNullableListFilter<"email_campaigns">
    is_recurring?: BoolNullableFilter<"email_campaigns"> | boolean | null
    recurrence_pattern?: JsonNullableFilter<"email_campaigns">
    email_templates?: XOR<Email_templatesNullableScalarRelationFilter, email_templatesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type email_campaignsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    recipients?: SortOrderInput | SortOrder
    send_to_all?: SortOrderInput | SortOrder
    tracking?: SortOrderInput | SortOrder
    tracking_id?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    template_id?: SortOrderInput | SortOrder
    scheduled_for?: SortOrderInput | SortOrder
    sender_name?: SortOrderInput | SortOrder
    sender_email?: SortOrderInput | SortOrder
    reply_to?: SortOrderInput | SortOrder
    segment_criteria?: SortOrderInput | SortOrder
    test_recipients?: SortOrder
    is_recurring?: SortOrderInput | SortOrder
    recurrence_pattern?: SortOrderInput | SortOrder
    _count?: email_campaignsCountOrderByAggregateInput
    _max?: email_campaignsMaxOrderByAggregateInput
    _min?: email_campaignsMinOrderByAggregateInput
  }

  export type email_campaignsScalarWhereWithAggregatesInput = {
    AND?: email_campaignsScalarWhereWithAggregatesInput | email_campaignsScalarWhereWithAggregatesInput[]
    OR?: email_campaignsScalarWhereWithAggregatesInput[]
    NOT?: email_campaignsScalarWhereWithAggregatesInput | email_campaignsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"email_campaigns"> | string
    created_at?: DateTimeWithAggregatesFilter<"email_campaigns"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"email_campaigns"> | Date | string | null
    name?: StringWithAggregatesFilter<"email_campaigns"> | string
    subject?: StringWithAggregatesFilter<"email_campaigns"> | string
    status?: StringWithAggregatesFilter<"email_campaigns"> | string
    recipients?: JsonNullableWithAggregatesFilter<"email_campaigns">
    send_to_all?: BoolNullableWithAggregatesFilter<"email_campaigns"> | boolean | null
    tracking?: BoolNullableWithAggregatesFilter<"email_campaigns"> | boolean | null
    tracking_id?: UuidNullableWithAggregatesFilter<"email_campaigns"> | string | null
    stats?: JsonNullableWithAggregatesFilter<"email_campaigns">
    user_id?: UuidNullableWithAggregatesFilter<"email_campaigns"> | string | null
    template_id?: UuidNullableWithAggregatesFilter<"email_campaigns"> | string | null
    scheduled_for?: DateTimeNullableWithAggregatesFilter<"email_campaigns"> | Date | string | null
    sender_name?: StringNullableWithAggregatesFilter<"email_campaigns"> | string | null
    sender_email?: StringNullableWithAggregatesFilter<"email_campaigns"> | string | null
    reply_to?: StringNullableWithAggregatesFilter<"email_campaigns"> | string | null
    segment_criteria?: JsonNullableWithAggregatesFilter<"email_campaigns">
    test_recipients?: StringNullableListFilter<"email_campaigns">
    is_recurring?: BoolNullableWithAggregatesFilter<"email_campaigns"> | boolean | null
    recurrence_pattern?: JsonNullableWithAggregatesFilter<"email_campaigns">
  }

  export type email_templatesWhereInput = {
    AND?: email_templatesWhereInput | email_templatesWhereInput[]
    OR?: email_templatesWhereInput[]
    NOT?: email_templatesWhereInput | email_templatesWhereInput[]
    id?: UuidFilter<"email_templates"> | string
    created_at?: DateTimeFilter<"email_templates"> | Date | string
    updated_at?: DateTimeNullableFilter<"email_templates"> | Date | string | null
    name?: StringFilter<"email_templates"> | string
    subject?: StringNullableFilter<"email_templates"> | string | null
    body?: StringNullableFilter<"email_templates"> | string | null
    html_body?: StringNullableFilter<"email_templates"> | string | null
    elements?: JsonNullableFilter<"email_templates">
    editor_settings?: JsonNullableFilter<"email_templates">
    thumbnail?: StringNullableFilter<"email_templates"> | string | null
    operator_id?: UuidNullableFilter<"email_templates"> | string | null
    category?: StringNullableFilter<"email_templates"> | string | null
    variables?: JsonNullableFilter<"email_templates">
    is_default?: BoolNullableFilter<"email_templates"> | boolean | null
    version?: IntNullableFilter<"email_templates"> | number | null
    email_campaigns?: Email_campaignsListRelationFilter
    operators?: XOR<OperatorsNullableScalarRelationFilter, operatorsWhereInput> | null
  }

  export type email_templatesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    html_body?: SortOrderInput | SortOrder
    elements?: SortOrderInput | SortOrder
    editor_settings?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    variables?: SortOrderInput | SortOrder
    is_default?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    email_campaigns?: email_campaignsOrderByRelationAggregateInput
    operators?: operatorsOrderByWithRelationInput
  }

  export type email_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: email_templatesWhereInput | email_templatesWhereInput[]
    OR?: email_templatesWhereInput[]
    NOT?: email_templatesWhereInput | email_templatesWhereInput[]
    created_at?: DateTimeFilter<"email_templates"> | Date | string
    updated_at?: DateTimeNullableFilter<"email_templates"> | Date | string | null
    name?: StringFilter<"email_templates"> | string
    subject?: StringNullableFilter<"email_templates"> | string | null
    body?: StringNullableFilter<"email_templates"> | string | null
    html_body?: StringNullableFilter<"email_templates"> | string | null
    elements?: JsonNullableFilter<"email_templates">
    editor_settings?: JsonNullableFilter<"email_templates">
    thumbnail?: StringNullableFilter<"email_templates"> | string | null
    operator_id?: UuidNullableFilter<"email_templates"> | string | null
    category?: StringNullableFilter<"email_templates"> | string | null
    variables?: JsonNullableFilter<"email_templates">
    is_default?: BoolNullableFilter<"email_templates"> | boolean | null
    version?: IntNullableFilter<"email_templates"> | number | null
    email_campaigns?: Email_campaignsListRelationFilter
    operators?: XOR<OperatorsNullableScalarRelationFilter, operatorsWhereInput> | null
  }, "id">

  export type email_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    html_body?: SortOrderInput | SortOrder
    elements?: SortOrderInput | SortOrder
    editor_settings?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    variables?: SortOrderInput | SortOrder
    is_default?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _count?: email_templatesCountOrderByAggregateInput
    _avg?: email_templatesAvgOrderByAggregateInput
    _max?: email_templatesMaxOrderByAggregateInput
    _min?: email_templatesMinOrderByAggregateInput
    _sum?: email_templatesSumOrderByAggregateInput
  }

  export type email_templatesScalarWhereWithAggregatesInput = {
    AND?: email_templatesScalarWhereWithAggregatesInput | email_templatesScalarWhereWithAggregatesInput[]
    OR?: email_templatesScalarWhereWithAggregatesInput[]
    NOT?: email_templatesScalarWhereWithAggregatesInput | email_templatesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"email_templates"> | string
    created_at?: DateTimeWithAggregatesFilter<"email_templates"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"email_templates"> | Date | string | null
    name?: StringWithAggregatesFilter<"email_templates"> | string
    subject?: StringNullableWithAggregatesFilter<"email_templates"> | string | null
    body?: StringNullableWithAggregatesFilter<"email_templates"> | string | null
    html_body?: StringNullableWithAggregatesFilter<"email_templates"> | string | null
    elements?: JsonNullableWithAggregatesFilter<"email_templates">
    editor_settings?: JsonNullableWithAggregatesFilter<"email_templates">
    thumbnail?: StringNullableWithAggregatesFilter<"email_templates"> | string | null
    operator_id?: UuidNullableWithAggregatesFilter<"email_templates"> | string | null
    category?: StringNullableWithAggregatesFilter<"email_templates"> | string | null
    variables?: JsonNullableWithAggregatesFilter<"email_templates">
    is_default?: BoolNullableWithAggregatesFilter<"email_templates"> | boolean | null
    version?: IntNullableWithAggregatesFilter<"email_templates"> | number | null
  }

  export type gift_cardsWhereInput = {
    AND?: gift_cardsWhereInput | gift_cardsWhereInput[]
    OR?: gift_cardsWhereInput[]
    NOT?: gift_cardsWhereInput | gift_cardsWhereInput[]
    id?: UuidFilter<"gift_cards"> | string
    created_at?: DateTimeFilter<"gift_cards"> | Date | string
    updated_at?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    code?: StringFilter<"gift_cards"> | string
    amount?: DecimalFilter<"gift_cards"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalNullableFilter<"gift_cards"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"gift_cards"> | string
    issue_date?: DateTimeFilter<"gift_cards"> | Date | string
    expiry_date?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    recipient_name?: StringNullableFilter<"gift_cards"> | string | null
    recipient_email?: StringNullableFilter<"gift_cards"> | string | null
    sender_id?: UuidNullableFilter<"gift_cards"> | string | null
    redeemed_at?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    message?: StringNullableFilter<"gift_cards"> | string | null
    payment_method?: Enumpayment_method_enumNullableFilter<"gift_cards"> | $Enums.payment_method_enum | null
    send_date?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    design_template?: StringNullableFilter<"gift_cards"> | string | null
    branch_id?: UuidNullableFilter<"gift_cards"> | string | null
    is_reloadable?: BoolNullableFilter<"gift_cards"> | boolean | null
    access_pin?: StringNullableFilter<"gift_cards"> | string | null
    usage_history?: JsonNullableListFilter<"gift_cards">
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
  }

  export type gift_cardsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrderInput | SortOrder
    status?: SortOrder
    issue_date?: SortOrder
    expiry_date?: SortOrderInput | SortOrder
    recipient_name?: SortOrderInput | SortOrder
    recipient_email?: SortOrderInput | SortOrder
    sender_id?: SortOrderInput | SortOrder
    redeemed_at?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    send_date?: SortOrderInput | SortOrder
    design_template?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    is_reloadable?: SortOrderInput | SortOrder
    access_pin?: SortOrderInput | SortOrder
    usage_history?: SortOrder
    branches?: branchesOrderByWithRelationInput
  }

  export type gift_cardsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: gift_cardsWhereInput | gift_cardsWhereInput[]
    OR?: gift_cardsWhereInput[]
    NOT?: gift_cardsWhereInput | gift_cardsWhereInput[]
    created_at?: DateTimeFilter<"gift_cards"> | Date | string
    updated_at?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    amount?: DecimalFilter<"gift_cards"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalNullableFilter<"gift_cards"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"gift_cards"> | string
    issue_date?: DateTimeFilter<"gift_cards"> | Date | string
    expiry_date?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    recipient_name?: StringNullableFilter<"gift_cards"> | string | null
    recipient_email?: StringNullableFilter<"gift_cards"> | string | null
    sender_id?: UuidNullableFilter<"gift_cards"> | string | null
    redeemed_at?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    message?: StringNullableFilter<"gift_cards"> | string | null
    payment_method?: Enumpayment_method_enumNullableFilter<"gift_cards"> | $Enums.payment_method_enum | null
    send_date?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    design_template?: StringNullableFilter<"gift_cards"> | string | null
    branch_id?: UuidNullableFilter<"gift_cards"> | string | null
    is_reloadable?: BoolNullableFilter<"gift_cards"> | boolean | null
    access_pin?: StringNullableFilter<"gift_cards"> | string | null
    usage_history?: JsonNullableListFilter<"gift_cards">
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
  }, "id" | "code">

  export type gift_cardsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrderInput | SortOrder
    status?: SortOrder
    issue_date?: SortOrder
    expiry_date?: SortOrderInput | SortOrder
    recipient_name?: SortOrderInput | SortOrder
    recipient_email?: SortOrderInput | SortOrder
    sender_id?: SortOrderInput | SortOrder
    redeemed_at?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    send_date?: SortOrderInput | SortOrder
    design_template?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    is_reloadable?: SortOrderInput | SortOrder
    access_pin?: SortOrderInput | SortOrder
    usage_history?: SortOrder
    _count?: gift_cardsCountOrderByAggregateInput
    _avg?: gift_cardsAvgOrderByAggregateInput
    _max?: gift_cardsMaxOrderByAggregateInput
    _min?: gift_cardsMinOrderByAggregateInput
    _sum?: gift_cardsSumOrderByAggregateInput
  }

  export type gift_cardsScalarWhereWithAggregatesInput = {
    AND?: gift_cardsScalarWhereWithAggregatesInput | gift_cardsScalarWhereWithAggregatesInput[]
    OR?: gift_cardsScalarWhereWithAggregatesInput[]
    NOT?: gift_cardsScalarWhereWithAggregatesInput | gift_cardsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"gift_cards"> | string
    created_at?: DateTimeWithAggregatesFilter<"gift_cards"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"gift_cards"> | Date | string | null
    code?: StringWithAggregatesFilter<"gift_cards"> | string
    amount?: DecimalWithAggregatesFilter<"gift_cards"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalNullableWithAggregatesFilter<"gift_cards"> | Decimal | DecimalJsLike | number | string | null
    status?: StringWithAggregatesFilter<"gift_cards"> | string
    issue_date?: DateTimeWithAggregatesFilter<"gift_cards"> | Date | string
    expiry_date?: DateTimeNullableWithAggregatesFilter<"gift_cards"> | Date | string | null
    recipient_name?: StringNullableWithAggregatesFilter<"gift_cards"> | string | null
    recipient_email?: StringNullableWithAggregatesFilter<"gift_cards"> | string | null
    sender_id?: UuidNullableWithAggregatesFilter<"gift_cards"> | string | null
    redeemed_at?: DateTimeNullableWithAggregatesFilter<"gift_cards"> | Date | string | null
    message?: StringNullableWithAggregatesFilter<"gift_cards"> | string | null
    payment_method?: Enumpayment_method_enumNullableWithAggregatesFilter<"gift_cards"> | $Enums.payment_method_enum | null
    send_date?: DateTimeNullableWithAggregatesFilter<"gift_cards"> | Date | string | null
    design_template?: StringNullableWithAggregatesFilter<"gift_cards"> | string | null
    branch_id?: UuidNullableWithAggregatesFilter<"gift_cards"> | string | null
    is_reloadable?: BoolNullableWithAggregatesFilter<"gift_cards"> | boolean | null
    access_pin?: StringNullableWithAggregatesFilter<"gift_cards"> | string | null
    usage_history?: JsonNullableListFilter<"gift_cards">
  }

  export type invoice_itemsWhereInput = {
    AND?: invoice_itemsWhereInput | invoice_itemsWhereInput[]
    OR?: invoice_itemsWhereInput[]
    NOT?: invoice_itemsWhereInput | invoice_itemsWhereInput[]
    id?: UuidFilter<"invoice_items"> | string
    created_at?: DateTimeFilter<"invoice_items"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoice_items"> | Date | string | null
    invoice_id?: UuidFilter<"invoice_items"> | string
    product_id?: UuidNullableFilter<"invoice_items"> | string | null
    plan_id?: UuidNullableFilter<"invoice_items"> | string | null
    description?: StringFilter<"invoice_items"> | string
    quantity?: IntFilter<"invoice_items"> | number
    unit_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    discount_rate?: DecimalNullableFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string | null
    tax_rate?: DecimalNullableFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string | null
    item_order?: IntNullableFilter<"invoice_items"> | number | null
    unit_of_measure?: StringNullableFilter<"invoice_items"> | string | null
    is_taxable?: BoolNullableFilter<"invoice_items"> | boolean | null
    serial_numbers?: StringNullableListFilter<"invoice_items">
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    plans?: XOR<PlansNullableScalarRelationFilter, plansWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
  }

  export type invoice_itemsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    invoice_id?: SortOrder
    product_id?: SortOrderInput | SortOrder
    plan_id?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    discount_rate?: SortOrderInput | SortOrder
    tax_rate?: SortOrderInput | SortOrder
    item_order?: SortOrderInput | SortOrder
    unit_of_measure?: SortOrderInput | SortOrder
    is_taxable?: SortOrderInput | SortOrder
    serial_numbers?: SortOrder
    invoices?: invoicesOrderByWithRelationInput
    plans?: plansOrderByWithRelationInput
    products?: productsOrderByWithRelationInput
  }

  export type invoice_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: invoice_itemsWhereInput | invoice_itemsWhereInput[]
    OR?: invoice_itemsWhereInput[]
    NOT?: invoice_itemsWhereInput | invoice_itemsWhereInput[]
    created_at?: DateTimeFilter<"invoice_items"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoice_items"> | Date | string | null
    invoice_id?: UuidFilter<"invoice_items"> | string
    product_id?: UuidNullableFilter<"invoice_items"> | string | null
    plan_id?: UuidNullableFilter<"invoice_items"> | string | null
    description?: StringFilter<"invoice_items"> | string
    quantity?: IntFilter<"invoice_items"> | number
    unit_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    discount_rate?: DecimalNullableFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string | null
    tax_rate?: DecimalNullableFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string | null
    item_order?: IntNullableFilter<"invoice_items"> | number | null
    unit_of_measure?: StringNullableFilter<"invoice_items"> | string | null
    is_taxable?: BoolNullableFilter<"invoice_items"> | boolean | null
    serial_numbers?: StringNullableListFilter<"invoice_items">
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    plans?: XOR<PlansNullableScalarRelationFilter, plansWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
  }, "id">

  export type invoice_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    invoice_id?: SortOrder
    product_id?: SortOrderInput | SortOrder
    plan_id?: SortOrderInput | SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    discount_rate?: SortOrderInput | SortOrder
    tax_rate?: SortOrderInput | SortOrder
    item_order?: SortOrderInput | SortOrder
    unit_of_measure?: SortOrderInput | SortOrder
    is_taxable?: SortOrderInput | SortOrder
    serial_numbers?: SortOrder
    _count?: invoice_itemsCountOrderByAggregateInput
    _avg?: invoice_itemsAvgOrderByAggregateInput
    _max?: invoice_itemsMaxOrderByAggregateInput
    _min?: invoice_itemsMinOrderByAggregateInput
    _sum?: invoice_itemsSumOrderByAggregateInput
  }

  export type invoice_itemsScalarWhereWithAggregatesInput = {
    AND?: invoice_itemsScalarWhereWithAggregatesInput | invoice_itemsScalarWhereWithAggregatesInput[]
    OR?: invoice_itemsScalarWhereWithAggregatesInput[]
    NOT?: invoice_itemsScalarWhereWithAggregatesInput | invoice_itemsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"invoice_items"> | string
    created_at?: DateTimeWithAggregatesFilter<"invoice_items"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"invoice_items"> | Date | string | null
    invoice_id?: UuidWithAggregatesFilter<"invoice_items"> | string
    product_id?: UuidNullableWithAggregatesFilter<"invoice_items"> | string | null
    plan_id?: UuidNullableWithAggregatesFilter<"invoice_items"> | string | null
    description?: StringWithAggregatesFilter<"invoice_items"> | string
    quantity?: IntWithAggregatesFilter<"invoice_items"> | number
    unit_price?: DecimalWithAggregatesFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalWithAggregatesFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    discount_rate?: DecimalNullableWithAggregatesFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string | null
    tax_rate?: DecimalNullableWithAggregatesFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string | null
    item_order?: IntNullableWithAggregatesFilter<"invoice_items"> | number | null
    unit_of_measure?: StringNullableWithAggregatesFilter<"invoice_items"> | string | null
    is_taxable?: BoolNullableWithAggregatesFilter<"invoice_items"> | boolean | null
    serial_numbers?: StringNullableListFilter<"invoice_items">
  }

  export type invoice_packagesWhereInput = {
    AND?: invoice_packagesWhereInput | invoice_packagesWhereInput[]
    OR?: invoice_packagesWhereInput[]
    NOT?: invoice_packagesWhereInput | invoice_packagesWhereInput[]
    id?: UuidFilter<"invoice_packages"> | string
    created_at?: DateTimeFilter<"invoice_packages"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoice_packages"> | Date | string | null
    invoice_id?: UuidFilter<"invoice_packages"> | string
    package_id?: UuidFilter<"invoice_packages"> | string
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    packages?: XOR<PackagesScalarRelationFilter, packagesWhereInput>
  }

  export type invoice_packagesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    invoice_id?: SortOrder
    package_id?: SortOrder
    invoices?: invoicesOrderByWithRelationInput
    packages?: packagesOrderByWithRelationInput
  }

  export type invoice_packagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_id_package_id?: invoice_packagesInvoice_idPackage_idCompoundUniqueInput
    AND?: invoice_packagesWhereInput | invoice_packagesWhereInput[]
    OR?: invoice_packagesWhereInput[]
    NOT?: invoice_packagesWhereInput | invoice_packagesWhereInput[]
    created_at?: DateTimeFilter<"invoice_packages"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoice_packages"> | Date | string | null
    invoice_id?: UuidFilter<"invoice_packages"> | string
    package_id?: UuidFilter<"invoice_packages"> | string
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    packages?: XOR<PackagesScalarRelationFilter, packagesWhereInput>
  }, "id" | "invoice_id_package_id">

  export type invoice_packagesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    invoice_id?: SortOrder
    package_id?: SortOrder
    _count?: invoice_packagesCountOrderByAggregateInput
    _max?: invoice_packagesMaxOrderByAggregateInput
    _min?: invoice_packagesMinOrderByAggregateInput
  }

  export type invoice_packagesScalarWhereWithAggregatesInput = {
    AND?: invoice_packagesScalarWhereWithAggregatesInput | invoice_packagesScalarWhereWithAggregatesInput[]
    OR?: invoice_packagesScalarWhereWithAggregatesInput[]
    NOT?: invoice_packagesScalarWhereWithAggregatesInput | invoice_packagesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"invoice_packages"> | string
    created_at?: DateTimeWithAggregatesFilter<"invoice_packages"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"invoice_packages"> | Date | string | null
    invoice_id?: UuidWithAggregatesFilter<"invoice_packages"> | string
    package_id?: UuidWithAggregatesFilter<"invoice_packages"> | string
  }

  export type invoicesWhereInput = {
    AND?: invoicesWhereInput | invoicesWhereInput[]
    OR?: invoicesWhereInput[]
    NOT?: invoicesWhereInput | invoicesWhereInput[]
    id?: UuidFilter<"invoices"> | string
    created_at?: DateTimeFilter<"invoices"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    invoice_number?: StringFilter<"invoices"> | string
    issue_date?: DateTimeFilter<"invoices"> | Date | string
    due_date?: DateTimeFilter<"invoices"> | Date | string
    status?: Enuminvoice_status_enumFilter<"invoices"> | $Enums.invoice_status_enum
    is_paid?: BoolNullableFilter<"invoices"> | boolean | null
    total_amount?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    discount_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    user_id?: UuidNullableFilter<"invoices"> | string | null
    branch_id?: UuidNullableFilter<"invoices"> | string | null
    operator_id?: UuidNullableFilter<"invoices"> | string | null
    billing_address?: JsonNullableFilter<"invoices">
    shipping_address?: JsonNullableFilter<"invoices">
    notes?: StringNullableFilter<"invoices"> | string | null
    payment_terms?: StringNullableFilter<"invoices"> | string | null
    currency?: StringNullableFilter<"invoices"> | string | null
    conversion_rate?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    tracking_number?: StringNullableFilter<"invoices"> | string | null
    shipping_method?: StringNullableFilter<"invoices"> | string | null
    invoice_type?: Enuminvoice_type_enumNullableFilter<"invoices"> | $Enums.invoice_type_enum | null
    commission_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    platform?: StringNullableFilter<"invoices"> | string | null
    external_reference_id?: StringNullableFilter<"invoices"> | string | null
    tax_details?: JsonNullableFilter<"invoices">
    price_plan?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFilter<"invoices"> | boolean
    paid_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: DateTimeNullableFilter<"invoices"> | Date | string | null
    invoice_items?: Invoice_itemsListRelationFilter
    invoice_packages?: Invoice_packagesListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    operators?: XOR<OperatorsNullableScalarRelationFilter, operatorsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    payments?: PaymentsListRelationFilter
  }

  export type invoicesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    invoice_number?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    is_paid?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    tax_amount?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    billing_address?: SortOrderInput | SortOrder
    shipping_address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    payment_terms?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    conversion_rate?: SortOrderInput | SortOrder
    tracking_number?: SortOrderInput | SortOrder
    shipping_method?: SortOrderInput | SortOrder
    invoice_type?: SortOrderInput | SortOrder
    commission_amount?: SortOrderInput | SortOrder
    marketplace_fee_rate?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    external_reference_id?: SortOrderInput | SortOrder
    tax_details?: SortOrderInput | SortOrder
    price_plan?: SortOrder
    shipping_insurance?: SortOrder
    paid_amount?: SortOrderInput | SortOrder
    remaining_amount?: SortOrderInput | SortOrder
    last_payment_date?: SortOrderInput | SortOrder
    invoice_items?: invoice_itemsOrderByRelationAggregateInput
    invoice_packages?: invoice_packagesOrderByRelationAggregateInput
    branches?: branchesOrderByWithRelationInput
    operators?: operatorsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    payments?: paymentsOrderByRelationAggregateInput
  }

  export type invoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_number?: string
    AND?: invoicesWhereInput | invoicesWhereInput[]
    OR?: invoicesWhereInput[]
    NOT?: invoicesWhereInput | invoicesWhereInput[]
    created_at?: DateTimeFilter<"invoices"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    issue_date?: DateTimeFilter<"invoices"> | Date | string
    due_date?: DateTimeFilter<"invoices"> | Date | string
    status?: Enuminvoice_status_enumFilter<"invoices"> | $Enums.invoice_status_enum
    is_paid?: BoolNullableFilter<"invoices"> | boolean | null
    total_amount?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    discount_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    user_id?: UuidNullableFilter<"invoices"> | string | null
    branch_id?: UuidNullableFilter<"invoices"> | string | null
    operator_id?: UuidNullableFilter<"invoices"> | string | null
    billing_address?: JsonNullableFilter<"invoices">
    shipping_address?: JsonNullableFilter<"invoices">
    notes?: StringNullableFilter<"invoices"> | string | null
    payment_terms?: StringNullableFilter<"invoices"> | string | null
    currency?: StringNullableFilter<"invoices"> | string | null
    conversion_rate?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    tracking_number?: StringNullableFilter<"invoices"> | string | null
    shipping_method?: StringNullableFilter<"invoices"> | string | null
    invoice_type?: Enuminvoice_type_enumNullableFilter<"invoices"> | $Enums.invoice_type_enum | null
    commission_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    platform?: StringNullableFilter<"invoices"> | string | null
    external_reference_id?: StringNullableFilter<"invoices"> | string | null
    tax_details?: JsonNullableFilter<"invoices">
    price_plan?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFilter<"invoices"> | boolean
    paid_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: DateTimeNullableFilter<"invoices"> | Date | string | null
    invoice_items?: Invoice_itemsListRelationFilter
    invoice_packages?: Invoice_packagesListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    operators?: XOR<OperatorsNullableScalarRelationFilter, operatorsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    payments?: PaymentsListRelationFilter
  }, "id" | "invoice_number">

  export type invoicesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    invoice_number?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    is_paid?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    tax_amount?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    billing_address?: SortOrderInput | SortOrder
    shipping_address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    payment_terms?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    conversion_rate?: SortOrderInput | SortOrder
    tracking_number?: SortOrderInput | SortOrder
    shipping_method?: SortOrderInput | SortOrder
    invoice_type?: SortOrderInput | SortOrder
    commission_amount?: SortOrderInput | SortOrder
    marketplace_fee_rate?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    external_reference_id?: SortOrderInput | SortOrder
    tax_details?: SortOrderInput | SortOrder
    price_plan?: SortOrder
    shipping_insurance?: SortOrder
    paid_amount?: SortOrderInput | SortOrder
    remaining_amount?: SortOrderInput | SortOrder
    last_payment_date?: SortOrderInput | SortOrder
    _count?: invoicesCountOrderByAggregateInput
    _avg?: invoicesAvgOrderByAggregateInput
    _max?: invoicesMaxOrderByAggregateInput
    _min?: invoicesMinOrderByAggregateInput
    _sum?: invoicesSumOrderByAggregateInput
  }

  export type invoicesScalarWhereWithAggregatesInput = {
    AND?: invoicesScalarWhereWithAggregatesInput | invoicesScalarWhereWithAggregatesInput[]
    OR?: invoicesScalarWhereWithAggregatesInput[]
    NOT?: invoicesScalarWhereWithAggregatesInput | invoicesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"invoices"> | string
    created_at?: DateTimeWithAggregatesFilter<"invoices"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"invoices"> | Date | string | null
    invoice_number?: StringWithAggregatesFilter<"invoices"> | string
    issue_date?: DateTimeWithAggregatesFilter<"invoices"> | Date | string
    due_date?: DateTimeWithAggregatesFilter<"invoices"> | Date | string
    status?: Enuminvoice_status_enumWithAggregatesFilter<"invoices"> | $Enums.invoice_status_enum
    is_paid?: BoolNullableWithAggregatesFilter<"invoices"> | boolean | null
    total_amount?: DecimalWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalNullableWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    discount_amount?: DecimalNullableWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    user_id?: UuidNullableWithAggregatesFilter<"invoices"> | string | null
    branch_id?: UuidNullableWithAggregatesFilter<"invoices"> | string | null
    operator_id?: UuidNullableWithAggregatesFilter<"invoices"> | string | null
    billing_address?: JsonNullableWithAggregatesFilter<"invoices">
    shipping_address?: JsonNullableWithAggregatesFilter<"invoices">
    notes?: StringNullableWithAggregatesFilter<"invoices"> | string | null
    payment_terms?: StringNullableWithAggregatesFilter<"invoices"> | string | null
    currency?: StringNullableWithAggregatesFilter<"invoices"> | string | null
    conversion_rate?: DecimalNullableWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    tracking_number?: StringNullableWithAggregatesFilter<"invoices"> | string | null
    shipping_method?: StringNullableWithAggregatesFilter<"invoices"> | string | null
    invoice_type?: Enuminvoice_type_enumNullableWithAggregatesFilter<"invoices"> | $Enums.invoice_type_enum | null
    commission_amount?: DecimalNullableWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: DecimalNullableWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    platform?: StringNullableWithAggregatesFilter<"invoices"> | string | null
    external_reference_id?: StringNullableWithAggregatesFilter<"invoices"> | string | null
    tax_details?: JsonNullableWithAggregatesFilter<"invoices">
    price_plan?: DecimalWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolWithAggregatesFilter<"invoices"> | boolean
    paid_amount?: DecimalNullableWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: DecimalNullableWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: DateTimeNullableWithAggregatesFilter<"invoices"> | Date | string | null
  }

  export type notification_preferencesWhereInput = {
    AND?: notification_preferencesWhereInput | notification_preferencesWhereInput[]
    OR?: notification_preferencesWhereInput[]
    NOT?: notification_preferencesWhereInput | notification_preferencesWhereInput[]
    id?: UuidFilter<"notification_preferences"> | string
    created_at?: DateTimeFilter<"notification_preferences"> | Date | string
    updated_at?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    user_id?: UuidFilter<"notification_preferences"> | string
    push_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    email_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    sms_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    news_and_updates?: BoolNullableFilter<"notification_preferences"> | boolean | null
    order_updates?: BoolNullableFilter<"notification_preferences"> | boolean | null
    promotions?: BoolNullableFilter<"notification_preferences"> | boolean | null
    security_alerts?: BoolNullableFilter<"notification_preferences"> | boolean | null
    quiet_hours_start?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    quiet_hours_end?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    quiet_hours_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    frequency?: StringNullableFilter<"notification_preferences"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notification_preferencesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    push_enabled?: SortOrderInput | SortOrder
    email_enabled?: SortOrderInput | SortOrder
    sms_enabled?: SortOrderInput | SortOrder
    news_and_updates?: SortOrderInput | SortOrder
    order_updates?: SortOrderInput | SortOrder
    promotions?: SortOrderInput | SortOrder
    security_alerts?: SortOrderInput | SortOrder
    quiet_hours_start?: SortOrderInput | SortOrder
    quiet_hours_end?: SortOrderInput | SortOrder
    quiet_hours_enabled?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type notification_preferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notification_preferencesWhereInput | notification_preferencesWhereInput[]
    OR?: notification_preferencesWhereInput[]
    NOT?: notification_preferencesWhereInput | notification_preferencesWhereInput[]
    created_at?: DateTimeFilter<"notification_preferences"> | Date | string
    updated_at?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    user_id?: UuidFilter<"notification_preferences"> | string
    push_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    email_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    sms_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    news_and_updates?: BoolNullableFilter<"notification_preferences"> | boolean | null
    order_updates?: BoolNullableFilter<"notification_preferences"> | boolean | null
    promotions?: BoolNullableFilter<"notification_preferences"> | boolean | null
    security_alerts?: BoolNullableFilter<"notification_preferences"> | boolean | null
    quiet_hours_start?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    quiet_hours_end?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    quiet_hours_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    frequency?: StringNullableFilter<"notification_preferences"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type notification_preferencesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    push_enabled?: SortOrderInput | SortOrder
    email_enabled?: SortOrderInput | SortOrder
    sms_enabled?: SortOrderInput | SortOrder
    news_and_updates?: SortOrderInput | SortOrder
    order_updates?: SortOrderInput | SortOrder
    promotions?: SortOrderInput | SortOrder
    security_alerts?: SortOrderInput | SortOrder
    quiet_hours_start?: SortOrderInput | SortOrder
    quiet_hours_end?: SortOrderInput | SortOrder
    quiet_hours_enabled?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    _count?: notification_preferencesCountOrderByAggregateInput
    _max?: notification_preferencesMaxOrderByAggregateInput
    _min?: notification_preferencesMinOrderByAggregateInput
  }

  export type notification_preferencesScalarWhereWithAggregatesInput = {
    AND?: notification_preferencesScalarWhereWithAggregatesInput | notification_preferencesScalarWhereWithAggregatesInput[]
    OR?: notification_preferencesScalarWhereWithAggregatesInput[]
    NOT?: notification_preferencesScalarWhereWithAggregatesInput | notification_preferencesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"notification_preferences"> | string
    created_at?: DateTimeWithAggregatesFilter<"notification_preferences"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"notification_preferences"> | Date | string | null
    user_id?: UuidWithAggregatesFilter<"notification_preferences"> | string
    push_enabled?: BoolNullableWithAggregatesFilter<"notification_preferences"> | boolean | null
    email_enabled?: BoolNullableWithAggregatesFilter<"notification_preferences"> | boolean | null
    sms_enabled?: BoolNullableWithAggregatesFilter<"notification_preferences"> | boolean | null
    news_and_updates?: BoolNullableWithAggregatesFilter<"notification_preferences"> | boolean | null
    order_updates?: BoolNullableWithAggregatesFilter<"notification_preferences"> | boolean | null
    promotions?: BoolNullableWithAggregatesFilter<"notification_preferences"> | boolean | null
    security_alerts?: BoolNullableWithAggregatesFilter<"notification_preferences"> | boolean | null
    quiet_hours_start?: DateTimeNullableWithAggregatesFilter<"notification_preferences"> | Date | string | null
    quiet_hours_end?: DateTimeNullableWithAggregatesFilter<"notification_preferences"> | Date | string | null
    quiet_hours_enabled?: BoolNullableWithAggregatesFilter<"notification_preferences"> | boolean | null
    frequency?: StringNullableWithAggregatesFilter<"notification_preferences"> | string | null
  }

  export type notification_usersWhereInput = {
    AND?: notification_usersWhereInput | notification_usersWhereInput[]
    OR?: notification_usersWhereInput[]
    NOT?: notification_usersWhereInput | notification_usersWhereInput[]
    id?: UuidFilter<"notification_users"> | string
    created_at?: DateTimeFilter<"notification_users"> | Date | string
    updated_at?: DateTimeNullableFilter<"notification_users"> | Date | string | null
    title?: StringFilter<"notification_users"> | string
    message?: StringFilter<"notification_users"> | string
    type?: StringFilter<"notification_users"> | string
    is_read?: BoolNullableFilter<"notification_users"> | boolean | null
    is_deleted?: BoolNullableFilter<"notification_users"> | boolean | null
    user_id?: UuidFilter<"notification_users"> | string
    data?: JsonNullableFilter<"notification_users">
    priority?: StringNullableFilter<"notification_users"> | string | null
    action_url?: StringNullableFilter<"notification_users"> | string | null
    icon?: StringNullableFilter<"notification_users"> | string | null
    expiry_date?: DateTimeNullableFilter<"notification_users"> | Date | string | null
    requires_action?: BoolNullableFilter<"notification_users"> | boolean | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notification_usersOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrderInput | SortOrder
    is_deleted?: SortOrderInput | SortOrder
    user_id?: SortOrder
    data?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    action_url?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    requires_action?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type notification_usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notification_usersWhereInput | notification_usersWhereInput[]
    OR?: notification_usersWhereInput[]
    NOT?: notification_usersWhereInput | notification_usersWhereInput[]
    created_at?: DateTimeFilter<"notification_users"> | Date | string
    updated_at?: DateTimeNullableFilter<"notification_users"> | Date | string | null
    title?: StringFilter<"notification_users"> | string
    message?: StringFilter<"notification_users"> | string
    type?: StringFilter<"notification_users"> | string
    is_read?: BoolNullableFilter<"notification_users"> | boolean | null
    is_deleted?: BoolNullableFilter<"notification_users"> | boolean | null
    user_id?: UuidFilter<"notification_users"> | string
    data?: JsonNullableFilter<"notification_users">
    priority?: StringNullableFilter<"notification_users"> | string | null
    action_url?: StringNullableFilter<"notification_users"> | string | null
    icon?: StringNullableFilter<"notification_users"> | string | null
    expiry_date?: DateTimeNullableFilter<"notification_users"> | Date | string | null
    requires_action?: BoolNullableFilter<"notification_users"> | boolean | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type notification_usersOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrderInput | SortOrder
    is_deleted?: SortOrderInput | SortOrder
    user_id?: SortOrder
    data?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    action_url?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    requires_action?: SortOrderInput | SortOrder
    _count?: notification_usersCountOrderByAggregateInput
    _max?: notification_usersMaxOrderByAggregateInput
    _min?: notification_usersMinOrderByAggregateInput
  }

  export type notification_usersScalarWhereWithAggregatesInput = {
    AND?: notification_usersScalarWhereWithAggregatesInput | notification_usersScalarWhereWithAggregatesInput[]
    OR?: notification_usersScalarWhereWithAggregatesInput[]
    NOT?: notification_usersScalarWhereWithAggregatesInput | notification_usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"notification_users"> | string
    created_at?: DateTimeWithAggregatesFilter<"notification_users"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"notification_users"> | Date | string | null
    title?: StringWithAggregatesFilter<"notification_users"> | string
    message?: StringWithAggregatesFilter<"notification_users"> | string
    type?: StringWithAggregatesFilter<"notification_users"> | string
    is_read?: BoolNullableWithAggregatesFilter<"notification_users"> | boolean | null
    is_deleted?: BoolNullableWithAggregatesFilter<"notification_users"> | boolean | null
    user_id?: UuidWithAggregatesFilter<"notification_users"> | string
    data?: JsonNullableWithAggregatesFilter<"notification_users">
    priority?: StringNullableWithAggregatesFilter<"notification_users"> | string | null
    action_url?: StringNullableWithAggregatesFilter<"notification_users"> | string | null
    icon?: StringNullableWithAggregatesFilter<"notification_users"> | string | null
    expiry_date?: DateTimeNullableWithAggregatesFilter<"notification_users"> | Date | string | null
    requires_action?: BoolNullableWithAggregatesFilter<"notification_users"> | boolean | null
  }

  export type notifications_operatorWhereInput = {
    AND?: notifications_operatorWhereInput | notifications_operatorWhereInput[]
    OR?: notifications_operatorWhereInput[]
    NOT?: notifications_operatorWhereInput | notifications_operatorWhereInput[]
    id?: UuidFilter<"notifications_operator"> | string
    created_at?: DateTimeFilter<"notifications_operator"> | Date | string
    updated_at?: DateTimeNullableFilter<"notifications_operator"> | Date | string | null
    title?: StringFilter<"notifications_operator"> | string
    message?: StringFilter<"notifications_operator"> | string
    is_read?: BoolNullableFilter<"notifications_operator"> | boolean | null
    operator_id?: UuidFilter<"notifications_operator"> | string
    data?: JsonNullableFilter<"notifications_operator">
    notification_type?: StringNullableFilter<"notifications_operator"> | string | null
    priority?: StringNullableFilter<"notifications_operator"> | string | null
    action_required?: BoolNullableFilter<"notifications_operator"> | boolean | null
    action_type?: StringNullableFilter<"notifications_operator"> | string | null
    action_data?: JsonNullableFilter<"notifications_operator">
    expiry_date?: DateTimeNullableFilter<"notifications_operator"> | Date | string | null
    operators?: XOR<OperatorsScalarRelationFilter, operatorsWhereInput>
  }

  export type notifications_operatorOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrderInput | SortOrder
    operator_id?: SortOrder
    data?: SortOrderInput | SortOrder
    notification_type?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    action_required?: SortOrderInput | SortOrder
    action_type?: SortOrderInput | SortOrder
    action_data?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    operators?: operatorsOrderByWithRelationInput
  }

  export type notifications_operatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notifications_operatorWhereInput | notifications_operatorWhereInput[]
    OR?: notifications_operatorWhereInput[]
    NOT?: notifications_operatorWhereInput | notifications_operatorWhereInput[]
    created_at?: DateTimeFilter<"notifications_operator"> | Date | string
    updated_at?: DateTimeNullableFilter<"notifications_operator"> | Date | string | null
    title?: StringFilter<"notifications_operator"> | string
    message?: StringFilter<"notifications_operator"> | string
    is_read?: BoolNullableFilter<"notifications_operator"> | boolean | null
    operator_id?: UuidFilter<"notifications_operator"> | string
    data?: JsonNullableFilter<"notifications_operator">
    notification_type?: StringNullableFilter<"notifications_operator"> | string | null
    priority?: StringNullableFilter<"notifications_operator"> | string | null
    action_required?: BoolNullableFilter<"notifications_operator"> | boolean | null
    action_type?: StringNullableFilter<"notifications_operator"> | string | null
    action_data?: JsonNullableFilter<"notifications_operator">
    expiry_date?: DateTimeNullableFilter<"notifications_operator"> | Date | string | null
    operators?: XOR<OperatorsScalarRelationFilter, operatorsWhereInput>
  }, "id">

  export type notifications_operatorOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrderInput | SortOrder
    operator_id?: SortOrder
    data?: SortOrderInput | SortOrder
    notification_type?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    action_required?: SortOrderInput | SortOrder
    action_type?: SortOrderInput | SortOrder
    action_data?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    _count?: notifications_operatorCountOrderByAggregateInput
    _max?: notifications_operatorMaxOrderByAggregateInput
    _min?: notifications_operatorMinOrderByAggregateInput
  }

  export type notifications_operatorScalarWhereWithAggregatesInput = {
    AND?: notifications_operatorScalarWhereWithAggregatesInput | notifications_operatorScalarWhereWithAggregatesInput[]
    OR?: notifications_operatorScalarWhereWithAggregatesInput[]
    NOT?: notifications_operatorScalarWhereWithAggregatesInput | notifications_operatorScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"notifications_operator"> | string
    created_at?: DateTimeWithAggregatesFilter<"notifications_operator"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"notifications_operator"> | Date | string | null
    title?: StringWithAggregatesFilter<"notifications_operator"> | string
    message?: StringWithAggregatesFilter<"notifications_operator"> | string
    is_read?: BoolNullableWithAggregatesFilter<"notifications_operator"> | boolean | null
    operator_id?: UuidWithAggregatesFilter<"notifications_operator"> | string
    data?: JsonNullableWithAggregatesFilter<"notifications_operator">
    notification_type?: StringNullableWithAggregatesFilter<"notifications_operator"> | string | null
    priority?: StringNullableWithAggregatesFilter<"notifications_operator"> | string | null
    action_required?: BoolNullableWithAggregatesFilter<"notifications_operator"> | boolean | null
    action_type?: StringNullableWithAggregatesFilter<"notifications_operator"> | string | null
    action_data?: JsonNullableWithAggregatesFilter<"notifications_operator">
    expiry_date?: DateTimeNullableWithAggregatesFilter<"notifications_operator"> | Date | string | null
  }

  export type operator_typesWhereInput = {
    AND?: operator_typesWhereInput | operator_typesWhereInput[]
    OR?: operator_typesWhereInput[]
    NOT?: operator_typesWhereInput | operator_typesWhereInput[]
    id?: UuidFilter<"operator_types"> | string
    created_at?: DateTimeFilter<"operator_types"> | Date | string
    updated_at?: DateTimeNullableFilter<"operator_types"> | Date | string | null
    name?: StringFilter<"operator_types"> | string
    description?: StringNullableFilter<"operator_types"> | string | null
    permissions?: JsonNullableFilter<"operator_types">
    operators?: OperatorsListRelationFilter
  }

  export type operator_typesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    operators?: operatorsOrderByRelationAggregateInput
  }

  export type operator_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: operator_typesWhereInput | operator_typesWhereInput[]
    OR?: operator_typesWhereInput[]
    NOT?: operator_typesWhereInput | operator_typesWhereInput[]
    created_at?: DateTimeFilter<"operator_types"> | Date | string
    updated_at?: DateTimeNullableFilter<"operator_types"> | Date | string | null
    name?: StringFilter<"operator_types"> | string
    description?: StringNullableFilter<"operator_types"> | string | null
    permissions?: JsonNullableFilter<"operator_types">
    operators?: OperatorsListRelationFilter
  }, "id">

  export type operator_typesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    _count?: operator_typesCountOrderByAggregateInput
    _max?: operator_typesMaxOrderByAggregateInput
    _min?: operator_typesMinOrderByAggregateInput
  }

  export type operator_typesScalarWhereWithAggregatesInput = {
    AND?: operator_typesScalarWhereWithAggregatesInput | operator_typesScalarWhereWithAggregatesInput[]
    OR?: operator_typesScalarWhereWithAggregatesInput[]
    NOT?: operator_typesScalarWhereWithAggregatesInput | operator_typesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"operator_types"> | string
    created_at?: DateTimeWithAggregatesFilter<"operator_types"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"operator_types"> | Date | string | null
    name?: StringWithAggregatesFilter<"operator_types"> | string
    description?: StringNullableWithAggregatesFilter<"operator_types"> | string | null
    permissions?: JsonNullableWithAggregatesFilter<"operator_types">
  }

  export type operatorsWhereInput = {
    AND?: operatorsWhereInput | operatorsWhereInput[]
    OR?: operatorsWhereInput[]
    NOT?: operatorsWhereInput | operatorsWhereInput[]
    id?: UuidFilter<"operators"> | string
    created_at?: DateTimeFilter<"operators"> | Date | string
    updated_at?: DateTimeNullableFilter<"operators"> | Date | string | null
    email?: StringFilter<"operators"> | string
    password?: StringFilter<"operators"> | string
    first_name?: StringFilter<"operators"> | string
    last_name?: StringFilter<"operators"> | string
    phone?: StringNullableFilter<"operators"> | string | null
    photo?: StringNullableFilter<"operators"> | string | null
    role?: Enumoperator_role_enumFilter<"operators"> | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFilter<"operators"> | $Enums.operator_status_enum
    last_login_at?: DateTimeNullableFilter<"operators"> | Date | string | null
    branch_id?: UuidFilter<"operators"> | string
    type_operator_id?: UuidFilter<"operators"> | string
    position?: StringNullableFilter<"operators"> | string | null
    hire_date?: DateTimeNullableFilter<"operators"> | Date | string | null
    birth_date?: DateTimeNullableFilter<"operators"> | Date | string | null
    emergency_contact?: JsonNullableFilter<"operators">
    skills?: StringNullableListFilter<"operators">
    personal_id?: StringNullableFilter<"operators"> | string | null
    address?: StringNullableFilter<"operators"> | string | null
    activities?: ActivitiesListRelationFilter
    email_templates?: Email_templatesListRelationFilter
    invoices?: InvoicesListRelationFilter
    notifications_operator?: Notifications_operatorListRelationFilter
    branches?: XOR<BranchesScalarRelationFilter, branchesWhereInput>
    operator_types?: XOR<Operator_typesScalarRelationFilter, operator_typesWhereInput>
    packages?: PackagesListRelationFilter
  }

  export type operatorsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    branch_id?: SortOrder
    type_operator_id?: SortOrder
    position?: SortOrderInput | SortOrder
    hire_date?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    skills?: SortOrder
    personal_id?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    activities?: activitiesOrderByRelationAggregateInput
    email_templates?: email_templatesOrderByRelationAggregateInput
    invoices?: invoicesOrderByRelationAggregateInput
    notifications_operator?: notifications_operatorOrderByRelationAggregateInput
    branches?: branchesOrderByWithRelationInput
    operator_types?: operator_typesOrderByWithRelationInput
    packages?: packagesOrderByRelationAggregateInput
  }

  export type operatorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: operatorsWhereInput | operatorsWhereInput[]
    OR?: operatorsWhereInput[]
    NOT?: operatorsWhereInput | operatorsWhereInput[]
    created_at?: DateTimeFilter<"operators"> | Date | string
    updated_at?: DateTimeNullableFilter<"operators"> | Date | string | null
    password?: StringFilter<"operators"> | string
    first_name?: StringFilter<"operators"> | string
    last_name?: StringFilter<"operators"> | string
    phone?: StringNullableFilter<"operators"> | string | null
    photo?: StringNullableFilter<"operators"> | string | null
    role?: Enumoperator_role_enumFilter<"operators"> | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFilter<"operators"> | $Enums.operator_status_enum
    last_login_at?: DateTimeNullableFilter<"operators"> | Date | string | null
    branch_id?: UuidFilter<"operators"> | string
    type_operator_id?: UuidFilter<"operators"> | string
    position?: StringNullableFilter<"operators"> | string | null
    hire_date?: DateTimeNullableFilter<"operators"> | Date | string | null
    birth_date?: DateTimeNullableFilter<"operators"> | Date | string | null
    emergency_contact?: JsonNullableFilter<"operators">
    skills?: StringNullableListFilter<"operators">
    personal_id?: StringNullableFilter<"operators"> | string | null
    address?: StringNullableFilter<"operators"> | string | null
    activities?: ActivitiesListRelationFilter
    email_templates?: Email_templatesListRelationFilter
    invoices?: InvoicesListRelationFilter
    notifications_operator?: Notifications_operatorListRelationFilter
    branches?: XOR<BranchesScalarRelationFilter, branchesWhereInput>
    operator_types?: XOR<Operator_typesScalarRelationFilter, operator_typesWhereInput>
    packages?: PackagesListRelationFilter
  }, "id" | "email">

  export type operatorsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    branch_id?: SortOrder
    type_operator_id?: SortOrder
    position?: SortOrderInput | SortOrder
    hire_date?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    skills?: SortOrder
    personal_id?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _count?: operatorsCountOrderByAggregateInput
    _max?: operatorsMaxOrderByAggregateInput
    _min?: operatorsMinOrderByAggregateInput
  }

  export type operatorsScalarWhereWithAggregatesInput = {
    AND?: operatorsScalarWhereWithAggregatesInput | operatorsScalarWhereWithAggregatesInput[]
    OR?: operatorsScalarWhereWithAggregatesInput[]
    NOT?: operatorsScalarWhereWithAggregatesInput | operatorsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"operators"> | string
    created_at?: DateTimeWithAggregatesFilter<"operators"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"operators"> | Date | string | null
    email?: StringWithAggregatesFilter<"operators"> | string
    password?: StringWithAggregatesFilter<"operators"> | string
    first_name?: StringWithAggregatesFilter<"operators"> | string
    last_name?: StringWithAggregatesFilter<"operators"> | string
    phone?: StringNullableWithAggregatesFilter<"operators"> | string | null
    photo?: StringNullableWithAggregatesFilter<"operators"> | string | null
    role?: Enumoperator_role_enumWithAggregatesFilter<"operators"> | $Enums.operator_role_enum
    status?: Enumoperator_status_enumWithAggregatesFilter<"operators"> | $Enums.operator_status_enum
    last_login_at?: DateTimeNullableWithAggregatesFilter<"operators"> | Date | string | null
    branch_id?: UuidWithAggregatesFilter<"operators"> | string
    type_operator_id?: UuidWithAggregatesFilter<"operators"> | string
    position?: StringNullableWithAggregatesFilter<"operators"> | string | null
    hire_date?: DateTimeNullableWithAggregatesFilter<"operators"> | Date | string | null
    birth_date?: DateTimeNullableWithAggregatesFilter<"operators"> | Date | string | null
    emergency_contact?: JsonNullableWithAggregatesFilter<"operators">
    skills?: StringNullableListFilter<"operators">
    personal_id?: StringNullableWithAggregatesFilter<"operators"> | string | null
    address?: StringNullableWithAggregatesFilter<"operators"> | string | null
  }

  export type packagesWhereInput = {
    AND?: packagesWhereInput | packagesWhereInput[]
    OR?: packagesWhereInput[]
    NOT?: packagesWhereInput | packagesWhereInput[]
    id?: UuidFilter<"packages"> | string
    created_at?: DateTimeFilter<"packages"> | Date | string
    updated_at?: DateTimeNullableFilter<"packages"> | Date | string | null
    user_reference?: UuidNullableFilter<"packages"> | string | null
    package_status?: Enumpackage_status_enumFilter<"packages"> | $Enums.package_status_enum
    tracking_number?: StringNullableFilter<"packages"> | string | null
    height?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    width?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    length?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    insurance?: BoolNullableFilter<"packages"> | boolean | null
    shipping_stages?: JsonNullableListFilter<"packages">
    branch_id?: UuidNullableFilter<"packages"> | string | null
    notes?: StringNullableFilter<"packages"> | string | null
    declared_value?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    customs_information?: JsonNullableFilter<"packages">
    is_fragile?: BoolNullableFilter<"packages"> | boolean | null
    estimated_delivery_date?: DateTimeNullableFilter<"packages"> | Date | string | null
    operator_id?: UuidNullableFilter<"packages"> | string | null
    position?: StringNullableFilter<"packages"> | string | null
    invoice_packages?: Invoice_packagesListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    operators?: XOR<OperatorsNullableScalarRelationFilter, operatorsWhereInput> | null
  }

  export type packagesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_reference?: SortOrderInput | SortOrder
    package_status?: SortOrder
    tracking_number?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    volumetric_weight?: SortOrderInput | SortOrder
    insurance?: SortOrderInput | SortOrder
    shipping_stages?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    declared_value?: SortOrderInput | SortOrder
    customs_information?: SortOrderInput | SortOrder
    is_fragile?: SortOrderInput | SortOrder
    estimated_delivery_date?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    invoice_packages?: invoice_packagesOrderByRelationAggregateInput
    branches?: branchesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    operators?: operatorsOrderByWithRelationInput
  }

  export type packagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: packagesWhereInput | packagesWhereInput[]
    OR?: packagesWhereInput[]
    NOT?: packagesWhereInput | packagesWhereInput[]
    created_at?: DateTimeFilter<"packages"> | Date | string
    updated_at?: DateTimeNullableFilter<"packages"> | Date | string | null
    user_reference?: UuidNullableFilter<"packages"> | string | null
    package_status?: Enumpackage_status_enumFilter<"packages"> | $Enums.package_status_enum
    tracking_number?: StringNullableFilter<"packages"> | string | null
    height?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    width?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    length?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    insurance?: BoolNullableFilter<"packages"> | boolean | null
    shipping_stages?: JsonNullableListFilter<"packages">
    branch_id?: UuidNullableFilter<"packages"> | string | null
    notes?: StringNullableFilter<"packages"> | string | null
    declared_value?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    customs_information?: JsonNullableFilter<"packages">
    is_fragile?: BoolNullableFilter<"packages"> | boolean | null
    estimated_delivery_date?: DateTimeNullableFilter<"packages"> | Date | string | null
    operator_id?: UuidNullableFilter<"packages"> | string | null
    position?: StringNullableFilter<"packages"> | string | null
    invoice_packages?: Invoice_packagesListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    operators?: XOR<OperatorsNullableScalarRelationFilter, operatorsWhereInput> | null
  }, "id">

  export type packagesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_reference?: SortOrderInput | SortOrder
    package_status?: SortOrder
    tracking_number?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    volumetric_weight?: SortOrderInput | SortOrder
    insurance?: SortOrderInput | SortOrder
    shipping_stages?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    declared_value?: SortOrderInput | SortOrder
    customs_information?: SortOrderInput | SortOrder
    is_fragile?: SortOrderInput | SortOrder
    estimated_delivery_date?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    _count?: packagesCountOrderByAggregateInput
    _avg?: packagesAvgOrderByAggregateInput
    _max?: packagesMaxOrderByAggregateInput
    _min?: packagesMinOrderByAggregateInput
    _sum?: packagesSumOrderByAggregateInput
  }

  export type packagesScalarWhereWithAggregatesInput = {
    AND?: packagesScalarWhereWithAggregatesInput | packagesScalarWhereWithAggregatesInput[]
    OR?: packagesScalarWhereWithAggregatesInput[]
    NOT?: packagesScalarWhereWithAggregatesInput | packagesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"packages"> | string
    created_at?: DateTimeWithAggregatesFilter<"packages"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"packages"> | Date | string | null
    user_reference?: UuidNullableWithAggregatesFilter<"packages"> | string | null
    package_status?: Enumpackage_status_enumWithAggregatesFilter<"packages"> | $Enums.package_status_enum
    tracking_number?: StringNullableWithAggregatesFilter<"packages"> | string | null
    height?: DecimalNullableWithAggregatesFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    width?: DecimalNullableWithAggregatesFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    length?: DecimalNullableWithAggregatesFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableWithAggregatesFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: DecimalNullableWithAggregatesFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    insurance?: BoolNullableWithAggregatesFilter<"packages"> | boolean | null
    shipping_stages?: JsonNullableListFilter<"packages">
    branch_id?: UuidNullableWithAggregatesFilter<"packages"> | string | null
    notes?: StringNullableWithAggregatesFilter<"packages"> | string | null
    declared_value?: DecimalNullableWithAggregatesFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    customs_information?: JsonNullableWithAggregatesFilter<"packages">
    is_fragile?: BoolNullableWithAggregatesFilter<"packages"> | boolean | null
    estimated_delivery_date?: DateTimeNullableWithAggregatesFilter<"packages"> | Date | string | null
    operator_id?: UuidNullableWithAggregatesFilter<"packages"> | string | null
    position?: StringNullableWithAggregatesFilter<"packages"> | string | null
  }

  export type payment_typesWhereInput = {
    AND?: payment_typesWhereInput | payment_typesWhereInput[]
    OR?: payment_typesWhereInput[]
    NOT?: payment_typesWhereInput | payment_typesWhereInput[]
    id?: IntFilter<"payment_types"> | number
    name?: StringFilter<"payment_types"> | string
    description?: StringNullableFilter<"payment_types"> | string | null
    is_active?: BoolNullableFilter<"payment_types"> | boolean | null
    processing_fee_percentage?: DecimalNullableFilter<"payment_types"> | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: DecimalNullableFilter<"payment_types"> | Decimal | DecimalJsLike | number | string | null
    requires_approval?: BoolNullableFilter<"payment_types"> | boolean | null
    icon?: StringNullableFilter<"payment_types"> | string | null
    payment_methods?: Payment_methodsListRelationFilter
  }

  export type payment_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    processing_fee_percentage?: SortOrderInput | SortOrder
    processing_fee_fixed?: SortOrderInput | SortOrder
    requires_approval?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    payment_methods?: payment_methodsOrderByRelationAggregateInput
  }

  export type payment_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: payment_typesWhereInput | payment_typesWhereInput[]
    OR?: payment_typesWhereInput[]
    NOT?: payment_typesWhereInput | payment_typesWhereInput[]
    name?: StringFilter<"payment_types"> | string
    description?: StringNullableFilter<"payment_types"> | string | null
    is_active?: BoolNullableFilter<"payment_types"> | boolean | null
    processing_fee_percentage?: DecimalNullableFilter<"payment_types"> | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: DecimalNullableFilter<"payment_types"> | Decimal | DecimalJsLike | number | string | null
    requires_approval?: BoolNullableFilter<"payment_types"> | boolean | null
    icon?: StringNullableFilter<"payment_types"> | string | null
    payment_methods?: Payment_methodsListRelationFilter
  }, "id">

  export type payment_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    processing_fee_percentage?: SortOrderInput | SortOrder
    processing_fee_fixed?: SortOrderInput | SortOrder
    requires_approval?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    _count?: payment_typesCountOrderByAggregateInput
    _avg?: payment_typesAvgOrderByAggregateInput
    _max?: payment_typesMaxOrderByAggregateInput
    _min?: payment_typesMinOrderByAggregateInput
    _sum?: payment_typesSumOrderByAggregateInput
  }

  export type payment_typesScalarWhereWithAggregatesInput = {
    AND?: payment_typesScalarWhereWithAggregatesInput | payment_typesScalarWhereWithAggregatesInput[]
    OR?: payment_typesScalarWhereWithAggregatesInput[]
    NOT?: payment_typesScalarWhereWithAggregatesInput | payment_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payment_types"> | number
    name?: StringWithAggregatesFilter<"payment_types"> | string
    description?: StringNullableWithAggregatesFilter<"payment_types"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"payment_types"> | boolean | null
    processing_fee_percentage?: DecimalNullableWithAggregatesFilter<"payment_types"> | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: DecimalNullableWithAggregatesFilter<"payment_types"> | Decimal | DecimalJsLike | number | string | null
    requires_approval?: BoolNullableWithAggregatesFilter<"payment_types"> | boolean | null
    icon?: StringNullableWithAggregatesFilter<"payment_types"> | string | null
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: UuidFilter<"payments"> | string
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    invoice_id?: UuidFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: Enumpayment_method_enumFilter<"payments"> | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFilter<"payments"> | $Enums.payment_status_enum
    payment_provider?: StringNullableFilter<"payments"> | string | null
    currency?: StringNullableFilter<"payments"> | string | null
    exchange_rate?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    fees?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    payer_details?: JsonNullableFilter<"payments">
    receipt_url?: StringNullableFilter<"payments"> | string | null
    notes?: StringNullableFilter<"payments"> | string | null
    transaction_id?: UuidNullableFilter<"payments"> | string | null
    payment_method_id?: UuidNullableFilter<"payments"> | string | null
    payment_methods?: XOR<Payment_methodsNullableScalarRelationFilter, payment_methodsWhereInput> | null
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    transactions?: XOR<TransactionsNullableScalarRelationFilter, transactionsWhereInput> | null
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    payment_provider?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    exchange_rate?: SortOrderInput | SortOrder
    fees?: SortOrderInput | SortOrder
    payer_details?: SortOrderInput | SortOrder
    receipt_url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    payment_methods?: payment_methodsOrderByWithRelationInput
    invoices?: invoicesOrderByWithRelationInput
    transactions?: transactionsOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    invoice_id?: UuidFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: Enumpayment_method_enumFilter<"payments"> | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFilter<"payments"> | $Enums.payment_status_enum
    payment_provider?: StringNullableFilter<"payments"> | string | null
    currency?: StringNullableFilter<"payments"> | string | null
    exchange_rate?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    fees?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    payer_details?: JsonNullableFilter<"payments">
    receipt_url?: StringNullableFilter<"payments"> | string | null
    notes?: StringNullableFilter<"payments"> | string | null
    transaction_id?: UuidNullableFilter<"payments"> | string | null
    payment_method_id?: UuidNullableFilter<"payments"> | string | null
    payment_methods?: XOR<Payment_methodsNullableScalarRelationFilter, payment_methodsWhereInput> | null
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    transactions?: XOR<TransactionsNullableScalarRelationFilter, transactionsWhereInput> | null
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    payment_provider?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    exchange_rate?: SortOrderInput | SortOrder
    fees?: SortOrderInput | SortOrder
    payer_details?: SortOrderInput | SortOrder
    receipt_url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payments"> | string
    created_at?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    invoice_id?: UuidWithAggregatesFilter<"payments"> | string
    amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    payment_method?: Enumpayment_method_enumWithAggregatesFilter<"payments"> | $Enums.payment_method_enum
    status?: Enumpayment_status_enumWithAggregatesFilter<"payments"> | $Enums.payment_status_enum
    payment_provider?: StringNullableWithAggregatesFilter<"payments"> | string | null
    currency?: StringNullableWithAggregatesFilter<"payments"> | string | null
    exchange_rate?: DecimalNullableWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    fees?: DecimalNullableWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    payer_details?: JsonNullableWithAggregatesFilter<"payments">
    receipt_url?: StringNullableWithAggregatesFilter<"payments"> | string | null
    notes?: StringNullableWithAggregatesFilter<"payments"> | string | null
    transaction_id?: UuidNullableWithAggregatesFilter<"payments"> | string | null
    payment_method_id?: UuidNullableWithAggregatesFilter<"payments"> | string | null
  }

  export type plan_addressesWhereInput = {
    AND?: plan_addressesWhereInput | plan_addressesWhereInput[]
    OR?: plan_addressesWhereInput[]
    NOT?: plan_addressesWhereInput | plan_addressesWhereInput[]
    id?: UuidFilter<"plan_addresses"> | string
    created_at?: DateTimeFilter<"plan_addresses"> | Date | string
    updated_at?: DateTimeFilter<"plan_addresses"> | Date | string
    plan_id?: UuidFilter<"plan_addresses"> | string
    address_type?: StringFilter<"plan_addresses"> | string
    address_line1?: StringFilter<"plan_addresses"> | string
    address_line2?: StringFilter<"plan_addresses"> | string
    city?: StringFilter<"plan_addresses"> | string
    state?: StringFilter<"plan_addresses"> | string
    country?: StringFilter<"plan_addresses"> | string
    postal_code?: StringFilter<"plan_addresses"> | string
    contact_name?: StringNullableFilter<"plan_addresses"> | string | null
    contact_phone?: StringFilter<"plan_addresses"> | string
    is_primary?: BoolFilter<"plan_addresses"> | boolean
    additional_info?: JsonNullableFilter<"plan_addresses">
    plans?: XOR<PlansScalarRelationFilter, plansWhereInput>
  }

  export type plan_addressesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan_id?: SortOrder
    address_type?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    contact_name?: SortOrderInput | SortOrder
    contact_phone?: SortOrder
    is_primary?: SortOrder
    additional_info?: SortOrderInput | SortOrder
    plans?: plansOrderByWithRelationInput
  }

  export type plan_addressesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: plan_addressesWhereInput | plan_addressesWhereInput[]
    OR?: plan_addressesWhereInput[]
    NOT?: plan_addressesWhereInput | plan_addressesWhereInput[]
    created_at?: DateTimeFilter<"plan_addresses"> | Date | string
    updated_at?: DateTimeFilter<"plan_addresses"> | Date | string
    plan_id?: UuidFilter<"plan_addresses"> | string
    address_type?: StringFilter<"plan_addresses"> | string
    address_line1?: StringFilter<"plan_addresses"> | string
    address_line2?: StringFilter<"plan_addresses"> | string
    city?: StringFilter<"plan_addresses"> | string
    state?: StringFilter<"plan_addresses"> | string
    country?: StringFilter<"plan_addresses"> | string
    postal_code?: StringFilter<"plan_addresses"> | string
    contact_name?: StringNullableFilter<"plan_addresses"> | string | null
    contact_phone?: StringFilter<"plan_addresses"> | string
    is_primary?: BoolFilter<"plan_addresses"> | boolean
    additional_info?: JsonNullableFilter<"plan_addresses">
    plans?: XOR<PlansScalarRelationFilter, plansWhereInput>
  }, "id">

  export type plan_addressesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan_id?: SortOrder
    address_type?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    contact_name?: SortOrderInput | SortOrder
    contact_phone?: SortOrder
    is_primary?: SortOrder
    additional_info?: SortOrderInput | SortOrder
    _count?: plan_addressesCountOrderByAggregateInput
    _max?: plan_addressesMaxOrderByAggregateInput
    _min?: plan_addressesMinOrderByAggregateInput
  }

  export type plan_addressesScalarWhereWithAggregatesInput = {
    AND?: plan_addressesScalarWhereWithAggregatesInput | plan_addressesScalarWhereWithAggregatesInput[]
    OR?: plan_addressesScalarWhereWithAggregatesInput[]
    NOT?: plan_addressesScalarWhereWithAggregatesInput | plan_addressesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"plan_addresses"> | string
    created_at?: DateTimeWithAggregatesFilter<"plan_addresses"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"plan_addresses"> | Date | string
    plan_id?: UuidWithAggregatesFilter<"plan_addresses"> | string
    address_type?: StringWithAggregatesFilter<"plan_addresses"> | string
    address_line1?: StringWithAggregatesFilter<"plan_addresses"> | string
    address_line2?: StringWithAggregatesFilter<"plan_addresses"> | string
    city?: StringWithAggregatesFilter<"plan_addresses"> | string
    state?: StringWithAggregatesFilter<"plan_addresses"> | string
    country?: StringWithAggregatesFilter<"plan_addresses"> | string
    postal_code?: StringWithAggregatesFilter<"plan_addresses"> | string
    contact_name?: StringNullableWithAggregatesFilter<"plan_addresses"> | string | null
    contact_phone?: StringWithAggregatesFilter<"plan_addresses"> | string
    is_primary?: BoolWithAggregatesFilter<"plan_addresses"> | boolean
    additional_info?: JsonNullableWithAggregatesFilter<"plan_addresses">
  }

  export type plan_featuresWhereInput = {
    AND?: plan_featuresWhereInput | plan_featuresWhereInput[]
    OR?: plan_featuresWhereInput[]
    NOT?: plan_featuresWhereInput | plan_featuresWhereInput[]
    id?: UuidFilter<"plan_features"> | string
    created_at?: DateTimeFilter<"plan_features"> | Date | string
    updated_at?: DateTimeNullableFilter<"plan_features"> | Date | string | null
    plan_id?: UuidFilter<"plan_features"> | string
    feature_name?: StringFilter<"plan_features"> | string
    feature_value?: StringNullableFilter<"plan_features"> | string | null
    is_included?: BoolNullableFilter<"plan_features"> | boolean | null
    limit_quantity?: IntNullableFilter<"plan_features"> | number | null
    description?: StringNullableFilter<"plan_features"> | string | null
    plans?: XOR<PlansScalarRelationFilter, plansWhereInput>
  }

  export type plan_featuresOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    plan_id?: SortOrder
    feature_name?: SortOrder
    feature_value?: SortOrderInput | SortOrder
    is_included?: SortOrderInput | SortOrder
    limit_quantity?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    plans?: plansOrderByWithRelationInput
  }

  export type plan_featuresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: plan_featuresWhereInput | plan_featuresWhereInput[]
    OR?: plan_featuresWhereInput[]
    NOT?: plan_featuresWhereInput | plan_featuresWhereInput[]
    created_at?: DateTimeFilter<"plan_features"> | Date | string
    updated_at?: DateTimeNullableFilter<"plan_features"> | Date | string | null
    plan_id?: UuidFilter<"plan_features"> | string
    feature_name?: StringFilter<"plan_features"> | string
    feature_value?: StringNullableFilter<"plan_features"> | string | null
    is_included?: BoolNullableFilter<"plan_features"> | boolean | null
    limit_quantity?: IntNullableFilter<"plan_features"> | number | null
    description?: StringNullableFilter<"plan_features"> | string | null
    plans?: XOR<PlansScalarRelationFilter, plansWhereInput>
  }, "id">

  export type plan_featuresOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    plan_id?: SortOrder
    feature_name?: SortOrder
    feature_value?: SortOrderInput | SortOrder
    is_included?: SortOrderInput | SortOrder
    limit_quantity?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: plan_featuresCountOrderByAggregateInput
    _avg?: plan_featuresAvgOrderByAggregateInput
    _max?: plan_featuresMaxOrderByAggregateInput
    _min?: plan_featuresMinOrderByAggregateInput
    _sum?: plan_featuresSumOrderByAggregateInput
  }

  export type plan_featuresScalarWhereWithAggregatesInput = {
    AND?: plan_featuresScalarWhereWithAggregatesInput | plan_featuresScalarWhereWithAggregatesInput[]
    OR?: plan_featuresScalarWhereWithAggregatesInput[]
    NOT?: plan_featuresScalarWhereWithAggregatesInput | plan_featuresScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"plan_features"> | string
    created_at?: DateTimeWithAggregatesFilter<"plan_features"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"plan_features"> | Date | string | null
    plan_id?: UuidWithAggregatesFilter<"plan_features"> | string
    feature_name?: StringWithAggregatesFilter<"plan_features"> | string
    feature_value?: StringNullableWithAggregatesFilter<"plan_features"> | string | null
    is_included?: BoolNullableWithAggregatesFilter<"plan_features"> | boolean | null
    limit_quantity?: IntNullableWithAggregatesFilter<"plan_features"> | number | null
    description?: StringNullableWithAggregatesFilter<"plan_features"> | string | null
  }

  export type plansWhereInput = {
    AND?: plansWhereInput | plansWhereInput[]
    OR?: plansWhereInput[]
    NOT?: plansWhereInput | plansWhereInput[]
    id?: UuidFilter<"plans"> | string
    created_at?: DateTimeFilter<"plans"> | Date | string
    updated_at?: DateTimeNullableFilter<"plans"> | Date | string | null
    name?: StringFilter<"plans"> | string
    description?: StringNullableFilter<"plans"> | string | null
    price?: DecimalFilter<"plans"> | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFilter<"plans"> | string
    color?: StringNullableFilter<"plans"> | string | null
    is_active?: BoolNullableFilter<"plans"> | boolean | null
    branch_id?: UuidNullableFilter<"plans"> | string | null
    trial_period_days?: IntNullableFilter<"plans"> | number | null
    setup_fee?: DecimalNullableFilter<"plans"> | Decimal | DecimalJsLike | number | string | null
    max_users?: IntNullableFilter<"plans"> | number | null
    discounts?: JsonNullableFilter<"plans">
    invoice_items?: Invoice_itemsListRelationFilter
    plan_addresses?: Plan_addressesListRelationFilter
    plan_features?: Plan_featuresListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    users?: UsersListRelationFilter
  }

  export type plansOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    color?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    trial_period_days?: SortOrderInput | SortOrder
    setup_fee?: SortOrderInput | SortOrder
    max_users?: SortOrderInput | SortOrder
    discounts?: SortOrderInput | SortOrder
    invoice_items?: invoice_itemsOrderByRelationAggregateInput
    plan_addresses?: plan_addressesOrderByRelationAggregateInput
    plan_features?: plan_featuresOrderByRelationAggregateInput
    branches?: branchesOrderByWithRelationInput
    users?: usersOrderByRelationAggregateInput
  }

  export type plansWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: plansWhereInput | plansWhereInput[]
    OR?: plansWhereInput[]
    NOT?: plansWhereInput | plansWhereInput[]
    created_at?: DateTimeFilter<"plans"> | Date | string
    updated_at?: DateTimeNullableFilter<"plans"> | Date | string | null
    name?: StringFilter<"plans"> | string
    description?: StringNullableFilter<"plans"> | string | null
    price?: DecimalFilter<"plans"> | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFilter<"plans"> | string
    color?: StringNullableFilter<"plans"> | string | null
    is_active?: BoolNullableFilter<"plans"> | boolean | null
    branch_id?: UuidNullableFilter<"plans"> | string | null
    trial_period_days?: IntNullableFilter<"plans"> | number | null
    setup_fee?: DecimalNullableFilter<"plans"> | Decimal | DecimalJsLike | number | string | null
    max_users?: IntNullableFilter<"plans"> | number | null
    discounts?: JsonNullableFilter<"plans">
    invoice_items?: Invoice_itemsListRelationFilter
    plan_addresses?: Plan_addressesListRelationFilter
    plan_features?: Plan_featuresListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    users?: UsersListRelationFilter
  }, "id">

  export type plansOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    color?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    trial_period_days?: SortOrderInput | SortOrder
    setup_fee?: SortOrderInput | SortOrder
    max_users?: SortOrderInput | SortOrder
    discounts?: SortOrderInput | SortOrder
    _count?: plansCountOrderByAggregateInput
    _avg?: plansAvgOrderByAggregateInput
    _max?: plansMaxOrderByAggregateInput
    _min?: plansMinOrderByAggregateInput
    _sum?: plansSumOrderByAggregateInput
  }

  export type plansScalarWhereWithAggregatesInput = {
    AND?: plansScalarWhereWithAggregatesInput | plansScalarWhereWithAggregatesInput[]
    OR?: plansScalarWhereWithAggregatesInput[]
    NOT?: plansScalarWhereWithAggregatesInput | plansScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"plans"> | string
    created_at?: DateTimeWithAggregatesFilter<"plans"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"plans"> | Date | string | null
    name?: StringWithAggregatesFilter<"plans"> | string
    description?: StringNullableWithAggregatesFilter<"plans"> | string | null
    price?: DecimalWithAggregatesFilter<"plans"> | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringWithAggregatesFilter<"plans"> | string
    color?: StringNullableWithAggregatesFilter<"plans"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"plans"> | boolean | null
    branch_id?: UuidNullableWithAggregatesFilter<"plans"> | string | null
    trial_period_days?: IntNullableWithAggregatesFilter<"plans"> | number | null
    setup_fee?: DecimalNullableWithAggregatesFilter<"plans"> | Decimal | DecimalJsLike | number | string | null
    max_users?: IntNullableWithAggregatesFilter<"plans"> | number | null
    discounts?: JsonNullableWithAggregatesFilter<"plans">
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    id?: UuidFilter<"products"> | string
    created_at?: DateTimeFilter<"products"> | Date | string
    updated_at?: DateTimeNullableFilter<"products"> | Date | string | null
    name?: StringFilter<"products"> | string
    description?: StringNullableFilter<"products"> | string | null
    price?: DecimalFilter<"products"> | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    sku?: StringNullableFilter<"products"> | string | null
    barcode?: StringNullableFilter<"products"> | string | null
    stock_quantity?: IntNullableFilter<"products"> | number | null
    is_active?: BoolNullableFilter<"products"> | boolean | null
    status?: Enumproduct_status_enumNullableFilter<"products"> | $Enums.product_status_enum | null
    category_id?: UuidNullableFilter<"products"> | string | null
    branch_id?: UuidNullableFilter<"products"> | string | null
    weight?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"products">
    images?: StringNullableListFilter<"products">
    tags?: StringNullableListFilter<"products">
    min_stock_alert?: IntNullableFilter<"products"> | number | null
    manufacturer?: StringNullableFilter<"products"> | string | null
    tax_rate?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    invoice_items?: Invoice_itemsListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
  }

  export type productsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    sale_price?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    stock_quantity?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    images?: SortOrder
    tags?: SortOrder
    min_stock_alert?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    tax_rate?: SortOrderInput | SortOrder
    invoice_items?: invoice_itemsOrderByRelationAggregateInput
    branches?: branchesOrderByWithRelationInput
    categories?: categoriesOrderByWithRelationInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    created_at?: DateTimeFilter<"products"> | Date | string
    updated_at?: DateTimeNullableFilter<"products"> | Date | string | null
    name?: StringFilter<"products"> | string
    description?: StringNullableFilter<"products"> | string | null
    price?: DecimalFilter<"products"> | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    barcode?: StringNullableFilter<"products"> | string | null
    stock_quantity?: IntNullableFilter<"products"> | number | null
    is_active?: BoolNullableFilter<"products"> | boolean | null
    status?: Enumproduct_status_enumNullableFilter<"products"> | $Enums.product_status_enum | null
    category_id?: UuidNullableFilter<"products"> | string | null
    branch_id?: UuidNullableFilter<"products"> | string | null
    weight?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"products">
    images?: StringNullableListFilter<"products">
    tags?: StringNullableListFilter<"products">
    min_stock_alert?: IntNullableFilter<"products"> | number | null
    manufacturer?: StringNullableFilter<"products"> | string | null
    tax_rate?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    invoice_items?: Invoice_itemsListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
  }, "id" | "sku">

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    sale_price?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    stock_quantity?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    images?: SortOrder
    tags?: SortOrder
    min_stock_alert?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    tax_rate?: SortOrderInput | SortOrder
    _count?: productsCountOrderByAggregateInput
    _avg?: productsAvgOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
    _sum?: productsSumOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"products"> | string
    created_at?: DateTimeWithAggregatesFilter<"products"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"products"> | Date | string | null
    name?: StringWithAggregatesFilter<"products"> | string
    description?: StringNullableWithAggregatesFilter<"products"> | string | null
    price?: DecimalWithAggregatesFilter<"products"> | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalNullableWithAggregatesFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    sku?: StringNullableWithAggregatesFilter<"products"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"products"> | string | null
    stock_quantity?: IntNullableWithAggregatesFilter<"products"> | number | null
    is_active?: BoolNullableWithAggregatesFilter<"products"> | boolean | null
    status?: Enumproduct_status_enumNullableWithAggregatesFilter<"products"> | $Enums.product_status_enum | null
    category_id?: UuidNullableWithAggregatesFilter<"products"> | string | null
    branch_id?: UuidNullableWithAggregatesFilter<"products"> | string | null
    weight?: DecimalNullableWithAggregatesFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableWithAggregatesFilter<"products">
    images?: StringNullableListFilter<"products">
    tags?: StringNullableListFilter<"products">
    min_stock_alert?: IntNullableWithAggregatesFilter<"products"> | number | null
    manufacturer?: StringNullableWithAggregatesFilter<"products"> | string | null
    tax_rate?: DecimalNullableWithAggregatesFilter<"products"> | Decimal | DecimalJsLike | number | string | null
  }

  export type type_usersWhereInput = {
    AND?: type_usersWhereInput | type_usersWhereInput[]
    OR?: type_usersWhereInput[]
    NOT?: type_usersWhereInput | type_usersWhereInput[]
    id?: UuidFilter<"type_users"> | string
    created_at?: DateTimeFilter<"type_users"> | Date | string
    updated_at?: DateTimeNullableFilter<"type_users"> | Date | string | null
    code?: StringNullableFilter<"type_users"> | string | null
    description?: StringNullableFilter<"type_users"> | string | null
    name?: StringFilter<"type_users"> | string
    permissions?: JsonNullableFilter<"type_users">
    users?: UsersListRelationFilter
  }

  export type type_usersOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrder
    permissions?: SortOrderInput | SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type type_usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: type_usersWhereInput | type_usersWhereInput[]
    OR?: type_usersWhereInput[]
    NOT?: type_usersWhereInput | type_usersWhereInput[]
    created_at?: DateTimeFilter<"type_users"> | Date | string
    updated_at?: DateTimeNullableFilter<"type_users"> | Date | string | null
    code?: StringNullableFilter<"type_users"> | string | null
    description?: StringNullableFilter<"type_users"> | string | null
    name?: StringFilter<"type_users"> | string
    permissions?: JsonNullableFilter<"type_users">
    users?: UsersListRelationFilter
  }, "id">

  export type type_usersOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrder
    permissions?: SortOrderInput | SortOrder
    _count?: type_usersCountOrderByAggregateInput
    _max?: type_usersMaxOrderByAggregateInput
    _min?: type_usersMinOrderByAggregateInput
  }

  export type type_usersScalarWhereWithAggregatesInput = {
    AND?: type_usersScalarWhereWithAggregatesInput | type_usersScalarWhereWithAggregatesInput[]
    OR?: type_usersScalarWhereWithAggregatesInput[]
    NOT?: type_usersScalarWhereWithAggregatesInput | type_usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"type_users"> | string
    created_at?: DateTimeWithAggregatesFilter<"type_users"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"type_users"> | Date | string | null
    code?: StringNullableWithAggregatesFilter<"type_users"> | string | null
    description?: StringNullableWithAggregatesFilter<"type_users"> | string | null
    name?: StringWithAggregatesFilter<"type_users"> | string
    permissions?: JsonNullableWithAggregatesFilter<"type_users">
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: UuidFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    account_status?: BoolNullableFilter<"users"> | boolean | null
    birth_date?: DateTimeNullableFilter<"users"> | Date | string | null
    branch_id?: UuidNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    first_name?: StringNullableFilter<"users"> | string | null
    is_email_verified?: BoolNullableFilter<"users"> | boolean | null
    is_online?: BoolNullableFilter<"users"> | boolean | null
    is_verified?: BoolNullableFilter<"users"> | boolean | null
    last_name?: StringNullableFilter<"users"> | string | null
    last_seen?: DateTimeNullableFilter<"users"> | Date | string | null
    phone?: StringNullableFilter<"users"> | string | null
    photo_url?: StringNullableFilter<"users"> | string | null
    plan_id?: UuidNullableFilter<"users"> | string | null
    type_user_id?: UuidNullableFilter<"users"> | string | null
    shipping_insurance?: BoolFilter<"users"> | boolean
    is_business?: BoolNullableFilter<"users"> | boolean | null
    ruc?: StringNullableFilter<"users"> | string | null
    company_name?: StringNullableFilter<"users"> | string | null
    referral_source_id?: UuidNullableFilter<"users"> | string | null
    email_campaigns?: Email_campaignsListRelationFilter
    invoices?: InvoicesListRelationFilter
    notification_preferences?: Notification_preferencesListRelationFilter
    notification_users?: Notification_usersListRelationFilter
    packages?: PackagesListRelationFilter
    saved_cards?: Saved_cardsListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    plans?: XOR<PlansNullableScalarRelationFilter, plansWhereInput> | null
    referral_sources?: XOR<Referral_sourcesNullableScalarRelationFilter, referral_sourcesWhereInput> | null
    type_users?: XOR<Type_usersNullableScalarRelationFilter, type_usersWhereInput> | null
    wallets?: WalletsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    account_status?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    is_email_verified?: SortOrderInput | SortOrder
    is_online?: SortOrderInput | SortOrder
    is_verified?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    last_seen?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    photo_url?: SortOrderInput | SortOrder
    plan_id?: SortOrderInput | SortOrder
    type_user_id?: SortOrderInput | SortOrder
    shipping_insurance?: SortOrder
    is_business?: SortOrderInput | SortOrder
    ruc?: SortOrderInput | SortOrder
    company_name?: SortOrderInput | SortOrder
    referral_source_id?: SortOrderInput | SortOrder
    email_campaigns?: email_campaignsOrderByRelationAggregateInput
    invoices?: invoicesOrderByRelationAggregateInput
    notification_preferences?: notification_preferencesOrderByRelationAggregateInput
    notification_users?: notification_usersOrderByRelationAggregateInput
    packages?: packagesOrderByRelationAggregateInput
    saved_cards?: saved_cardsOrderByRelationAggregateInput
    branches?: branchesOrderByWithRelationInput
    plans?: plansOrderByWithRelationInput
    referral_sources?: referral_sourcesOrderByWithRelationInput
    type_users?: type_usersOrderByWithRelationInput
    wallets?: walletsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    ruc?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    account_status?: BoolNullableFilter<"users"> | boolean | null
    birth_date?: DateTimeNullableFilter<"users"> | Date | string | null
    branch_id?: UuidNullableFilter<"users"> | string | null
    first_name?: StringNullableFilter<"users"> | string | null
    is_email_verified?: BoolNullableFilter<"users"> | boolean | null
    is_online?: BoolNullableFilter<"users"> | boolean | null
    is_verified?: BoolNullableFilter<"users"> | boolean | null
    last_name?: StringNullableFilter<"users"> | string | null
    last_seen?: DateTimeNullableFilter<"users"> | Date | string | null
    phone?: StringNullableFilter<"users"> | string | null
    photo_url?: StringNullableFilter<"users"> | string | null
    plan_id?: UuidNullableFilter<"users"> | string | null
    type_user_id?: UuidNullableFilter<"users"> | string | null
    shipping_insurance?: BoolFilter<"users"> | boolean
    is_business?: BoolNullableFilter<"users"> | boolean | null
    company_name?: StringNullableFilter<"users"> | string | null
    referral_source_id?: UuidNullableFilter<"users"> | string | null
    email_campaigns?: Email_campaignsListRelationFilter
    invoices?: InvoicesListRelationFilter
    notification_preferences?: Notification_preferencesListRelationFilter
    notification_users?: Notification_usersListRelationFilter
    packages?: PackagesListRelationFilter
    saved_cards?: Saved_cardsListRelationFilter
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    plans?: XOR<PlansNullableScalarRelationFilter, plansWhereInput> | null
    referral_sources?: XOR<Referral_sourcesNullableScalarRelationFilter, referral_sourcesWhereInput> | null
    type_users?: XOR<Type_usersNullableScalarRelationFilter, type_usersWhereInput> | null
    wallets?: WalletsListRelationFilter
  }, "id" | "email" | "ruc">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    account_status?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    is_email_verified?: SortOrderInput | SortOrder
    is_online?: SortOrderInput | SortOrder
    is_verified?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    last_seen?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    photo_url?: SortOrderInput | SortOrder
    plan_id?: SortOrderInput | SortOrder
    type_user_id?: SortOrderInput | SortOrder
    shipping_insurance?: SortOrder
    is_business?: SortOrderInput | SortOrder
    ruc?: SortOrderInput | SortOrder
    company_name?: SortOrderInput | SortOrder
    referral_source_id?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"users"> | string
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    account_status?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    birth_date?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    branch_id?: UuidNullableWithAggregatesFilter<"users"> | string | null
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    is_email_verified?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    is_online?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    is_verified?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    last_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    last_seen?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    photo_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    plan_id?: UuidNullableWithAggregatesFilter<"users"> | string | null
    type_user_id?: UuidNullableWithAggregatesFilter<"users"> | string | null
    shipping_insurance?: BoolWithAggregatesFilter<"users"> | boolean
    is_business?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    ruc?: StringNullableWithAggregatesFilter<"users"> | string | null
    company_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    referral_source_id?: UuidNullableWithAggregatesFilter<"users"> | string | null
  }

  export type vehiclesWhereInput = {
    AND?: vehiclesWhereInput | vehiclesWhereInput[]
    OR?: vehiclesWhereInput[]
    NOT?: vehiclesWhereInput | vehiclesWhereInput[]
    id?: UuidFilter<"vehicles"> | string
    created_at?: DateTimeFilter<"vehicles"> | Date | string
    updated_at?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    make?: StringFilter<"vehicles"> | string
    model?: StringFilter<"vehicles"> | string
    year?: IntNullableFilter<"vehicles"> | number | null
    license_plate?: StringFilter<"vehicles"> | string
    status?: StringFilter<"vehicles"> | string
    branch_id?: UuidNullableFilter<"vehicles"> | string | null
    color?: StringNullableFilter<"vehicles"> | string | null
    vin?: StringNullableFilter<"vehicles"> | string | null
    purchase_date?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    last_maintenance_date?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    mileage?: IntNullableFilter<"vehicles"> | number | null
    fuel_type?: StringNullableFilter<"vehicles"> | string | null
    insurance_info?: JsonNullableFilter<"vehicles">
    technical_specs?: JsonNullableFilter<"vehicles">
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
  }

  export type vehiclesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrderInput | SortOrder
    license_plate?: SortOrder
    status?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    vin?: SortOrderInput | SortOrder
    purchase_date?: SortOrderInput | SortOrder
    last_maintenance_date?: SortOrderInput | SortOrder
    mileage?: SortOrderInput | SortOrder
    fuel_type?: SortOrderInput | SortOrder
    insurance_info?: SortOrderInput | SortOrder
    technical_specs?: SortOrderInput | SortOrder
    branches?: branchesOrderByWithRelationInput
  }

  export type vehiclesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    license_plate?: string
    vin?: string
    AND?: vehiclesWhereInput | vehiclesWhereInput[]
    OR?: vehiclesWhereInput[]
    NOT?: vehiclesWhereInput | vehiclesWhereInput[]
    created_at?: DateTimeFilter<"vehicles"> | Date | string
    updated_at?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    make?: StringFilter<"vehicles"> | string
    model?: StringFilter<"vehicles"> | string
    year?: IntNullableFilter<"vehicles"> | number | null
    status?: StringFilter<"vehicles"> | string
    branch_id?: UuidNullableFilter<"vehicles"> | string | null
    color?: StringNullableFilter<"vehicles"> | string | null
    purchase_date?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    last_maintenance_date?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    mileage?: IntNullableFilter<"vehicles"> | number | null
    fuel_type?: StringNullableFilter<"vehicles"> | string | null
    insurance_info?: JsonNullableFilter<"vehicles">
    technical_specs?: JsonNullableFilter<"vehicles">
    branches?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
  }, "id" | "license_plate" | "vin">

  export type vehiclesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrderInput | SortOrder
    license_plate?: SortOrder
    status?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    vin?: SortOrderInput | SortOrder
    purchase_date?: SortOrderInput | SortOrder
    last_maintenance_date?: SortOrderInput | SortOrder
    mileage?: SortOrderInput | SortOrder
    fuel_type?: SortOrderInput | SortOrder
    insurance_info?: SortOrderInput | SortOrder
    technical_specs?: SortOrderInput | SortOrder
    _count?: vehiclesCountOrderByAggregateInput
    _avg?: vehiclesAvgOrderByAggregateInput
    _max?: vehiclesMaxOrderByAggregateInput
    _min?: vehiclesMinOrderByAggregateInput
    _sum?: vehiclesSumOrderByAggregateInput
  }

  export type vehiclesScalarWhereWithAggregatesInput = {
    AND?: vehiclesScalarWhereWithAggregatesInput | vehiclesScalarWhereWithAggregatesInput[]
    OR?: vehiclesScalarWhereWithAggregatesInput[]
    NOT?: vehiclesScalarWhereWithAggregatesInput | vehiclesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"vehicles"> | string
    created_at?: DateTimeWithAggregatesFilter<"vehicles"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"vehicles"> | Date | string | null
    make?: StringWithAggregatesFilter<"vehicles"> | string
    model?: StringWithAggregatesFilter<"vehicles"> | string
    year?: IntNullableWithAggregatesFilter<"vehicles"> | number | null
    license_plate?: StringWithAggregatesFilter<"vehicles"> | string
    status?: StringWithAggregatesFilter<"vehicles"> | string
    branch_id?: UuidNullableWithAggregatesFilter<"vehicles"> | string | null
    color?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    vin?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    purchase_date?: DateTimeNullableWithAggregatesFilter<"vehicles"> | Date | string | null
    last_maintenance_date?: DateTimeNullableWithAggregatesFilter<"vehicles"> | Date | string | null
    mileage?: IntNullableWithAggregatesFilter<"vehicles"> | number | null
    fuel_type?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    insurance_info?: JsonNullableWithAggregatesFilter<"vehicles">
    technical_specs?: JsonNullableWithAggregatesFilter<"vehicles">
  }

  export type walletsWhereInput = {
    AND?: walletsWhereInput | walletsWhereInput[]
    OR?: walletsWhereInput[]
    NOT?: walletsWhereInput | walletsWhereInput[]
    id?: UuidFilter<"wallets"> | string
    created_at?: DateTimeFilter<"wallets"> | Date | string
    updated_at?: DateTimeNullableFilter<"wallets"> | Date | string | null
    balance?: DecimalNullableFilter<"wallets"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"wallets"> | string | null
    is_active?: BoolNullableFilter<"wallets"> | boolean | null
    last_transaction_date?: DateTimeNullableFilter<"wallets"> | Date | string | null
    user_id?: UuidNullableFilter<"wallets"> | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type walletsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_transaction_date?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type walletsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: walletsWhereInput | walletsWhereInput[]
    OR?: walletsWhereInput[]
    NOT?: walletsWhereInput | walletsWhereInput[]
    created_at?: DateTimeFilter<"wallets"> | Date | string
    updated_at?: DateTimeNullableFilter<"wallets"> | Date | string | null
    balance?: DecimalNullableFilter<"wallets"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"wallets"> | string | null
    is_active?: BoolNullableFilter<"wallets"> | boolean | null
    last_transaction_date?: DateTimeNullableFilter<"wallets"> | Date | string | null
    user_id?: UuidNullableFilter<"wallets"> | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type walletsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_transaction_date?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: walletsCountOrderByAggregateInput
    _avg?: walletsAvgOrderByAggregateInput
    _max?: walletsMaxOrderByAggregateInput
    _min?: walletsMinOrderByAggregateInput
    _sum?: walletsSumOrderByAggregateInput
  }

  export type walletsScalarWhereWithAggregatesInput = {
    AND?: walletsScalarWhereWithAggregatesInput | walletsScalarWhereWithAggregatesInput[]
    OR?: walletsScalarWhereWithAggregatesInput[]
    NOT?: walletsScalarWhereWithAggregatesInput | walletsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"wallets"> | string
    created_at?: DateTimeWithAggregatesFilter<"wallets"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"wallets"> | Date | string | null
    balance?: DecimalNullableWithAggregatesFilter<"wallets"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"wallets"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"wallets"> | boolean | null
    last_transaction_date?: DateTimeNullableWithAggregatesFilter<"wallets"> | Date | string | null
    user_id?: UuidNullableWithAggregatesFilter<"wallets"> | string | null
  }

  export type saved_cardsWhereInput = {
    AND?: saved_cardsWhereInput | saved_cardsWhereInput[]
    OR?: saved_cardsWhereInput[]
    NOT?: saved_cardsWhereInput | saved_cardsWhereInput[]
    id?: IntFilter<"saved_cards"> | number
    user_id?: UuidFilter<"saved_cards"> | string
    card_token?: StringFilter<"saved_cards"> | string
    card_type?: StringNullableFilter<"saved_cards"> | string | null
    cardholder_name?: StringNullableFilter<"saved_cards"> | string | null
    expiry_month?: IntFilter<"saved_cards"> | number
    expiry_year?: IntFilter<"saved_cards"> | number
    brand?: StringNullableFilter<"saved_cards"> | string | null
    last_four_digits?: StringNullableFilter<"saved_cards"> | string | null
    is_default?: BoolNullableFilter<"saved_cards"> | boolean | null
    created_at?: DateTimeNullableFilter<"saved_cards"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saved_cards"> | Date | string | null
    nick_name?: StringNullableFilter<"saved_cards"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type saved_cardsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_token?: SortOrder
    card_type?: SortOrderInput | SortOrder
    cardholder_name?: SortOrderInput | SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    brand?: SortOrderInput | SortOrder
    last_four_digits?: SortOrderInput | SortOrder
    is_default?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    nick_name?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type saved_cardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: saved_cardsWhereInput | saved_cardsWhereInput[]
    OR?: saved_cardsWhereInput[]
    NOT?: saved_cardsWhereInput | saved_cardsWhereInput[]
    user_id?: UuidFilter<"saved_cards"> | string
    card_token?: StringFilter<"saved_cards"> | string
    card_type?: StringNullableFilter<"saved_cards"> | string | null
    cardholder_name?: StringNullableFilter<"saved_cards"> | string | null
    expiry_month?: IntFilter<"saved_cards"> | number
    expiry_year?: IntFilter<"saved_cards"> | number
    brand?: StringNullableFilter<"saved_cards"> | string | null
    last_four_digits?: StringNullableFilter<"saved_cards"> | string | null
    is_default?: BoolNullableFilter<"saved_cards"> | boolean | null
    created_at?: DateTimeNullableFilter<"saved_cards"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saved_cards"> | Date | string | null
    nick_name?: StringNullableFilter<"saved_cards"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type saved_cardsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_token?: SortOrder
    card_type?: SortOrderInput | SortOrder
    cardholder_name?: SortOrderInput | SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    brand?: SortOrderInput | SortOrder
    last_four_digits?: SortOrderInput | SortOrder
    is_default?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    nick_name?: SortOrderInput | SortOrder
    _count?: saved_cardsCountOrderByAggregateInput
    _avg?: saved_cardsAvgOrderByAggregateInput
    _max?: saved_cardsMaxOrderByAggregateInput
    _min?: saved_cardsMinOrderByAggregateInput
    _sum?: saved_cardsSumOrderByAggregateInput
  }

  export type saved_cardsScalarWhereWithAggregatesInput = {
    AND?: saved_cardsScalarWhereWithAggregatesInput | saved_cardsScalarWhereWithAggregatesInput[]
    OR?: saved_cardsScalarWhereWithAggregatesInput[]
    NOT?: saved_cardsScalarWhereWithAggregatesInput | saved_cardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"saved_cards"> | number
    user_id?: UuidWithAggregatesFilter<"saved_cards"> | string
    card_token?: StringWithAggregatesFilter<"saved_cards"> | string
    card_type?: StringNullableWithAggregatesFilter<"saved_cards"> | string | null
    cardholder_name?: StringNullableWithAggregatesFilter<"saved_cards"> | string | null
    expiry_month?: IntWithAggregatesFilter<"saved_cards"> | number
    expiry_year?: IntWithAggregatesFilter<"saved_cards"> | number
    brand?: StringNullableWithAggregatesFilter<"saved_cards"> | string | null
    last_four_digits?: StringNullableWithAggregatesFilter<"saved_cards"> | string | null
    is_default?: BoolNullableWithAggregatesFilter<"saved_cards"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"saved_cards"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"saved_cards"> | Date | string | null
    nick_name?: StringNullableWithAggregatesFilter<"saved_cards"> | string | null
  }

  export type payment_methodsWhereInput = {
    AND?: payment_methodsWhereInput | payment_methodsWhereInput[]
    OR?: payment_methodsWhereInput[]
    NOT?: payment_methodsWhereInput | payment_methodsWhereInput[]
    id?: UuidFilter<"payment_methods"> | string
    created_at?: DateTimeNullableFilter<"payment_methods"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payment_methods"> | Date | string | null
    name?: StringFilter<"payment_methods"> | string
    is_active?: BoolNullableFilter<"payment_methods"> | boolean | null
    details?: JsonNullableFilter<"payment_methods">
    payment_type_id?: IntNullableFilter<"payment_methods"> | number | null
    payment_types?: XOR<Payment_typesNullableScalarRelationFilter, payment_typesWhereInput> | null
    payments?: PaymentsListRelationFilter
    transactions?: TransactionsListRelationFilter
  }

  export type payment_methodsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    is_active?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    payment_type_id?: SortOrderInput | SortOrder
    payment_types?: payment_typesOrderByWithRelationInput
    payments?: paymentsOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
  }

  export type payment_methodsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: payment_methodsWhereInput | payment_methodsWhereInput[]
    OR?: payment_methodsWhereInput[]
    NOT?: payment_methodsWhereInput | payment_methodsWhereInput[]
    created_at?: DateTimeNullableFilter<"payment_methods"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payment_methods"> | Date | string | null
    name?: StringFilter<"payment_methods"> | string
    is_active?: BoolNullableFilter<"payment_methods"> | boolean | null
    details?: JsonNullableFilter<"payment_methods">
    payment_type_id?: IntNullableFilter<"payment_methods"> | number | null
    payment_types?: XOR<Payment_typesNullableScalarRelationFilter, payment_typesWhereInput> | null
    payments?: PaymentsListRelationFilter
    transactions?: TransactionsListRelationFilter
  }, "id">

  export type payment_methodsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    is_active?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    payment_type_id?: SortOrderInput | SortOrder
    _count?: payment_methodsCountOrderByAggregateInput
    _avg?: payment_methodsAvgOrderByAggregateInput
    _max?: payment_methodsMaxOrderByAggregateInput
    _min?: payment_methodsMinOrderByAggregateInput
    _sum?: payment_methodsSumOrderByAggregateInput
  }

  export type payment_methodsScalarWhereWithAggregatesInput = {
    AND?: payment_methodsScalarWhereWithAggregatesInput | payment_methodsScalarWhereWithAggregatesInput[]
    OR?: payment_methodsScalarWhereWithAggregatesInput[]
    NOT?: payment_methodsScalarWhereWithAggregatesInput | payment_methodsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payment_methods"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"payment_methods"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"payment_methods"> | Date | string | null
    name?: StringWithAggregatesFilter<"payment_methods"> | string
    is_active?: BoolNullableWithAggregatesFilter<"payment_methods"> | boolean | null
    details?: JsonNullableWithAggregatesFilter<"payment_methods">
    payment_type_id?: IntNullableWithAggregatesFilter<"payment_methods"> | number | null
  }

  export type transaction_categoriesWhereInput = {
    AND?: transaction_categoriesWhereInput | transaction_categoriesWhereInput[]
    OR?: transaction_categoriesWhereInput[]
    NOT?: transaction_categoriesWhereInput | transaction_categoriesWhereInput[]
    id?: UuidFilter<"transaction_categories"> | string
    created_at?: DateTimeNullableFilter<"transaction_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transaction_categories"> | Date | string | null
    name?: StringFilter<"transaction_categories"> | string
    description?: StringNullableFilter<"transaction_categories"> | string | null
    parent_id?: UuidNullableFilter<"transaction_categories"> | string | null
    is_active?: BoolNullableFilter<"transaction_categories"> | boolean | null
    transaction_categories?: XOR<Transaction_categoriesNullableScalarRelationFilter, transaction_categoriesWhereInput> | null
    other_transaction_categories?: Transaction_categoriesListRelationFilter
    transactions?: TransactionsListRelationFilter
  }

  export type transaction_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    transaction_categories?: transaction_categoriesOrderByWithRelationInput
    other_transaction_categories?: transaction_categoriesOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
  }

  export type transaction_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transaction_categoriesWhereInput | transaction_categoriesWhereInput[]
    OR?: transaction_categoriesWhereInput[]
    NOT?: transaction_categoriesWhereInput | transaction_categoriesWhereInput[]
    created_at?: DateTimeNullableFilter<"transaction_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transaction_categories"> | Date | string | null
    name?: StringFilter<"transaction_categories"> | string
    description?: StringNullableFilter<"transaction_categories"> | string | null
    parent_id?: UuidNullableFilter<"transaction_categories"> | string | null
    is_active?: BoolNullableFilter<"transaction_categories"> | boolean | null
    transaction_categories?: XOR<Transaction_categoriesNullableScalarRelationFilter, transaction_categoriesWhereInput> | null
    other_transaction_categories?: Transaction_categoriesListRelationFilter
    transactions?: TransactionsListRelationFilter
  }, "id">

  export type transaction_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: transaction_categoriesCountOrderByAggregateInput
    _max?: transaction_categoriesMaxOrderByAggregateInput
    _min?: transaction_categoriesMinOrderByAggregateInput
  }

  export type transaction_categoriesScalarWhereWithAggregatesInput = {
    AND?: transaction_categoriesScalarWhereWithAggregatesInput | transaction_categoriesScalarWhereWithAggregatesInput[]
    OR?: transaction_categoriesScalarWhereWithAggregatesInput[]
    NOT?: transaction_categoriesScalarWhereWithAggregatesInput | transaction_categoriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"transaction_categories"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"transaction_categories"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"transaction_categories"> | Date | string | null
    name?: StringWithAggregatesFilter<"transaction_categories"> | string
    description?: StringNullableWithAggregatesFilter<"transaction_categories"> | string | null
    parent_id?: UuidNullableWithAggregatesFilter<"transaction_categories"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"transaction_categories"> | boolean | null
  }

  export type transactionsWhereInput = {
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    id?: UuidFilter<"transactions"> | string
    created_at?: DateTimeNullableFilter<"transactions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transactions"> | Date | string | null
    description?: StringNullableFilter<"transactions"> | string | null
    status?: StringFilter<"transactions"> | string
    transaction_date?: DateTimeNullableFilter<"transactions"> | Date | string | null
    transaction_type?: StringFilter<"transactions"> | string
    reference_id?: UuidNullableFilter<"transactions"> | string | null
    entity_type?: StringNullableFilter<"transactions"> | string | null
    entity_id?: UuidNullableFilter<"transactions"> | string | null
    payment_method_id?: UuidNullableFilter<"transactions"> | string | null
    metadata?: JsonNullableFilter<"transactions">
    category_id?: UuidNullableFilter<"transactions"> | string | null
    transaction_type_id?: UuidNullableFilter<"transactions"> | string | null
    amount?: DecimalNullableFilter<"transactions"> | Decimal | DecimalJsLike | number | string | null
    payments?: PaymentsListRelationFilter
    transaction_categories?: XOR<Transaction_categoriesNullableScalarRelationFilter, transaction_categoriesWhereInput> | null
    payment_methods?: XOR<Payment_methodsNullableScalarRelationFilter, payment_methodsWhereInput> | null
    transaction_types?: XOR<Transaction_typesNullableScalarRelationFilter, transaction_typesWhereInput> | null
  }

  export type transactionsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    transaction_date?: SortOrderInput | SortOrder
    transaction_type?: SortOrder
    reference_id?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    entity_id?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    transaction_type_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    payments?: paymentsOrderByRelationAggregateInput
    transaction_categories?: transaction_categoriesOrderByWithRelationInput
    payment_methods?: payment_methodsOrderByWithRelationInput
    transaction_types?: transaction_typesOrderByWithRelationInput
  }

  export type transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    created_at?: DateTimeNullableFilter<"transactions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transactions"> | Date | string | null
    description?: StringNullableFilter<"transactions"> | string | null
    status?: StringFilter<"transactions"> | string
    transaction_date?: DateTimeNullableFilter<"transactions"> | Date | string | null
    transaction_type?: StringFilter<"transactions"> | string
    reference_id?: UuidNullableFilter<"transactions"> | string | null
    entity_type?: StringNullableFilter<"transactions"> | string | null
    entity_id?: UuidNullableFilter<"transactions"> | string | null
    payment_method_id?: UuidNullableFilter<"transactions"> | string | null
    metadata?: JsonNullableFilter<"transactions">
    category_id?: UuidNullableFilter<"transactions"> | string | null
    transaction_type_id?: UuidNullableFilter<"transactions"> | string | null
    amount?: DecimalNullableFilter<"transactions"> | Decimal | DecimalJsLike | number | string | null
    payments?: PaymentsListRelationFilter
    transaction_categories?: XOR<Transaction_categoriesNullableScalarRelationFilter, transaction_categoriesWhereInput> | null
    payment_methods?: XOR<Payment_methodsNullableScalarRelationFilter, payment_methodsWhereInput> | null
    transaction_types?: XOR<Transaction_typesNullableScalarRelationFilter, transaction_typesWhereInput> | null
  }, "id">

  export type transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    transaction_date?: SortOrderInput | SortOrder
    transaction_type?: SortOrder
    reference_id?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    entity_id?: SortOrderInput | SortOrder
    payment_method_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    transaction_type_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    _count?: transactionsCountOrderByAggregateInput
    _avg?: transactionsAvgOrderByAggregateInput
    _max?: transactionsMaxOrderByAggregateInput
    _min?: transactionsMinOrderByAggregateInput
    _sum?: transactionsSumOrderByAggregateInput
  }

  export type transactionsScalarWhereWithAggregatesInput = {
    AND?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    OR?: transactionsScalarWhereWithAggregatesInput[]
    NOT?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"transactions"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"transactions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"transactions"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    status?: StringWithAggregatesFilter<"transactions"> | string
    transaction_date?: DateTimeNullableWithAggregatesFilter<"transactions"> | Date | string | null
    transaction_type?: StringWithAggregatesFilter<"transactions"> | string
    reference_id?: UuidNullableWithAggregatesFilter<"transactions"> | string | null
    entity_type?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    entity_id?: UuidNullableWithAggregatesFilter<"transactions"> | string | null
    payment_method_id?: UuidNullableWithAggregatesFilter<"transactions"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"transactions">
    category_id?: UuidNullableWithAggregatesFilter<"transactions"> | string | null
    transaction_type_id?: UuidNullableWithAggregatesFilter<"transactions"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"transactions"> | Decimal | DecimalJsLike | number | string | null
  }

  export type transaction_typesWhereInput = {
    AND?: transaction_typesWhereInput | transaction_typesWhereInput[]
    OR?: transaction_typesWhereInput[]
    NOT?: transaction_typesWhereInput | transaction_typesWhereInput[]
    id?: UuidFilter<"transaction_types"> | string
    created_at?: DateTimeNullableFilter<"transaction_types"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transaction_types"> | Date | string | null
    code?: StringFilter<"transaction_types"> | string
    name?: StringFilter<"transaction_types"> | string
    description?: StringNullableFilter<"transaction_types"> | string | null
    affects_balance?: StringFilter<"transaction_types"> | string
    is_active?: BoolNullableFilter<"transaction_types"> | boolean | null
    transactions?: TransactionsListRelationFilter
  }

  export type transaction_typesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    affects_balance?: SortOrder
    is_active?: SortOrderInput | SortOrder
    transactions?: transactionsOrderByRelationAggregateInput
  }

  export type transaction_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: transaction_typesWhereInput | transaction_typesWhereInput[]
    OR?: transaction_typesWhereInput[]
    NOT?: transaction_typesWhereInput | transaction_typesWhereInput[]
    created_at?: DateTimeNullableFilter<"transaction_types"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transaction_types"> | Date | string | null
    name?: StringFilter<"transaction_types"> | string
    description?: StringNullableFilter<"transaction_types"> | string | null
    affects_balance?: StringFilter<"transaction_types"> | string
    is_active?: BoolNullableFilter<"transaction_types"> | boolean | null
    transactions?: TransactionsListRelationFilter
  }, "id" | "code">

  export type transaction_typesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    affects_balance?: SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: transaction_typesCountOrderByAggregateInput
    _max?: transaction_typesMaxOrderByAggregateInput
    _min?: transaction_typesMinOrderByAggregateInput
  }

  export type transaction_typesScalarWhereWithAggregatesInput = {
    AND?: transaction_typesScalarWhereWithAggregatesInput | transaction_typesScalarWhereWithAggregatesInput[]
    OR?: transaction_typesScalarWhereWithAggregatesInput[]
    NOT?: transaction_typesScalarWhereWithAggregatesInput | transaction_typesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"transaction_types"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"transaction_types"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"transaction_types"> | Date | string | null
    code?: StringWithAggregatesFilter<"transaction_types"> | string
    name?: StringWithAggregatesFilter<"transaction_types"> | string
    description?: StringNullableWithAggregatesFilter<"transaction_types"> | string | null
    affects_balance?: StringWithAggregatesFilter<"transaction_types"> | string
    is_active?: BoolNullableWithAggregatesFilter<"transaction_types"> | boolean | null
  }

  export type referral_sourcesWhereInput = {
    AND?: referral_sourcesWhereInput | referral_sourcesWhereInput[]
    OR?: referral_sourcesWhereInput[]
    NOT?: referral_sourcesWhereInput | referral_sourcesWhereInput[]
    id?: UuidFilter<"referral_sources"> | string
    source_name?: StringFilter<"referral_sources"> | string
    users?: UsersListRelationFilter
  }

  export type referral_sourcesOrderByWithRelationInput = {
    id?: SortOrder
    source_name?: SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type referral_sourcesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    source_name?: string
    AND?: referral_sourcesWhereInput | referral_sourcesWhereInput[]
    OR?: referral_sourcesWhereInput[]
    NOT?: referral_sourcesWhereInput | referral_sourcesWhereInput[]
    users?: UsersListRelationFilter
  }, "id" | "source_name">

  export type referral_sourcesOrderByWithAggregationInput = {
    id?: SortOrder
    source_name?: SortOrder
    _count?: referral_sourcesCountOrderByAggregateInput
    _max?: referral_sourcesMaxOrderByAggregateInput
    _min?: referral_sourcesMinOrderByAggregateInput
  }

  export type referral_sourcesScalarWhereWithAggregatesInput = {
    AND?: referral_sourcesScalarWhereWithAggregatesInput | referral_sourcesScalarWhereWithAggregatesInput[]
    OR?: referral_sourcesScalarWhereWithAggregatesInput[]
    NOT?: referral_sourcesScalarWhereWithAggregatesInput | referral_sourcesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"referral_sources"> | string
    source_name?: StringWithAggregatesFilter<"referral_sources"> | string
  }

  export type cash_closuresWhereInput = {
    AND?: cash_closuresWhereInput | cash_closuresWhereInput[]
    OR?: cash_closuresWhereInput[]
    NOT?: cash_closuresWhereInput | cash_closuresWhereInput[]
    id?: UuidFilter<"cash_closures"> | string
    created_at?: DateTimeFilter<"cash_closures"> | Date | string
    cash_closures?: DateTimeFilter<"cash_closures"> | Date | string
    total_cash?: FloatFilter<"cash_closures"> | number
    total_yappy?: FloatFilter<"cash_closures"> | number
    total_card?: FloatFilter<"cash_closures"> | number
    total_bank_transfer?: FloatFilter<"cash_closures"> | number
    total_digital_wallet?: FloatFilter<"cash_closures"> | number
    total_internal_wallet?: FloatFilter<"cash_closures"> | number
    total_credits?: FloatFilter<"cash_closures"> | number
    total_debits?: FloatFilter<"cash_closures"> | number
    final_balance?: FloatFilter<"cash_closures"> | number
    status?: StringFilter<"cash_closures"> | string
  }

  export type cash_closuresOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    cash_closures?: SortOrder
    total_cash?: SortOrder
    total_yappy?: SortOrder
    total_card?: SortOrder
    total_bank_transfer?: SortOrder
    total_digital_wallet?: SortOrder
    total_internal_wallet?: SortOrder
    total_credits?: SortOrder
    total_debits?: SortOrder
    final_balance?: SortOrder
    status?: SortOrder
  }

  export type cash_closuresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cash_closuresWhereInput | cash_closuresWhereInput[]
    OR?: cash_closuresWhereInput[]
    NOT?: cash_closuresWhereInput | cash_closuresWhereInput[]
    created_at?: DateTimeFilter<"cash_closures"> | Date | string
    cash_closures?: DateTimeFilter<"cash_closures"> | Date | string
    total_cash?: FloatFilter<"cash_closures"> | number
    total_yappy?: FloatFilter<"cash_closures"> | number
    total_card?: FloatFilter<"cash_closures"> | number
    total_bank_transfer?: FloatFilter<"cash_closures"> | number
    total_digital_wallet?: FloatFilter<"cash_closures"> | number
    total_internal_wallet?: FloatFilter<"cash_closures"> | number
    total_credits?: FloatFilter<"cash_closures"> | number
    total_debits?: FloatFilter<"cash_closures"> | number
    final_balance?: FloatFilter<"cash_closures"> | number
    status?: StringFilter<"cash_closures"> | string
  }, "id">

  export type cash_closuresOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    cash_closures?: SortOrder
    total_cash?: SortOrder
    total_yappy?: SortOrder
    total_card?: SortOrder
    total_bank_transfer?: SortOrder
    total_digital_wallet?: SortOrder
    total_internal_wallet?: SortOrder
    total_credits?: SortOrder
    total_debits?: SortOrder
    final_balance?: SortOrder
    status?: SortOrder
    _count?: cash_closuresCountOrderByAggregateInput
    _avg?: cash_closuresAvgOrderByAggregateInput
    _max?: cash_closuresMaxOrderByAggregateInput
    _min?: cash_closuresMinOrderByAggregateInput
    _sum?: cash_closuresSumOrderByAggregateInput
  }

  export type cash_closuresScalarWhereWithAggregatesInput = {
    AND?: cash_closuresScalarWhereWithAggregatesInput | cash_closuresScalarWhereWithAggregatesInput[]
    OR?: cash_closuresScalarWhereWithAggregatesInput[]
    NOT?: cash_closuresScalarWhereWithAggregatesInput | cash_closuresScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"cash_closures"> | string
    created_at?: DateTimeWithAggregatesFilter<"cash_closures"> | Date | string
    cash_closures?: DateTimeWithAggregatesFilter<"cash_closures"> | Date | string
    total_cash?: FloatWithAggregatesFilter<"cash_closures"> | number
    total_yappy?: FloatWithAggregatesFilter<"cash_closures"> | number
    total_card?: FloatWithAggregatesFilter<"cash_closures"> | number
    total_bank_transfer?: FloatWithAggregatesFilter<"cash_closures"> | number
    total_digital_wallet?: FloatWithAggregatesFilter<"cash_closures"> | number
    total_internal_wallet?: FloatWithAggregatesFilter<"cash_closures"> | number
    total_credits?: FloatWithAggregatesFilter<"cash_closures"> | number
    total_debits?: FloatWithAggregatesFilter<"cash_closures"> | number
    final_balance?: FloatWithAggregatesFilter<"cash_closures"> | number
    status?: StringWithAggregatesFilter<"cash_closures"> | string
  }

  export type activitiesCreateInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    branches?: branchesCreateNestedOneWithoutActivitiesInput
    operators?: operatorsCreateNestedOneWithoutActivitiesInput
  }

  export type activitiesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    operator_id?: string | null
    branch_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    branches?: branchesUpdateOneWithoutActivitiesNestedInput
    operators?: operatorsUpdateOneWithoutActivitiesNestedInput
  }

  export type activitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesCreateManyInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    operator_id?: string | null
    branch_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type branchesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type branchesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
  }

  export type branchesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type branchesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    icon?: string | null
    is_active?: boolean | null
    order_position?: number | null
    products?: productsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    icon?: string | null
    is_active?: boolean | null
    order_position?: number | null
    products?: productsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_position?: NullableIntFieldUpdateOperationsInput | number | null
    products?: productsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_position?: NullableIntFieldUpdateOperationsInput | number | null
    products?: productsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    icon?: string | null
    is_active?: boolean | null
    order_position?: number | null
  }

  export type categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type companiesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    email?: string | null
    phone?: string | null
    ruc?: string | null
    logo_url?: string | null
    website?: string | null
    tax_id?: string | null
    business_type?: string | null
    industry?: string | null
    founded_date?: Date | string | null
    is_active?: boolean | null
    branches?: branchesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    email?: string | null
    phone?: string | null
    ruc?: string | null
    logo_url?: string | null
    website?: string | null
    tax_id?: string | null
    business_type?: string | null
    industry?: string | null
    founded_date?: Date | string | null
    is_active?: boolean | null
    branches?: branchesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    founded_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branches?: branchesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    founded_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branches?: branchesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    email?: string | null
    phone?: string | null
    ruc?: string | null
    logo_url?: string | null
    website?: string | null
    tax_id?: string | null
    business_type?: string | null
    industry?: string | null
    founded_date?: Date | string | null
    is_active?: boolean | null
  }

  export type companiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    founded_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    founded_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type email_campaignsCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
    email_templates?: email_templatesCreateNestedOneWithoutEmail_campaignsInput
    users?: usersCreateNestedOneWithoutEmail_campaignsInput
  }

  export type email_campaignsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    user_id?: string | null
    template_id?: string | null
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
    email_templates?: email_templatesUpdateOneWithoutEmail_campaignsNestedInput
    users?: usersUpdateOneWithoutEmail_campaignsNestedInput
  }

  export type email_campaignsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    template_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    user_id?: string | null
    template_id?: string | null
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    template_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_templatesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject?: string | null
    body?: string | null
    html_body?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    category?: string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean | null
    version?: number | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutEmail_templatesInput
    operators?: operatorsCreateNestedOneWithoutEmail_templatesInput
  }

  export type email_templatesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject?: string | null
    body?: string | null
    html_body?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    operator_id?: string | null
    category?: string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean | null
    version?: number | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutEmail_templatesInput
  }

  export type email_templatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    email_campaigns?: email_campaignsUpdateManyWithoutEmail_templatesNestedInput
    operators?: operatorsUpdateOneWithoutEmail_templatesNestedInput
  }

  export type email_templatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutEmail_templatesNestedInput
  }

  export type email_templatesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject?: string | null
    body?: string | null
    html_body?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    operator_id?: string | null
    category?: string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean | null
    version?: number | null
  }

  export type email_templatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type email_templatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gift_cardsCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    issue_date?: Date | string
    expiry_date?: Date | string | null
    recipient_name?: string | null
    recipient_email?: string | null
    sender_id?: string | null
    redeemed_at?: Date | string | null
    message?: string | null
    payment_method?: $Enums.payment_method_enum | null
    send_date?: Date | string | null
    design_template?: string | null
    is_reloadable?: boolean | null
    access_pin?: string | null
    usage_history?: gift_cardsCreateusage_historyInput | InputJsonValue[]
    branches?: branchesCreateNestedOneWithoutGift_cardsInput
  }

  export type gift_cardsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    issue_date?: Date | string
    expiry_date?: Date | string | null
    recipient_name?: string | null
    recipient_email?: string | null
    sender_id?: string | null
    redeemed_at?: Date | string | null
    message?: string | null
    payment_method?: $Enums.payment_method_enum | null
    send_date?: Date | string | null
    design_template?: string | null
    branch_id?: string | null
    is_reloadable?: boolean | null
    access_pin?: string | null
    usage_history?: gift_cardsCreateusage_historyInput | InputJsonValue[]
  }

  export type gift_cardsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    recipient_email?: NullableStringFieldUpdateOperationsInput | string | null
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    redeemed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableEnumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    design_template?: NullableStringFieldUpdateOperationsInput | string | null
    is_reloadable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_pin?: NullableStringFieldUpdateOperationsInput | string | null
    usage_history?: gift_cardsUpdateusage_historyInput | InputJsonValue[]
    branches?: branchesUpdateOneWithoutGift_cardsNestedInput
  }

  export type gift_cardsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    recipient_email?: NullableStringFieldUpdateOperationsInput | string | null
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    redeemed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableEnumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    design_template?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_reloadable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_pin?: NullableStringFieldUpdateOperationsInput | string | null
    usage_history?: gift_cardsUpdateusage_historyInput | InputJsonValue[]
  }

  export type gift_cardsCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    issue_date?: Date | string
    expiry_date?: Date | string | null
    recipient_name?: string | null
    recipient_email?: string | null
    sender_id?: string | null
    redeemed_at?: Date | string | null
    message?: string | null
    payment_method?: $Enums.payment_method_enum | null
    send_date?: Date | string | null
    design_template?: string | null
    branch_id?: string | null
    is_reloadable?: boolean | null
    access_pin?: string | null
    usage_history?: gift_cardsCreateusage_historyInput | InputJsonValue[]
  }

  export type gift_cardsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    recipient_email?: NullableStringFieldUpdateOperationsInput | string | null
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    redeemed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableEnumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    design_template?: NullableStringFieldUpdateOperationsInput | string | null
    is_reloadable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_pin?: NullableStringFieldUpdateOperationsInput | string | null
    usage_history?: gift_cardsUpdateusage_historyInput | InputJsonValue[]
  }

  export type gift_cardsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    recipient_email?: NullableStringFieldUpdateOperationsInput | string | null
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    redeemed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableEnumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    design_template?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_reloadable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_pin?: NullableStringFieldUpdateOperationsInput | string | null
    usage_history?: gift_cardsUpdateusage_historyInput | InputJsonValue[]
  }

  export type invoice_itemsCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
    invoices: invoicesCreateNestedOneWithoutInvoice_itemsInput
    plans?: plansCreateNestedOneWithoutInvoice_itemsInput
    products?: productsCreateNestedOneWithoutInvoice_itemsInput
  }

  export type invoice_itemsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    product_id?: string | null
    plan_id?: string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
  }

  export type invoice_itemsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
    invoices?: invoicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
    plans?: plansUpdateOneWithoutInvoice_itemsNestedInput
    products?: productsUpdateOneWithoutInvoice_itemsNestedInput
  }

  export type invoice_itemsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type invoice_itemsCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    product_id?: string | null
    plan_id?: string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
  }

  export type invoice_itemsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type invoice_itemsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type invoice_packagesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoices: invoicesCreateNestedOneWithoutInvoice_packagesInput
    packages: packagesCreateNestedOneWithoutInvoice_packagesInput
  }

  export type invoice_packagesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    package_id: string
  }

  export type invoice_packagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: invoicesUpdateOneRequiredWithoutInvoice_packagesNestedInput
    packages?: packagesUpdateOneRequiredWithoutInvoice_packagesNestedInput
  }

  export type invoice_packagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_packagesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    package_id: string
  }

  export type invoice_packagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type invoice_packagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
  }

  export type invoicesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesCreateNestedManyWithoutInvoicesInput
    branches?: branchesCreateNestedOneWithoutInvoicesInput
    operators?: operatorsCreateNestedOneWithoutInvoicesInput
    users?: usersCreateNestedOneWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    branch_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutInvoicesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUpdateManyWithoutInvoicesNestedInput
    branches?: branchesUpdateOneWithoutInvoicesNestedInput
    operators?: operatorsUpdateOneWithoutInvoicesNestedInput
    users?: usersUpdateOneWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    branch_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
  }

  export type invoicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type invoicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notification_preferencesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    push_enabled?: boolean | null
    email_enabled?: boolean | null
    sms_enabled?: boolean | null
    news_and_updates?: boolean | null
    order_updates?: boolean | null
    promotions?: boolean | null
    security_alerts?: boolean | null
    quiet_hours_start?: Date | string | null
    quiet_hours_end?: Date | string | null
    quiet_hours_enabled?: boolean | null
    frequency?: string | null
    users: usersCreateNestedOneWithoutNotification_preferencesInput
  }

  export type notification_preferencesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_id: string
    push_enabled?: boolean | null
    email_enabled?: boolean | null
    sms_enabled?: boolean | null
    news_and_updates?: boolean | null
    order_updates?: boolean | null
    promotions?: boolean | null
    security_alerts?: boolean | null
    quiet_hours_start?: Date | string | null
    quiet_hours_end?: Date | string | null
    quiet_hours_enabled?: boolean | null
    frequency?: string | null
  }

  export type notification_preferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    push_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sms_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    news_and_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    promotions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security_alerts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quiet_hours_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutNotification_preferencesNestedInput
  }

  export type notification_preferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    push_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sms_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    news_and_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    promotions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security_alerts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quiet_hours_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notification_preferencesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_id: string
    push_enabled?: boolean | null
    email_enabled?: boolean | null
    sms_enabled?: boolean | null
    news_and_updates?: boolean | null
    order_updates?: boolean | null
    promotions?: boolean | null
    security_alerts?: boolean | null
    quiet_hours_start?: Date | string | null
    quiet_hours_end?: Date | string | null
    quiet_hours_enabled?: boolean | null
    frequency?: string | null
  }

  export type notification_preferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    push_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sms_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    news_and_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    promotions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security_alerts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quiet_hours_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notification_preferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    push_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sms_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    news_and_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    promotions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security_alerts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quiet_hours_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notification_usersCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    type: string
    is_read?: boolean | null
    is_deleted?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: string | null
    action_url?: string | null
    icon?: string | null
    expiry_date?: Date | string | null
    requires_action?: boolean | null
    users: usersCreateNestedOneWithoutNotification_usersInput
  }

  export type notification_usersUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    type: string
    is_read?: boolean | null
    is_deleted?: boolean | null
    user_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: string | null
    action_url?: string | null
    icon?: string | null
    expiry_date?: Date | string | null
    requires_action?: boolean | null
  }

  export type notification_usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_url?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requires_action?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneRequiredWithoutNotification_usersNestedInput
  }

  export type notification_usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_url?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requires_action?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notification_usersCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    type: string
    is_read?: boolean | null
    is_deleted?: boolean | null
    user_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: string | null
    action_url?: string | null
    icon?: string | null
    expiry_date?: Date | string | null
    requires_action?: boolean | null
  }

  export type notification_usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_url?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requires_action?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notification_usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_url?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requires_action?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notifications_operatorCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: string | null
    priority?: string | null
    action_required?: boolean | null
    action_type?: string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: Date | string | null
    operators: operatorsCreateNestedOneWithoutNotifications_operatorInput
  }

  export type notifications_operatorUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    is_read?: boolean | null
    operator_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: string | null
    priority?: string | null
    action_required?: boolean | null
    action_type?: string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: Date | string | null
  }

  export type notifications_operatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    action_type?: NullableStringFieldUpdateOperationsInput | string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operators?: operatorsUpdateOneRequiredWithoutNotifications_operatorNestedInput
  }

  export type notifications_operatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operator_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    action_type?: NullableStringFieldUpdateOperationsInput | string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notifications_operatorCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    is_read?: boolean | null
    operator_id: string
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: string | null
    priority?: string | null
    action_required?: boolean | null
    action_type?: string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: Date | string | null
  }

  export type notifications_operatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    action_type?: NullableStringFieldUpdateOperationsInput | string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notifications_operatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operator_id?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    action_type?: NullableStringFieldUpdateOperationsInput | string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type operator_typesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    operators?: operatorsCreateNestedManyWithoutOperator_typesInput
  }

  export type operator_typesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    operators?: operatorsUncheckedCreateNestedManyWithoutOperator_typesInput
  }

  export type operator_typesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    operators?: operatorsUpdateManyWithoutOperator_typesNestedInput
  }

  export type operator_typesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    operators?: operatorsUncheckedUpdateManyWithoutOperator_typesNestedInput
  }

  export type operator_typesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type operator_typesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type operator_typesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type operatorsCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorCreateNestedManyWithoutOperatorsInput
    branches: branchesCreateNestedOneWithoutOperatorsInput
    operator_types: operator_typesCreateNestedOneWithoutOperatorsInput
    packages?: packagesCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesUncheckedCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorUncheckedCreateNestedManyWithoutOperatorsInput
    packages?: packagesUncheckedCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUpdateManyWithoutOperatorsNestedInput
    branches?: branchesUpdateOneRequiredWithoutOperatorsNestedInput
    operator_types?: operator_typesUpdateOneRequiredWithoutOperatorsNestedInput
    packages?: packagesUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUncheckedUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUncheckedUpdateManyWithoutOperatorsNestedInput
    packages?: packagesUncheckedUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
  }

  export type operatorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operatorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type packagesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    position?: string | null
    invoice_packages?: invoice_packagesCreateNestedManyWithoutPackagesInput
    branches?: branchesCreateNestedOneWithoutPackagesInput
    users?: usersCreateNestedOneWithoutPackagesInput
    operators?: operatorsCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_reference?: string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    branch_id?: string | null
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    operator_id?: string | null
    position?: string | null
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutPackagesInput
  }

  export type packagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_packages?: invoice_packagesUpdateManyWithoutPackagesNestedInput
    branches?: branchesUpdateOneWithoutPackagesNestedInput
    users?: usersUpdateOneWithoutPackagesNestedInput
    operators?: operatorsUpdateOneWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_reference?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutPackagesNestedInput
  }

  export type packagesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_reference?: string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    branch_id?: string | null
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    operator_id?: string | null
    position?: string | null
  }

  export type packagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type packagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_reference?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_typesCreateInput = {
    name: string
    description?: string | null
    is_active?: boolean | null
    processing_fee_percentage?: Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: Decimal | DecimalJsLike | number | string | null
    requires_approval?: boolean | null
    icon?: string | null
    payment_methods?: payment_methodsCreateNestedManyWithoutPayment_typesInput
  }

  export type payment_typesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    is_active?: boolean | null
    processing_fee_percentage?: Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: Decimal | DecimalJsLike | number | string | null
    requires_approval?: boolean | null
    icon?: string | null
    payment_methods?: payment_methodsUncheckedCreateNestedManyWithoutPayment_typesInput
  }

  export type payment_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processing_fee_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requires_approval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    payment_methods?: payment_methodsUpdateManyWithoutPayment_typesNestedInput
  }

  export type payment_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processing_fee_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requires_approval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    payment_methods?: payment_methodsUncheckedUpdateManyWithoutPayment_typesNestedInput
  }

  export type payment_typesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    is_active?: boolean | null
    processing_fee_percentage?: Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: Decimal | DecimalJsLike | number | string | null
    requires_approval?: boolean | null
    icon?: string | null
  }

  export type payment_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processing_fee_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requires_approval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processing_fee_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requires_approval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    payment_methods?: payment_methodsCreateNestedOneWithoutPaymentsInput
    invoices: invoicesCreateNestedOneWithoutPaymentsInput
    transactions?: transactionsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    transaction_id?: string | null
    payment_method_id?: string | null
  }

  export type paymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_methods?: payment_methodsUpdateOneWithoutPaymentsNestedInput
    invoices?: invoicesUpdateOneRequiredWithoutPaymentsNestedInput
    transactions?: transactionsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    transaction_id?: string | null
    payment_method_id?: string | null
  }

  export type paymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_addressesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    address_type: string
    address_line1: string
    address_line2: string
    city: string
    state: string
    country: string
    postal_code: string
    contact_name?: string | null
    contact_phone: string
    is_primary?: boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
    plans: plansCreateNestedOneWithoutPlan_addressesInput
  }

  export type plan_addressesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    plan_id: string
    address_type: string
    address_line1: string
    address_line2: string
    city: string
    state: string
    country: string
    postal_code: string
    contact_name?: string | null
    contact_phone: string
    is_primary?: boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_addressesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_type?: StringFieldUpdateOperationsInput | string
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
    plans?: plansUpdateOneRequiredWithoutPlan_addressesNestedInput
  }

  export type plan_addressesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan_id?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_addressesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    plan_id: string
    address_type: string
    address_line1: string
    address_line2: string
    city: string
    state: string
    country: string
    postal_code: string
    contact_name?: string | null
    contact_phone: string
    is_primary?: boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_addressesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_type?: StringFieldUpdateOperationsInput | string
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_addressesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan_id?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_featuresCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    feature_name: string
    feature_value?: string | null
    is_included?: boolean | null
    limit_quantity?: number | null
    description?: string | null
    plans: plansCreateNestedOneWithoutPlan_featuresInput
  }

  export type plan_featuresUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    plan_id: string
    feature_name: string
    feature_value?: string | null
    is_included?: boolean | null
    limit_quantity?: number | null
    description?: string | null
  }

  export type plan_featuresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feature_name?: StringFieldUpdateOperationsInput | string
    feature_value?: NullableStringFieldUpdateOperationsInput | string | null
    is_included?: NullableBoolFieldUpdateOperationsInput | boolean | null
    limit_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plans?: plansUpdateOneRequiredWithoutPlan_featuresNestedInput
  }

  export type plan_featuresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan_id?: StringFieldUpdateOperationsInput | string
    feature_name?: StringFieldUpdateOperationsInput | string
    feature_value?: NullableStringFieldUpdateOperationsInput | string | null
    is_included?: NullableBoolFieldUpdateOperationsInput | boolean | null
    limit_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_featuresCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    plan_id: string
    feature_name: string
    feature_value?: string | null
    is_included?: boolean | null
    limit_quantity?: number | null
    description?: string | null
  }

  export type plan_featuresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feature_name?: StringFieldUpdateOperationsInput | string
    feature_value?: NullableStringFieldUpdateOperationsInput | string | null
    is_included?: NullableBoolFieldUpdateOperationsInput | boolean | null
    limit_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_featuresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan_id?: StringFieldUpdateOperationsInput | string
    feature_name?: StringFieldUpdateOperationsInput | string
    feature_value?: NullableStringFieldUpdateOperationsInput | string | null
    is_included?: NullableBoolFieldUpdateOperationsInput | boolean | null
    limit_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plansCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsCreateNestedManyWithoutPlansInput
    plan_addresses?: plan_addressesCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresCreateNestedManyWithoutPlansInput
    branches?: branchesCreateNestedOneWithoutPlansInput
    users?: usersCreateNestedManyWithoutPlansInput
  }

  export type plansUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    branch_id?: string | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutPlansInput
    plan_addresses?: plan_addressesUncheckedCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresUncheckedCreateNestedManyWithoutPlansInput
    users?: usersUncheckedCreateNestedManyWithoutPlansInput
  }

  export type plansUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUpdateManyWithoutPlansNestedInput
    plan_addresses?: plan_addressesUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUpdateManyWithoutPlansNestedInput
    branches?: branchesUpdateOneWithoutPlansNestedInput
    users?: usersUpdateManyWithoutPlansNestedInput
  }

  export type plansUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutPlansNestedInput
    plan_addresses?: plan_addressesUncheckedUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUncheckedUpdateManyWithoutPlansNestedInput
    users?: usersUncheckedUpdateManyWithoutPlansNestedInput
  }

  export type plansCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    branch_id?: string | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plansUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plansUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
  }

  export type productsCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutProductsInput
    branches?: branchesCreateNestedOneWithoutProductsInput
    categories?: categoriesCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    category_id?: string | null
    branch_id?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutProductsNestedInput
    branches?: branchesUpdateOneWithoutProductsNestedInput
    categories?: categoriesUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    category_id?: string | null
    branch_id?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
  }

  export type productsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type productsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type type_usersCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code?: string | null
    description?: string | null
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    users?: usersCreateNestedManyWithoutType_usersInput
  }

  export type type_usersUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code?: string | null
    description?: string | null
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUncheckedCreateNestedManyWithoutType_usersInput
  }

  export type type_usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUpdateManyWithoutType_usersNestedInput
  }

  export type type_usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUncheckedUpdateManyWithoutType_usersNestedInput
  }

  export type type_usersCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code?: string | null
    description?: string | null
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type type_usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type type_usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type usersCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehiclesCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    make: string
    model: string
    year?: number | null
    license_plate: string
    status?: string
    color?: string | null
    vin?: string | null
    purchase_date?: Date | string | null
    last_maintenance_date?: Date | string | null
    mileage?: number | null
    fuel_type?: string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
    branches?: branchesCreateNestedOneWithoutVehiclesInput
  }

  export type vehiclesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    make: string
    model: string
    year?: number | null
    license_plate: string
    status?: string
    branch_id?: string | null
    color?: string | null
    vin?: string | null
    purchase_date?: Date | string | null
    last_maintenance_date?: Date | string | null
    mileage?: number | null
    fuel_type?: string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_maintenance_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
    branches?: branchesUpdateOneWithoutVehiclesNestedInput
  }

  export type vehiclesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_maintenance_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    make: string
    model: string
    year?: number | null
    license_plate: string
    status?: string
    branch_id?: string | null
    color?: string | null
    vin?: string | null
    purchase_date?: Date | string | null
    last_maintenance_date?: Date | string | null
    mileage?: number | null
    fuel_type?: string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_maintenance_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_maintenance_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type walletsCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean | null
    last_transaction_date?: Date | string | null
    users?: usersCreateNestedOneWithoutWalletsInput
  }

  export type walletsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean | null
    last_transaction_date?: Date | string | null
    user_id?: string | null
  }

  export type walletsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutWalletsNestedInput
  }

  export type walletsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletsCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean | null
    last_transaction_date?: Date | string | null
    user_id?: string | null
  }

  export type walletsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type walletsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saved_cardsCreateInput = {
    card_token: string
    card_type?: string | null
    cardholder_name?: string | null
    expiry_month: number
    expiry_year: number
    brand?: string | null
    last_four_digits?: string | null
    is_default?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    nick_name?: string | null
    users: usersCreateNestedOneWithoutSaved_cardsInput
  }

  export type saved_cardsUncheckedCreateInput = {
    id?: number
    user_id: string
    card_token: string
    card_type?: string | null
    cardholder_name?: string | null
    expiry_month: number
    expiry_year: number
    brand?: string | null
    last_four_digits?: string | null
    is_default?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    nick_name?: string | null
  }

  export type saved_cardsUpdateInput = {
    card_token?: StringFieldUpdateOperationsInput | string
    card_type?: NullableStringFieldUpdateOperationsInput | string | null
    cardholder_name?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last_four_digits?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nick_name?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutSaved_cardsNestedInput
  }

  export type saved_cardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    card_token?: StringFieldUpdateOperationsInput | string
    card_type?: NullableStringFieldUpdateOperationsInput | string | null
    cardholder_name?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last_four_digits?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nick_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saved_cardsCreateManyInput = {
    id?: number
    user_id: string
    card_token: string
    card_type?: string | null
    cardholder_name?: string | null
    expiry_month: number
    expiry_year: number
    brand?: string | null
    last_four_digits?: string | null
    is_default?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    nick_name?: string | null
  }

  export type saved_cardsUpdateManyMutationInput = {
    card_token?: StringFieldUpdateOperationsInput | string
    card_type?: NullableStringFieldUpdateOperationsInput | string | null
    cardholder_name?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last_four_digits?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nick_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saved_cardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    card_token?: StringFieldUpdateOperationsInput | string
    card_type?: NullableStringFieldUpdateOperationsInput | string | null
    cardholder_name?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last_four_digits?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nick_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_methodsCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_types?: payment_typesCreateNestedOneWithoutPayment_methodsInput
    payments?: paymentsCreateNestedManyWithoutPayment_methodsInput
    transactions?: transactionsCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_type_id?: number | null
    payments?: paymentsUncheckedCreateNestedManyWithoutPayment_methodsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_types?: payment_typesUpdateOneWithoutPayment_methodsNestedInput
    payments?: paymentsUpdateManyWithoutPayment_methodsNestedInput
    transactions?: transactionsUpdateManyWithoutPayment_methodsNestedInput
  }

  export type payment_methodsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    payments?: paymentsUncheckedUpdateManyWithoutPayment_methodsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutPayment_methodsNestedInput
  }

  export type payment_methodsCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_type_id?: number | null
  }

  export type payment_methodsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type payment_methodsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transaction_categoriesCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    is_active?: boolean | null
    transaction_categories?: transaction_categoriesCreateNestedOneWithoutOther_transaction_categoriesInput
    other_transaction_categories?: transaction_categoriesCreateNestedManyWithoutTransaction_categoriesInput
    transactions?: transactionsCreateNestedManyWithoutTransaction_categoriesInput
  }

  export type transaction_categoriesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    parent_id?: string | null
    is_active?: boolean | null
    other_transaction_categories?: transaction_categoriesUncheckedCreateNestedManyWithoutTransaction_categoriesInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutTransaction_categoriesInput
  }

  export type transaction_categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    transaction_categories?: transaction_categoriesUpdateOneWithoutOther_transaction_categoriesNestedInput
    other_transaction_categories?: transaction_categoriesUpdateManyWithoutTransaction_categoriesNestedInput
    transactions?: transactionsUpdateManyWithoutTransaction_categoriesNestedInput
  }

  export type transaction_categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    other_transaction_categories?: transaction_categoriesUncheckedUpdateManyWithoutTransaction_categoriesNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutTransaction_categoriesNestedInput
  }

  export type transaction_categoriesCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    parent_id?: string | null
    is_active?: boolean | null
  }

  export type transaction_categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type transaction_categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type transactionsCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutTransactionsInput
    transaction_categories?: transaction_categoriesCreateNestedOneWithoutTransactionsInput
    payment_methods?: payment_methodsCreateNestedOneWithoutTransactionsInput
    transaction_types?: transaction_typesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    payment_method_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: string | null
    transaction_type_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutTransactionsNestedInput
    transaction_categories?: transaction_categoriesUpdateOneWithoutTransactionsNestedInput
    payment_methods?: payment_methodsUpdateOneWithoutTransactionsNestedInput
    transaction_types?: transaction_typesUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    payment_method_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: string | null
    transaction_type_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type transactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type transactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type transaction_typesCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    code: string
    name: string
    description?: string | null
    affects_balance: string
    is_active?: boolean | null
    transactions?: transactionsCreateNestedManyWithoutTransaction_typesInput
  }

  export type transaction_typesUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    code: string
    name: string
    description?: string | null
    affects_balance: string
    is_active?: boolean | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutTransaction_typesInput
  }

  export type transaction_typesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affects_balance?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    transactions?: transactionsUpdateManyWithoutTransaction_typesNestedInput
  }

  export type transaction_typesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affects_balance?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    transactions?: transactionsUncheckedUpdateManyWithoutTransaction_typesNestedInput
  }

  export type transaction_typesCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    code: string
    name: string
    description?: string | null
    affects_balance: string
    is_active?: boolean | null
  }

  export type transaction_typesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affects_balance?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type transaction_typesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affects_balance?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type referral_sourcesCreateInput = {
    id?: string
    source_name: string
    users?: usersCreateNestedManyWithoutReferral_sourcesInput
  }

  export type referral_sourcesUncheckedCreateInput = {
    id?: string
    source_name: string
    users?: usersUncheckedCreateNestedManyWithoutReferral_sourcesInput
  }

  export type referral_sourcesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source_name?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateManyWithoutReferral_sourcesNestedInput
  }

  export type referral_sourcesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source_name?: StringFieldUpdateOperationsInput | string
    users?: usersUncheckedUpdateManyWithoutReferral_sourcesNestedInput
  }

  export type referral_sourcesCreateManyInput = {
    id?: string
    source_name: string
  }

  export type referral_sourcesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source_name?: StringFieldUpdateOperationsInput | string
  }

  export type referral_sourcesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source_name?: StringFieldUpdateOperationsInput | string
  }

  export type cash_closuresCreateInput = {
    id?: string
    created_at?: Date | string
    cash_closures: Date | string
    total_cash: number
    total_yappy: number
    total_card: number
    total_bank_transfer: number
    total_digital_wallet: number
    total_internal_wallet: number
    total_credits: number
    total_debits: number
    final_balance: number
    status: string
  }

  export type cash_closuresUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    cash_closures: Date | string
    total_cash: number
    total_yappy: number
    total_card: number
    total_bank_transfer: number
    total_digital_wallet: number
    total_internal_wallet: number
    total_credits: number
    total_debits: number
    final_balance: number
    status: string
  }

  export type cash_closuresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_closures?: DateTimeFieldUpdateOperationsInput | Date | string
    total_cash?: FloatFieldUpdateOperationsInput | number
    total_yappy?: FloatFieldUpdateOperationsInput | number
    total_card?: FloatFieldUpdateOperationsInput | number
    total_bank_transfer?: FloatFieldUpdateOperationsInput | number
    total_digital_wallet?: FloatFieldUpdateOperationsInput | number
    total_internal_wallet?: FloatFieldUpdateOperationsInput | number
    total_credits?: FloatFieldUpdateOperationsInput | number
    total_debits?: FloatFieldUpdateOperationsInput | number
    final_balance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type cash_closuresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_closures?: DateTimeFieldUpdateOperationsInput | Date | string
    total_cash?: FloatFieldUpdateOperationsInput | number
    total_yappy?: FloatFieldUpdateOperationsInput | number
    total_card?: FloatFieldUpdateOperationsInput | number
    total_bank_transfer?: FloatFieldUpdateOperationsInput | number
    total_digital_wallet?: FloatFieldUpdateOperationsInput | number
    total_internal_wallet?: FloatFieldUpdateOperationsInput | number
    total_credits?: FloatFieldUpdateOperationsInput | number
    total_debits?: FloatFieldUpdateOperationsInput | number
    final_balance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type cash_closuresCreateManyInput = {
    id?: string
    created_at?: Date | string
    cash_closures: Date | string
    total_cash: number
    total_yappy: number
    total_card: number
    total_bank_transfer: number
    total_digital_wallet: number
    total_internal_wallet: number
    total_credits: number
    total_debits: number
    final_balance: number
    status: string
  }

  export type cash_closuresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_closures?: DateTimeFieldUpdateOperationsInput | Date | string
    total_cash?: FloatFieldUpdateOperationsInput | number
    total_yappy?: FloatFieldUpdateOperationsInput | number
    total_card?: FloatFieldUpdateOperationsInput | number
    total_bank_transfer?: FloatFieldUpdateOperationsInput | number
    total_digital_wallet?: FloatFieldUpdateOperationsInput | number
    total_internal_wallet?: FloatFieldUpdateOperationsInput | number
    total_credits?: FloatFieldUpdateOperationsInput | number
    total_debits?: FloatFieldUpdateOperationsInput | number
    final_balance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type cash_closuresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_closures?: DateTimeFieldUpdateOperationsInput | Date | string
    total_cash?: FloatFieldUpdateOperationsInput | number
    total_yappy?: FloatFieldUpdateOperationsInput | number
    total_card?: FloatFieldUpdateOperationsInput | number
    total_bank_transfer?: FloatFieldUpdateOperationsInput | number
    total_digital_wallet?: FloatFieldUpdateOperationsInput | number
    total_internal_wallet?: FloatFieldUpdateOperationsInput | number
    total_credits?: FloatFieldUpdateOperationsInput | number
    total_debits?: FloatFieldUpdateOperationsInput | number
    final_balance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Enumactivity_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.activity_type_enum | Enumactivity_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.activity_type_enum[] | ListEnumactivity_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.activity_type_enum[] | ListEnumactivity_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumactivity_type_enumFilter<$PrismaModel> | $Enums.activity_type_enum
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Enumactivity_status_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.activity_status_enum | Enumactivity_status_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.activity_status_enum[] | ListEnumactivity_status_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.activity_status_enum[] | ListEnumactivity_status_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumactivity_status_enumNullableFilter<$PrismaModel> | $Enums.activity_status_enum | null
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BranchesNullableScalarRelationFilter = {
    is?: branchesWhereInput | null
    isNot?: branchesWhereInput | null
  }

  export type OperatorsNullableScalarRelationFilter = {
    is?: operatorsWhereInput | null
    isNot?: operatorsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type activitiesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    action?: SortOrder
    type?: SortOrder
    description?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    operator_id?: SortOrder
    branch_id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    old_values?: SortOrder
    new_values?: SortOrder
    metadata?: SortOrder
  }

  export type activitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    action?: SortOrder
    type?: SortOrder
    description?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    operator_id?: SortOrder
    branch_id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
  }

  export type activitiesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    action?: SortOrder
    type?: SortOrder
    description?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    operator_id?: SortOrder
    branch_id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Enumactivity_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.activity_type_enum | Enumactivity_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.activity_type_enum[] | ListEnumactivity_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.activity_type_enum[] | ListEnumactivity_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumactivity_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.activity_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumactivity_type_enumFilter<$PrismaModel>
    _max?: NestedEnumactivity_type_enumFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enumactivity_status_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.activity_status_enum | Enumactivity_status_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.activity_status_enum[] | ListEnumactivity_status_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.activity_status_enum[] | ListEnumactivity_status_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumactivity_status_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.activity_status_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumactivity_status_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumactivity_status_enumNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ActivitiesListRelationFilter = {
    every?: activitiesWhereInput
    some?: activitiesWhereInput
    none?: activitiesWhereInput
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type Gift_cardsListRelationFilter = {
    every?: gift_cardsWhereInput
    some?: gift_cardsWhereInput
    none?: gift_cardsWhereInput
  }

  export type InvoicesListRelationFilter = {
    every?: invoicesWhereInput
    some?: invoicesWhereInput
    none?: invoicesWhereInput
  }

  export type OperatorsListRelationFilter = {
    every?: operatorsWhereInput
    some?: operatorsWhereInput
    none?: operatorsWhereInput
  }

  export type PackagesListRelationFilter = {
    every?: packagesWhereInput
    some?: packagesWhereInput
    none?: packagesWhereInput
  }

  export type PlansListRelationFilter = {
    every?: plansWhereInput
    some?: plansWhereInput
    none?: plansWhereInput
  }

  export type ProductsListRelationFilter = {
    every?: productsWhereInput
    some?: productsWhereInput
    none?: productsWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type VehiclesListRelationFilter = {
    every?: vehiclesWhereInput
    some?: vehiclesWhereInput
    none?: vehiclesWhereInput
  }

  export type activitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gift_cardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type operatorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type packagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehiclesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type branchesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    is_active?: SortOrder
    prefix?: SortOrder
    company_id?: SortOrder
    manager_name?: SortOrder
    opening_hours?: SortOrder
    timezone?: SortOrder
  }

  export type branchesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    is_active?: SortOrder
    prefix?: SortOrder
    company_id?: SortOrder
    manager_name?: SortOrder
    timezone?: SortOrder
  }

  export type branchesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    is_active?: SortOrder
    prefix?: SortOrder
    company_id?: SortOrder
    manager_name?: SortOrder
    timezone?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_active?: SortOrder
    order_position?: SortOrder
  }

  export type categoriesAvgOrderByAggregateInput = {
    order_position?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_active?: SortOrder
    order_position?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_active?: SortOrder
    order_position?: SortOrder
  }

  export type categoriesSumOrderByAggregateInput = {
    order_position?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BranchesListRelationFilter = {
    every?: branchesWhereInput
    some?: branchesWhereInput
    none?: branchesWhereInput
  }

  export type branchesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    ruc?: SortOrder
    logo_url?: SortOrder
    website?: SortOrder
    tax_id?: SortOrder
    business_type?: SortOrder
    industry?: SortOrder
    founded_date?: SortOrder
    is_active?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    ruc?: SortOrder
    logo_url?: SortOrder
    website?: SortOrder
    tax_id?: SortOrder
    business_type?: SortOrder
    industry?: SortOrder
    founded_date?: SortOrder
    is_active?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    ruc?: SortOrder
    logo_url?: SortOrder
    website?: SortOrder
    tax_id?: SortOrder
    business_type?: SortOrder
    industry?: SortOrder
    founded_date?: SortOrder
    is_active?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Email_templatesNullableScalarRelationFilter = {
    is?: email_templatesWhereInput | null
    isNot?: email_templatesWhereInput | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type email_campaignsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    recipients?: SortOrder
    send_to_all?: SortOrder
    tracking?: SortOrder
    tracking_id?: SortOrder
    stats?: SortOrder
    user_id?: SortOrder
    template_id?: SortOrder
    scheduled_for?: SortOrder
    sender_name?: SortOrder
    sender_email?: SortOrder
    reply_to?: SortOrder
    segment_criteria?: SortOrder
    test_recipients?: SortOrder
    is_recurring?: SortOrder
    recurrence_pattern?: SortOrder
  }

  export type email_campaignsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    send_to_all?: SortOrder
    tracking?: SortOrder
    tracking_id?: SortOrder
    user_id?: SortOrder
    template_id?: SortOrder
    scheduled_for?: SortOrder
    sender_name?: SortOrder
    sender_email?: SortOrder
    reply_to?: SortOrder
    is_recurring?: SortOrder
  }

  export type email_campaignsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    send_to_all?: SortOrder
    tracking?: SortOrder
    tracking_id?: SortOrder
    user_id?: SortOrder
    template_id?: SortOrder
    scheduled_for?: SortOrder
    sender_name?: SortOrder
    sender_email?: SortOrder
    reply_to?: SortOrder
    is_recurring?: SortOrder
  }

  export type Email_campaignsListRelationFilter = {
    every?: email_campaignsWhereInput
    some?: email_campaignsWhereInput
    none?: email_campaignsWhereInput
  }

  export type email_campaignsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type email_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    html_body?: SortOrder
    elements?: SortOrder
    editor_settings?: SortOrder
    thumbnail?: SortOrder
    operator_id?: SortOrder
    category?: SortOrder
    variables?: SortOrder
    is_default?: SortOrder
    version?: SortOrder
  }

  export type email_templatesAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type email_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    html_body?: SortOrder
    thumbnail?: SortOrder
    operator_id?: SortOrder
    category?: SortOrder
    is_default?: SortOrder
    version?: SortOrder
  }

  export type email_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    html_body?: SortOrder
    thumbnail?: SortOrder
    operator_id?: SortOrder
    category?: SortOrder
    is_default?: SortOrder
    version?: SortOrder
  }

  export type email_templatesSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Enumpayment_method_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_method_enumNullableFilter<$PrismaModel> | $Enums.payment_method_enum | null
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type gift_cardsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    issue_date?: SortOrder
    expiry_date?: SortOrder
    recipient_name?: SortOrder
    recipient_email?: SortOrder
    sender_id?: SortOrder
    redeemed_at?: SortOrder
    message?: SortOrder
    payment_method?: SortOrder
    send_date?: SortOrder
    design_template?: SortOrder
    branch_id?: SortOrder
    is_reloadable?: SortOrder
    access_pin?: SortOrder
    usage_history?: SortOrder
  }

  export type gift_cardsAvgOrderByAggregateInput = {
    amount?: SortOrder
    balance?: SortOrder
  }

  export type gift_cardsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    issue_date?: SortOrder
    expiry_date?: SortOrder
    recipient_name?: SortOrder
    recipient_email?: SortOrder
    sender_id?: SortOrder
    redeemed_at?: SortOrder
    message?: SortOrder
    payment_method?: SortOrder
    send_date?: SortOrder
    design_template?: SortOrder
    branch_id?: SortOrder
    is_reloadable?: SortOrder
    access_pin?: SortOrder
  }

  export type gift_cardsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    issue_date?: SortOrder
    expiry_date?: SortOrder
    recipient_name?: SortOrder
    recipient_email?: SortOrder
    sender_id?: SortOrder
    redeemed_at?: SortOrder
    message?: SortOrder
    payment_method?: SortOrder
    send_date?: SortOrder
    design_template?: SortOrder
    branch_id?: SortOrder
    is_reloadable?: SortOrder
    access_pin?: SortOrder
  }

  export type gift_cardsSumOrderByAggregateInput = {
    amount?: SortOrder
    balance?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type Enumpayment_method_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_method_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_method_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_method_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_method_enumNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InvoicesScalarRelationFilter = {
    is?: invoicesWhereInput
    isNot?: invoicesWhereInput
  }

  export type PlansNullableScalarRelationFilter = {
    is?: plansWhereInput | null
    isNot?: plansWhereInput | null
  }

  export type ProductsNullableScalarRelationFilter = {
    is?: productsWhereInput | null
    isNot?: productsWhereInput | null
  }

  export type invoice_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    product_id?: SortOrder
    plan_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    discount_rate?: SortOrder
    tax_rate?: SortOrder
    item_order?: SortOrder
    unit_of_measure?: SortOrder
    is_taxable?: SortOrder
    serial_numbers?: SortOrder
  }

  export type invoice_itemsAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    discount_rate?: SortOrder
    tax_rate?: SortOrder
    item_order?: SortOrder
  }

  export type invoice_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    product_id?: SortOrder
    plan_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    discount_rate?: SortOrder
    tax_rate?: SortOrder
    item_order?: SortOrder
    unit_of_measure?: SortOrder
    is_taxable?: SortOrder
  }

  export type invoice_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    product_id?: SortOrder
    plan_id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    discount_rate?: SortOrder
    tax_rate?: SortOrder
    item_order?: SortOrder
    unit_of_measure?: SortOrder
    is_taxable?: SortOrder
  }

  export type invoice_itemsSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    discount_rate?: SortOrder
    tax_rate?: SortOrder
    item_order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PackagesScalarRelationFilter = {
    is?: packagesWhereInput
    isNot?: packagesWhereInput
  }

  export type invoice_packagesInvoice_idPackage_idCompoundUniqueInput = {
    invoice_id: string
    package_id: string
  }

  export type invoice_packagesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    package_id?: SortOrder
  }

  export type invoice_packagesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    package_id?: SortOrder
  }

  export type invoice_packagesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    package_id?: SortOrder
  }

  export type Enuminvoice_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_status_enum | Enuminvoice_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnuminvoice_status_enumFilter<$PrismaModel> | $Enums.invoice_status_enum
  }

  export type Enuminvoice_type_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_type_enum | Enuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.invoice_type_enum[] | ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.invoice_type_enum[] | ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnuminvoice_type_enumNullableFilter<$PrismaModel> | $Enums.invoice_type_enum | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Invoice_itemsListRelationFilter = {
    every?: invoice_itemsWhereInput
    some?: invoice_itemsWhereInput
    none?: invoice_itemsWhereInput
  }

  export type Invoice_packagesListRelationFilter = {
    every?: invoice_packagesWhereInput
    some?: invoice_packagesWhereInput
    none?: invoice_packagesWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type invoice_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoice_packagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoicesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_number?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    is_paid?: SortOrder
    total_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
    operator_id?: SortOrder
    billing_address?: SortOrder
    shipping_address?: SortOrder
    notes?: SortOrder
    payment_terms?: SortOrder
    currency?: SortOrder
    conversion_rate?: SortOrder
    tracking_number?: SortOrder
    shipping_method?: SortOrder
    invoice_type?: SortOrder
    commission_amount?: SortOrder
    marketplace_fee_rate?: SortOrder
    platform?: SortOrder
    external_reference_id?: SortOrder
    tax_details?: SortOrder
    price_plan?: SortOrder
    shipping_insurance?: SortOrder
    paid_amount?: SortOrder
    remaining_amount?: SortOrder
    last_payment_date?: SortOrder
  }

  export type invoicesAvgOrderByAggregateInput = {
    total_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    conversion_rate?: SortOrder
    commission_amount?: SortOrder
    marketplace_fee_rate?: SortOrder
    price_plan?: SortOrder
    paid_amount?: SortOrder
    remaining_amount?: SortOrder
  }

  export type invoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_number?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    is_paid?: SortOrder
    total_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
    operator_id?: SortOrder
    notes?: SortOrder
    payment_terms?: SortOrder
    currency?: SortOrder
    conversion_rate?: SortOrder
    tracking_number?: SortOrder
    shipping_method?: SortOrder
    invoice_type?: SortOrder
    commission_amount?: SortOrder
    marketplace_fee_rate?: SortOrder
    platform?: SortOrder
    external_reference_id?: SortOrder
    price_plan?: SortOrder
    shipping_insurance?: SortOrder
    paid_amount?: SortOrder
    remaining_amount?: SortOrder
    last_payment_date?: SortOrder
  }

  export type invoicesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_number?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    is_paid?: SortOrder
    total_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
    operator_id?: SortOrder
    notes?: SortOrder
    payment_terms?: SortOrder
    currency?: SortOrder
    conversion_rate?: SortOrder
    tracking_number?: SortOrder
    shipping_method?: SortOrder
    invoice_type?: SortOrder
    commission_amount?: SortOrder
    marketplace_fee_rate?: SortOrder
    platform?: SortOrder
    external_reference_id?: SortOrder
    price_plan?: SortOrder
    shipping_insurance?: SortOrder
    paid_amount?: SortOrder
    remaining_amount?: SortOrder
    last_payment_date?: SortOrder
  }

  export type invoicesSumOrderByAggregateInput = {
    total_amount?: SortOrder
    tax_amount?: SortOrder
    discount_amount?: SortOrder
    conversion_rate?: SortOrder
    commission_amount?: SortOrder
    marketplace_fee_rate?: SortOrder
    price_plan?: SortOrder
    paid_amount?: SortOrder
    remaining_amount?: SortOrder
  }

  export type Enuminvoice_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_status_enum | Enuminvoice_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnuminvoice_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.invoice_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminvoice_status_enumFilter<$PrismaModel>
    _max?: NestedEnuminvoice_status_enumFilter<$PrismaModel>
  }

  export type Enuminvoice_type_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_type_enum | Enuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.invoice_type_enum[] | ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.invoice_type_enum[] | ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnuminvoice_type_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.invoice_type_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminvoice_type_enumNullableFilter<$PrismaModel>
    _max?: NestedEnuminvoice_type_enumNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type notification_preferencesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    push_enabled?: SortOrder
    email_enabled?: SortOrder
    sms_enabled?: SortOrder
    news_and_updates?: SortOrder
    order_updates?: SortOrder
    promotions?: SortOrder
    security_alerts?: SortOrder
    quiet_hours_start?: SortOrder
    quiet_hours_end?: SortOrder
    quiet_hours_enabled?: SortOrder
    frequency?: SortOrder
  }

  export type notification_preferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    push_enabled?: SortOrder
    email_enabled?: SortOrder
    sms_enabled?: SortOrder
    news_and_updates?: SortOrder
    order_updates?: SortOrder
    promotions?: SortOrder
    security_alerts?: SortOrder
    quiet_hours_start?: SortOrder
    quiet_hours_end?: SortOrder
    quiet_hours_enabled?: SortOrder
    frequency?: SortOrder
  }

  export type notification_preferencesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    push_enabled?: SortOrder
    email_enabled?: SortOrder
    sms_enabled?: SortOrder
    news_and_updates?: SortOrder
    order_updates?: SortOrder
    promotions?: SortOrder
    security_alerts?: SortOrder
    quiet_hours_start?: SortOrder
    quiet_hours_end?: SortOrder
    quiet_hours_enabled?: SortOrder
    frequency?: SortOrder
  }

  export type notification_usersCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    is_deleted?: SortOrder
    user_id?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    action_url?: SortOrder
    icon?: SortOrder
    expiry_date?: SortOrder
    requires_action?: SortOrder
  }

  export type notification_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    is_deleted?: SortOrder
    user_id?: SortOrder
    priority?: SortOrder
    action_url?: SortOrder
    icon?: SortOrder
    expiry_date?: SortOrder
    requires_action?: SortOrder
  }

  export type notification_usersMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    is_deleted?: SortOrder
    user_id?: SortOrder
    priority?: SortOrder
    action_url?: SortOrder
    icon?: SortOrder
    expiry_date?: SortOrder
    requires_action?: SortOrder
  }

  export type OperatorsScalarRelationFilter = {
    is?: operatorsWhereInput
    isNot?: operatorsWhereInput
  }

  export type notifications_operatorCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    operator_id?: SortOrder
    data?: SortOrder
    notification_type?: SortOrder
    priority?: SortOrder
    action_required?: SortOrder
    action_type?: SortOrder
    action_data?: SortOrder
    expiry_date?: SortOrder
  }

  export type notifications_operatorMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    operator_id?: SortOrder
    notification_type?: SortOrder
    priority?: SortOrder
    action_required?: SortOrder
    action_type?: SortOrder
    expiry_date?: SortOrder
  }

  export type notifications_operatorMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    operator_id?: SortOrder
    notification_type?: SortOrder
    priority?: SortOrder
    action_required?: SortOrder
    action_type?: SortOrder
    expiry_date?: SortOrder
  }

  export type operator_typesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
  }

  export type operator_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type operator_typesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type Enumoperator_role_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.operator_role_enum | Enumoperator_role_enumFieldRefInput<$PrismaModel>
    in?: $Enums.operator_role_enum[] | ListEnumoperator_role_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.operator_role_enum[] | ListEnumoperator_role_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumoperator_role_enumFilter<$PrismaModel> | $Enums.operator_role_enum
  }

  export type Enumoperator_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.operator_status_enum | Enumoperator_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.operator_status_enum[] | ListEnumoperator_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.operator_status_enum[] | ListEnumoperator_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumoperator_status_enumFilter<$PrismaModel> | $Enums.operator_status_enum
  }

  export type Email_templatesListRelationFilter = {
    every?: email_templatesWhereInput
    some?: email_templatesWhereInput
    none?: email_templatesWhereInput
  }

  export type Notifications_operatorListRelationFilter = {
    every?: notifications_operatorWhereInput
    some?: notifications_operatorWhereInput
    none?: notifications_operatorWhereInput
  }

  export type BranchesScalarRelationFilter = {
    is?: branchesWhereInput
    isNot?: branchesWhereInput
  }

  export type Operator_typesScalarRelationFilter = {
    is?: operator_typesWhereInput
    isNot?: operator_typesWhereInput
  }

  export type email_templatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notifications_operatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type operatorsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    role?: SortOrder
    status?: SortOrder
    last_login_at?: SortOrder
    branch_id?: SortOrder
    type_operator_id?: SortOrder
    position?: SortOrder
    hire_date?: SortOrder
    birth_date?: SortOrder
    emergency_contact?: SortOrder
    skills?: SortOrder
    personal_id?: SortOrder
    address?: SortOrder
  }

  export type operatorsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    role?: SortOrder
    status?: SortOrder
    last_login_at?: SortOrder
    branch_id?: SortOrder
    type_operator_id?: SortOrder
    position?: SortOrder
    hire_date?: SortOrder
    birth_date?: SortOrder
    personal_id?: SortOrder
    address?: SortOrder
  }

  export type operatorsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    role?: SortOrder
    status?: SortOrder
    last_login_at?: SortOrder
    branch_id?: SortOrder
    type_operator_id?: SortOrder
    position?: SortOrder
    hire_date?: SortOrder
    birth_date?: SortOrder
    personal_id?: SortOrder
    address?: SortOrder
  }

  export type Enumoperator_role_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.operator_role_enum | Enumoperator_role_enumFieldRefInput<$PrismaModel>
    in?: $Enums.operator_role_enum[] | ListEnumoperator_role_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.operator_role_enum[] | ListEnumoperator_role_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumoperator_role_enumWithAggregatesFilter<$PrismaModel> | $Enums.operator_role_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumoperator_role_enumFilter<$PrismaModel>
    _max?: NestedEnumoperator_role_enumFilter<$PrismaModel>
  }

  export type Enumoperator_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.operator_status_enum | Enumoperator_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.operator_status_enum[] | ListEnumoperator_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.operator_status_enum[] | ListEnumoperator_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumoperator_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.operator_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumoperator_status_enumFilter<$PrismaModel>
    _max?: NestedEnumoperator_status_enumFilter<$PrismaModel>
  }

  export type Enumpackage_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.package_status_enum | Enumpackage_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.package_status_enum[] | ListEnumpackage_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.package_status_enum[] | ListEnumpackage_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpackage_status_enumFilter<$PrismaModel> | $Enums.package_status_enum
  }

  export type packagesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_reference?: SortOrder
    package_status?: SortOrder
    tracking_number?: SortOrder
    height?: SortOrder
    width?: SortOrder
    length?: SortOrder
    weight?: SortOrder
    volumetric_weight?: SortOrder
    insurance?: SortOrder
    shipping_stages?: SortOrder
    branch_id?: SortOrder
    notes?: SortOrder
    declared_value?: SortOrder
    customs_information?: SortOrder
    is_fragile?: SortOrder
    estimated_delivery_date?: SortOrder
    operator_id?: SortOrder
    position?: SortOrder
  }

  export type packagesAvgOrderByAggregateInput = {
    height?: SortOrder
    width?: SortOrder
    length?: SortOrder
    weight?: SortOrder
    volumetric_weight?: SortOrder
    declared_value?: SortOrder
  }

  export type packagesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_reference?: SortOrder
    package_status?: SortOrder
    tracking_number?: SortOrder
    height?: SortOrder
    width?: SortOrder
    length?: SortOrder
    weight?: SortOrder
    volumetric_weight?: SortOrder
    insurance?: SortOrder
    branch_id?: SortOrder
    notes?: SortOrder
    declared_value?: SortOrder
    is_fragile?: SortOrder
    estimated_delivery_date?: SortOrder
    operator_id?: SortOrder
    position?: SortOrder
  }

  export type packagesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_reference?: SortOrder
    package_status?: SortOrder
    tracking_number?: SortOrder
    height?: SortOrder
    width?: SortOrder
    length?: SortOrder
    weight?: SortOrder
    volumetric_weight?: SortOrder
    insurance?: SortOrder
    branch_id?: SortOrder
    notes?: SortOrder
    declared_value?: SortOrder
    is_fragile?: SortOrder
    estimated_delivery_date?: SortOrder
    operator_id?: SortOrder
    position?: SortOrder
  }

  export type packagesSumOrderByAggregateInput = {
    height?: SortOrder
    width?: SortOrder
    length?: SortOrder
    weight?: SortOrder
    volumetric_weight?: SortOrder
    declared_value?: SortOrder
  }

  export type Enumpackage_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.package_status_enum | Enumpackage_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.package_status_enum[] | ListEnumpackage_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.package_status_enum[] | ListEnumpackage_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpackage_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.package_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpackage_status_enumFilter<$PrismaModel>
    _max?: NestedEnumpackage_status_enumFilter<$PrismaModel>
  }

  export type Payment_methodsListRelationFilter = {
    every?: payment_methodsWhereInput
    some?: payment_methodsWhereInput
    none?: payment_methodsWhereInput
  }

  export type payment_methodsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    processing_fee_percentage?: SortOrder
    processing_fee_fixed?: SortOrder
    requires_approval?: SortOrder
    icon?: SortOrder
  }

  export type payment_typesAvgOrderByAggregateInput = {
    id?: SortOrder
    processing_fee_percentage?: SortOrder
    processing_fee_fixed?: SortOrder
  }

  export type payment_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    processing_fee_percentage?: SortOrder
    processing_fee_fixed?: SortOrder
    requires_approval?: SortOrder
    icon?: SortOrder
  }

  export type payment_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    processing_fee_percentage?: SortOrder
    processing_fee_fixed?: SortOrder
    requires_approval?: SortOrder
    icon?: SortOrder
  }

  export type payment_typesSumOrderByAggregateInput = {
    id?: SortOrder
    processing_fee_percentage?: SortOrder
    processing_fee_fixed?: SortOrder
  }

  export type Enumpayment_method_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_method_enumFilter<$PrismaModel> | $Enums.payment_method_enum
  }

  export type Enumpayment_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status_enum | Enumpayment_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_status_enumFilter<$PrismaModel> | $Enums.payment_status_enum
  }

  export type Payment_methodsNullableScalarRelationFilter = {
    is?: payment_methodsWhereInput | null
    isNot?: payment_methodsWhereInput | null
  }

  export type TransactionsNullableScalarRelationFilter = {
    is?: transactionsWhereInput | null
    isNot?: transactionsWhereInput | null
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    payment_provider?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    fees?: SortOrder
    payer_details?: SortOrder
    receipt_url?: SortOrder
    notes?: SortOrder
    transaction_id?: SortOrder
    payment_method_id?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    amount?: SortOrder
    exchange_rate?: SortOrder
    fees?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    payment_provider?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    fees?: SortOrder
    receipt_url?: SortOrder
    notes?: SortOrder
    transaction_id?: SortOrder
    payment_method_id?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    payment_provider?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    fees?: SortOrder
    receipt_url?: SortOrder
    notes?: SortOrder
    transaction_id?: SortOrder
    payment_method_id?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    amount?: SortOrder
    exchange_rate?: SortOrder
    fees?: SortOrder
  }

  export type Enumpayment_method_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_method_enumWithAggregatesFilter<$PrismaModel> | $Enums.payment_method_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayment_method_enumFilter<$PrismaModel>
    _max?: NestedEnumpayment_method_enumFilter<$PrismaModel>
  }

  export type Enumpayment_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status_enum | Enumpayment_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.payment_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayment_status_enumFilter<$PrismaModel>
    _max?: NestedEnumpayment_status_enumFilter<$PrismaModel>
  }

  export type PlansScalarRelationFilter = {
    is?: plansWhereInput
    isNot?: plansWhereInput
  }

  export type plan_addressesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan_id?: SortOrder
    address_type?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    is_primary?: SortOrder
    additional_info?: SortOrder
  }

  export type plan_addressesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan_id?: SortOrder
    address_type?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    is_primary?: SortOrder
  }

  export type plan_addressesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan_id?: SortOrder
    address_type?: SortOrder
    address_line1?: SortOrder
    address_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    is_primary?: SortOrder
  }

  export type plan_featuresCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan_id?: SortOrder
    feature_name?: SortOrder
    feature_value?: SortOrder
    is_included?: SortOrder
    limit_quantity?: SortOrder
    description?: SortOrder
  }

  export type plan_featuresAvgOrderByAggregateInput = {
    limit_quantity?: SortOrder
  }

  export type plan_featuresMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan_id?: SortOrder
    feature_name?: SortOrder
    feature_value?: SortOrder
    is_included?: SortOrder
    limit_quantity?: SortOrder
    description?: SortOrder
  }

  export type plan_featuresMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan_id?: SortOrder
    feature_name?: SortOrder
    feature_value?: SortOrder
    is_included?: SortOrder
    limit_quantity?: SortOrder
    description?: SortOrder
  }

  export type plan_featuresSumOrderByAggregateInput = {
    limit_quantity?: SortOrder
  }

  export type Plan_addressesListRelationFilter = {
    every?: plan_addressesWhereInput
    some?: plan_addressesWhereInput
    none?: plan_addressesWhereInput
  }

  export type Plan_featuresListRelationFilter = {
    every?: plan_featuresWhereInput
    some?: plan_featuresWhereInput
    none?: plan_featuresWhereInput
  }

  export type plan_addressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plan_featuresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plansCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    color?: SortOrder
    is_active?: SortOrder
    branch_id?: SortOrder
    trial_period_days?: SortOrder
    setup_fee?: SortOrder
    max_users?: SortOrder
    discounts?: SortOrder
  }

  export type plansAvgOrderByAggregateInput = {
    price?: SortOrder
    trial_period_days?: SortOrder
    setup_fee?: SortOrder
    max_users?: SortOrder
  }

  export type plansMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    color?: SortOrder
    is_active?: SortOrder
    branch_id?: SortOrder
    trial_period_days?: SortOrder
    setup_fee?: SortOrder
    max_users?: SortOrder
  }

  export type plansMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    color?: SortOrder
    is_active?: SortOrder
    branch_id?: SortOrder
    trial_period_days?: SortOrder
    setup_fee?: SortOrder
    max_users?: SortOrder
  }

  export type plansSumOrderByAggregateInput = {
    price?: SortOrder
    trial_period_days?: SortOrder
    setup_fee?: SortOrder
    max_users?: SortOrder
  }

  export type Enumproduct_status_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.product_status_enum | Enumproduct_status_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.product_status_enum[] | ListEnumproduct_status_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.product_status_enum[] | ListEnumproduct_status_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumproduct_status_enumNullableFilter<$PrismaModel> | $Enums.product_status_enum | null
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sale_price?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    stock_quantity?: SortOrder
    is_active?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    branch_id?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    images?: SortOrder
    tags?: SortOrder
    min_stock_alert?: SortOrder
    manufacturer?: SortOrder
    tax_rate?: SortOrder
  }

  export type productsAvgOrderByAggregateInput = {
    price?: SortOrder
    sale_price?: SortOrder
    stock_quantity?: SortOrder
    weight?: SortOrder
    min_stock_alert?: SortOrder
    tax_rate?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sale_price?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    stock_quantity?: SortOrder
    is_active?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    branch_id?: SortOrder
    weight?: SortOrder
    min_stock_alert?: SortOrder
    manufacturer?: SortOrder
    tax_rate?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sale_price?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    stock_quantity?: SortOrder
    is_active?: SortOrder
    status?: SortOrder
    category_id?: SortOrder
    branch_id?: SortOrder
    weight?: SortOrder
    min_stock_alert?: SortOrder
    manufacturer?: SortOrder
    tax_rate?: SortOrder
  }

  export type productsSumOrderByAggregateInput = {
    price?: SortOrder
    sale_price?: SortOrder
    stock_quantity?: SortOrder
    weight?: SortOrder
    min_stock_alert?: SortOrder
    tax_rate?: SortOrder
  }

  export type Enumproduct_status_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.product_status_enum | Enumproduct_status_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.product_status_enum[] | ListEnumproduct_status_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.product_status_enum[] | ListEnumproduct_status_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumproduct_status_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.product_status_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumproduct_status_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumproduct_status_enumNullableFilter<$PrismaModel>
  }

  export type type_usersCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    description?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
  }

  export type type_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    description?: SortOrder
    name?: SortOrder
  }

  export type type_usersMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    description?: SortOrder
    name?: SortOrder
  }

  export type Notification_preferencesListRelationFilter = {
    every?: notification_preferencesWhereInput
    some?: notification_preferencesWhereInput
    none?: notification_preferencesWhereInput
  }

  export type Notification_usersListRelationFilter = {
    every?: notification_usersWhereInput
    some?: notification_usersWhereInput
    none?: notification_usersWhereInput
  }

  export type Saved_cardsListRelationFilter = {
    every?: saved_cardsWhereInput
    some?: saved_cardsWhereInput
    none?: saved_cardsWhereInput
  }

  export type Referral_sourcesNullableScalarRelationFilter = {
    is?: referral_sourcesWhereInput | null
    isNot?: referral_sourcesWhereInput | null
  }

  export type Type_usersNullableScalarRelationFilter = {
    is?: type_usersWhereInput | null
    isNot?: type_usersWhereInput | null
  }

  export type WalletsListRelationFilter = {
    every?: walletsWhereInput
    some?: walletsWhereInput
    none?: walletsWhereInput
  }

  export type notification_preferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notification_usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type saved_cardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type walletsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_status?: SortOrder
    birth_date?: SortOrder
    branch_id?: SortOrder
    email?: SortOrder
    first_name?: SortOrder
    is_email_verified?: SortOrder
    is_online?: SortOrder
    is_verified?: SortOrder
    last_name?: SortOrder
    last_seen?: SortOrder
    phone?: SortOrder
    photo_url?: SortOrder
    plan_id?: SortOrder
    type_user_id?: SortOrder
    shipping_insurance?: SortOrder
    is_business?: SortOrder
    ruc?: SortOrder
    company_name?: SortOrder
    referral_source_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_status?: SortOrder
    birth_date?: SortOrder
    branch_id?: SortOrder
    email?: SortOrder
    first_name?: SortOrder
    is_email_verified?: SortOrder
    is_online?: SortOrder
    is_verified?: SortOrder
    last_name?: SortOrder
    last_seen?: SortOrder
    phone?: SortOrder
    photo_url?: SortOrder
    plan_id?: SortOrder
    type_user_id?: SortOrder
    shipping_insurance?: SortOrder
    is_business?: SortOrder
    ruc?: SortOrder
    company_name?: SortOrder
    referral_source_id?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    account_status?: SortOrder
    birth_date?: SortOrder
    branch_id?: SortOrder
    email?: SortOrder
    first_name?: SortOrder
    is_email_verified?: SortOrder
    is_online?: SortOrder
    is_verified?: SortOrder
    last_name?: SortOrder
    last_seen?: SortOrder
    phone?: SortOrder
    photo_url?: SortOrder
    plan_id?: SortOrder
    type_user_id?: SortOrder
    shipping_insurance?: SortOrder
    is_business?: SortOrder
    ruc?: SortOrder
    company_name?: SortOrder
    referral_source_id?: SortOrder
  }

  export type vehiclesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    license_plate?: SortOrder
    status?: SortOrder
    branch_id?: SortOrder
    color?: SortOrder
    vin?: SortOrder
    purchase_date?: SortOrder
    last_maintenance_date?: SortOrder
    mileage?: SortOrder
    fuel_type?: SortOrder
    insurance_info?: SortOrder
    technical_specs?: SortOrder
  }

  export type vehiclesAvgOrderByAggregateInput = {
    year?: SortOrder
    mileage?: SortOrder
  }

  export type vehiclesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    license_plate?: SortOrder
    status?: SortOrder
    branch_id?: SortOrder
    color?: SortOrder
    vin?: SortOrder
    purchase_date?: SortOrder
    last_maintenance_date?: SortOrder
    mileage?: SortOrder
    fuel_type?: SortOrder
  }

  export type vehiclesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    license_plate?: SortOrder
    status?: SortOrder
    branch_id?: SortOrder
    color?: SortOrder
    vin?: SortOrder
    purchase_date?: SortOrder
    last_maintenance_date?: SortOrder
    mileage?: SortOrder
    fuel_type?: SortOrder
  }

  export type vehiclesSumOrderByAggregateInput = {
    year?: SortOrder
    mileage?: SortOrder
  }

  export type walletsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    last_transaction_date?: SortOrder
    user_id?: SortOrder
  }

  export type walletsAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type walletsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    last_transaction_date?: SortOrder
    user_id?: SortOrder
  }

  export type walletsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    last_transaction_date?: SortOrder
    user_id?: SortOrder
  }

  export type walletsSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type saved_cardsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_token?: SortOrder
    card_type?: SortOrder
    cardholder_name?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    brand?: SortOrder
    last_four_digits?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    nick_name?: SortOrder
  }

  export type saved_cardsAvgOrderByAggregateInput = {
    id?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
  }

  export type saved_cardsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_token?: SortOrder
    card_type?: SortOrder
    cardholder_name?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    brand?: SortOrder
    last_four_digits?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    nick_name?: SortOrder
  }

  export type saved_cardsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_token?: SortOrder
    card_type?: SortOrder
    cardholder_name?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
    brand?: SortOrder
    last_four_digits?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    nick_name?: SortOrder
  }

  export type saved_cardsSumOrderByAggregateInput = {
    id?: SortOrder
    expiry_month?: SortOrder
    expiry_year?: SortOrder
  }

  export type Payment_typesNullableScalarRelationFilter = {
    is?: payment_typesWhereInput | null
    isNot?: payment_typesWhereInput | null
  }

  export type TransactionsListRelationFilter = {
    every?: transactionsWhereInput
    some?: transactionsWhereInput
    none?: transactionsWhereInput
  }

  export type transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_methodsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    details?: SortOrder
    payment_type_id?: SortOrder
  }

  export type payment_methodsAvgOrderByAggregateInput = {
    payment_type_id?: SortOrder
  }

  export type payment_methodsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    payment_type_id?: SortOrder
  }

  export type payment_methodsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    payment_type_id?: SortOrder
  }

  export type payment_methodsSumOrderByAggregateInput = {
    payment_type_id?: SortOrder
  }

  export type Transaction_categoriesNullableScalarRelationFilter = {
    is?: transaction_categoriesWhereInput | null
    isNot?: transaction_categoriesWhereInput | null
  }

  export type Transaction_categoriesListRelationFilter = {
    every?: transaction_categoriesWhereInput
    some?: transaction_categoriesWhereInput
    none?: transaction_categoriesWhereInput
  }

  export type transaction_categoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transaction_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parent_id?: SortOrder
    is_active?: SortOrder
  }

  export type transaction_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parent_id?: SortOrder
    is_active?: SortOrder
  }

  export type transaction_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parent_id?: SortOrder
    is_active?: SortOrder
  }

  export type Transaction_typesNullableScalarRelationFilter = {
    is?: transaction_typesWhereInput | null
    isNot?: transaction_typesWhereInput | null
  }

  export type transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    status?: SortOrder
    transaction_date?: SortOrder
    transaction_type?: SortOrder
    reference_id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    payment_method_id?: SortOrder
    metadata?: SortOrder
    category_id?: SortOrder
    transaction_type_id?: SortOrder
    amount?: SortOrder
  }

  export type transactionsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    status?: SortOrder
    transaction_date?: SortOrder
    transaction_type?: SortOrder
    reference_id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    payment_method_id?: SortOrder
    category_id?: SortOrder
    transaction_type_id?: SortOrder
    amount?: SortOrder
  }

  export type transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    status?: SortOrder
    transaction_date?: SortOrder
    transaction_type?: SortOrder
    reference_id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    payment_method_id?: SortOrder
    category_id?: SortOrder
    transaction_type_id?: SortOrder
    amount?: SortOrder
  }

  export type transactionsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type transaction_typesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    affects_balance?: SortOrder
    is_active?: SortOrder
  }

  export type transaction_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    affects_balance?: SortOrder
    is_active?: SortOrder
  }

  export type transaction_typesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    affects_balance?: SortOrder
    is_active?: SortOrder
  }

  export type referral_sourcesCountOrderByAggregateInput = {
    id?: SortOrder
    source_name?: SortOrder
  }

  export type referral_sourcesMaxOrderByAggregateInput = {
    id?: SortOrder
    source_name?: SortOrder
  }

  export type referral_sourcesMinOrderByAggregateInput = {
    id?: SortOrder
    source_name?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type cash_closuresCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    cash_closures?: SortOrder
    total_cash?: SortOrder
    total_yappy?: SortOrder
    total_card?: SortOrder
    total_bank_transfer?: SortOrder
    total_digital_wallet?: SortOrder
    total_internal_wallet?: SortOrder
    total_credits?: SortOrder
    total_debits?: SortOrder
    final_balance?: SortOrder
    status?: SortOrder
  }

  export type cash_closuresAvgOrderByAggregateInput = {
    total_cash?: SortOrder
    total_yappy?: SortOrder
    total_card?: SortOrder
    total_bank_transfer?: SortOrder
    total_digital_wallet?: SortOrder
    total_internal_wallet?: SortOrder
    total_credits?: SortOrder
    total_debits?: SortOrder
    final_balance?: SortOrder
  }

  export type cash_closuresMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    cash_closures?: SortOrder
    total_cash?: SortOrder
    total_yappy?: SortOrder
    total_card?: SortOrder
    total_bank_transfer?: SortOrder
    total_digital_wallet?: SortOrder
    total_internal_wallet?: SortOrder
    total_credits?: SortOrder
    total_debits?: SortOrder
    final_balance?: SortOrder
    status?: SortOrder
  }

  export type cash_closuresMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    cash_closures?: SortOrder
    total_cash?: SortOrder
    total_yappy?: SortOrder
    total_card?: SortOrder
    total_bank_transfer?: SortOrder
    total_digital_wallet?: SortOrder
    total_internal_wallet?: SortOrder
    total_credits?: SortOrder
    total_debits?: SortOrder
    final_balance?: SortOrder
    status?: SortOrder
  }

  export type cash_closuresSumOrderByAggregateInput = {
    total_cash?: SortOrder
    total_yappy?: SortOrder
    total_card?: SortOrder
    total_bank_transfer?: SortOrder
    total_digital_wallet?: SortOrder
    total_internal_wallet?: SortOrder
    total_credits?: SortOrder
    total_debits?: SortOrder
    final_balance?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type branchesCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<branchesCreateWithoutActivitiesInput, branchesUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutActivitiesInput
    connect?: branchesWhereUniqueInput
  }

  export type operatorsCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<operatorsCreateWithoutActivitiesInput, operatorsUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutActivitiesInput
    connect?: operatorsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Enumactivity_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.activity_type_enum
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumactivity_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.activity_status_enum | null
  }

  export type branchesUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<branchesCreateWithoutActivitiesInput, branchesUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutActivitiesInput
    upsert?: branchesUpsertWithoutActivitiesInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutActivitiesInput, branchesUpdateWithoutActivitiesInput>, branchesUncheckedUpdateWithoutActivitiesInput>
  }

  export type operatorsUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<operatorsCreateWithoutActivitiesInput, operatorsUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutActivitiesInput
    upsert?: operatorsUpsertWithoutActivitiesInput
    disconnect?: operatorsWhereInput | boolean
    delete?: operatorsWhereInput | boolean
    connect?: operatorsWhereUniqueInput
    update?: XOR<XOR<operatorsUpdateToOneWithWhereWithoutActivitiesInput, operatorsUpdateWithoutActivitiesInput>, operatorsUncheckedUpdateWithoutActivitiesInput>
  }

  export type activitiesCreateNestedManyWithoutBranchesInput = {
    create?: XOR<activitiesCreateWithoutBranchesInput, activitiesUncheckedCreateWithoutBranchesInput> | activitiesCreateWithoutBranchesInput[] | activitiesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: activitiesCreateOrConnectWithoutBranchesInput | activitiesCreateOrConnectWithoutBranchesInput[]
    createMany?: activitiesCreateManyBranchesInputEnvelope
    connect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
  }

  export type companiesCreateNestedOneWithoutBranchesInput = {
    create?: XOR<companiesCreateWithoutBranchesInput, companiesUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutBranchesInput
    connect?: companiesWhereUniqueInput
  }

  export type gift_cardsCreateNestedManyWithoutBranchesInput = {
    create?: XOR<gift_cardsCreateWithoutBranchesInput, gift_cardsUncheckedCreateWithoutBranchesInput> | gift_cardsCreateWithoutBranchesInput[] | gift_cardsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: gift_cardsCreateOrConnectWithoutBranchesInput | gift_cardsCreateOrConnectWithoutBranchesInput[]
    createMany?: gift_cardsCreateManyBranchesInputEnvelope
    connect?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
  }

  export type invoicesCreateNestedManyWithoutBranchesInput = {
    create?: XOR<invoicesCreateWithoutBranchesInput, invoicesUncheckedCreateWithoutBranchesInput> | invoicesCreateWithoutBranchesInput[] | invoicesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutBranchesInput | invoicesCreateOrConnectWithoutBranchesInput[]
    createMany?: invoicesCreateManyBranchesInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type operatorsCreateNestedManyWithoutBranchesInput = {
    create?: XOR<operatorsCreateWithoutBranchesInput, operatorsUncheckedCreateWithoutBranchesInput> | operatorsCreateWithoutBranchesInput[] | operatorsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: operatorsCreateOrConnectWithoutBranchesInput | operatorsCreateOrConnectWithoutBranchesInput[]
    createMany?: operatorsCreateManyBranchesInputEnvelope
    connect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
  }

  export type packagesCreateNestedManyWithoutBranchesInput = {
    create?: XOR<packagesCreateWithoutBranchesInput, packagesUncheckedCreateWithoutBranchesInput> | packagesCreateWithoutBranchesInput[] | packagesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutBranchesInput | packagesCreateOrConnectWithoutBranchesInput[]
    createMany?: packagesCreateManyBranchesInputEnvelope
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
  }

  export type plansCreateNestedManyWithoutBranchesInput = {
    create?: XOR<plansCreateWithoutBranchesInput, plansUncheckedCreateWithoutBranchesInput> | plansCreateWithoutBranchesInput[] | plansUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: plansCreateOrConnectWithoutBranchesInput | plansCreateOrConnectWithoutBranchesInput[]
    createMany?: plansCreateManyBranchesInputEnvelope
    connect?: plansWhereUniqueInput | plansWhereUniqueInput[]
  }

  export type productsCreateNestedManyWithoutBranchesInput = {
    create?: XOR<productsCreateWithoutBranchesInput, productsUncheckedCreateWithoutBranchesInput> | productsCreateWithoutBranchesInput[] | productsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBranchesInput | productsCreateOrConnectWithoutBranchesInput[]
    createMany?: productsCreateManyBranchesInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutBranchesInput = {
    create?: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput> | usersCreateWithoutBranchesInput[] | usersUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBranchesInput | usersCreateOrConnectWithoutBranchesInput[]
    createMany?: usersCreateManyBranchesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type vehiclesCreateNestedManyWithoutBranchesInput = {
    create?: XOR<vehiclesCreateWithoutBranchesInput, vehiclesUncheckedCreateWithoutBranchesInput> | vehiclesCreateWithoutBranchesInput[] | vehiclesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: vehiclesCreateOrConnectWithoutBranchesInput | vehiclesCreateOrConnectWithoutBranchesInput[]
    createMany?: vehiclesCreateManyBranchesInputEnvelope
    connect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
  }

  export type activitiesUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<activitiesCreateWithoutBranchesInput, activitiesUncheckedCreateWithoutBranchesInput> | activitiesCreateWithoutBranchesInput[] | activitiesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: activitiesCreateOrConnectWithoutBranchesInput | activitiesCreateOrConnectWithoutBranchesInput[]
    createMany?: activitiesCreateManyBranchesInputEnvelope
    connect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
  }

  export type gift_cardsUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<gift_cardsCreateWithoutBranchesInput, gift_cardsUncheckedCreateWithoutBranchesInput> | gift_cardsCreateWithoutBranchesInput[] | gift_cardsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: gift_cardsCreateOrConnectWithoutBranchesInput | gift_cardsCreateOrConnectWithoutBranchesInput[]
    createMany?: gift_cardsCreateManyBranchesInputEnvelope
    connect?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
  }

  export type invoicesUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<invoicesCreateWithoutBranchesInput, invoicesUncheckedCreateWithoutBranchesInput> | invoicesCreateWithoutBranchesInput[] | invoicesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutBranchesInput | invoicesCreateOrConnectWithoutBranchesInput[]
    createMany?: invoicesCreateManyBranchesInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type operatorsUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<operatorsCreateWithoutBranchesInput, operatorsUncheckedCreateWithoutBranchesInput> | operatorsCreateWithoutBranchesInput[] | operatorsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: operatorsCreateOrConnectWithoutBranchesInput | operatorsCreateOrConnectWithoutBranchesInput[]
    createMany?: operatorsCreateManyBranchesInputEnvelope
    connect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
  }

  export type packagesUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<packagesCreateWithoutBranchesInput, packagesUncheckedCreateWithoutBranchesInput> | packagesCreateWithoutBranchesInput[] | packagesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutBranchesInput | packagesCreateOrConnectWithoutBranchesInput[]
    createMany?: packagesCreateManyBranchesInputEnvelope
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
  }

  export type plansUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<plansCreateWithoutBranchesInput, plansUncheckedCreateWithoutBranchesInput> | plansCreateWithoutBranchesInput[] | plansUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: plansCreateOrConnectWithoutBranchesInput | plansCreateOrConnectWithoutBranchesInput[]
    createMany?: plansCreateManyBranchesInputEnvelope
    connect?: plansWhereUniqueInput | plansWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<productsCreateWithoutBranchesInput, productsUncheckedCreateWithoutBranchesInput> | productsCreateWithoutBranchesInput[] | productsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBranchesInput | productsCreateOrConnectWithoutBranchesInput[]
    createMany?: productsCreateManyBranchesInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput> | usersCreateWithoutBranchesInput[] | usersUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBranchesInput | usersCreateOrConnectWithoutBranchesInput[]
    createMany?: usersCreateManyBranchesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type vehiclesUncheckedCreateNestedManyWithoutBranchesInput = {
    create?: XOR<vehiclesCreateWithoutBranchesInput, vehiclesUncheckedCreateWithoutBranchesInput> | vehiclesCreateWithoutBranchesInput[] | vehiclesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: vehiclesCreateOrConnectWithoutBranchesInput | vehiclesCreateOrConnectWithoutBranchesInput[]
    createMany?: vehiclesCreateManyBranchesInputEnvelope
    connect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type activitiesUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<activitiesCreateWithoutBranchesInput, activitiesUncheckedCreateWithoutBranchesInput> | activitiesCreateWithoutBranchesInput[] | activitiesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: activitiesCreateOrConnectWithoutBranchesInput | activitiesCreateOrConnectWithoutBranchesInput[]
    upsert?: activitiesUpsertWithWhereUniqueWithoutBranchesInput | activitiesUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: activitiesCreateManyBranchesInputEnvelope
    set?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    disconnect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    delete?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    connect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    update?: activitiesUpdateWithWhereUniqueWithoutBranchesInput | activitiesUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: activitiesUpdateManyWithWhereWithoutBranchesInput | activitiesUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: activitiesScalarWhereInput | activitiesScalarWhereInput[]
  }

  export type companiesUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<companiesCreateWithoutBranchesInput, companiesUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutBranchesInput
    upsert?: companiesUpsertWithoutBranchesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutBranchesInput, companiesUpdateWithoutBranchesInput>, companiesUncheckedUpdateWithoutBranchesInput>
  }

  export type gift_cardsUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<gift_cardsCreateWithoutBranchesInput, gift_cardsUncheckedCreateWithoutBranchesInput> | gift_cardsCreateWithoutBranchesInput[] | gift_cardsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: gift_cardsCreateOrConnectWithoutBranchesInput | gift_cardsCreateOrConnectWithoutBranchesInput[]
    upsert?: gift_cardsUpsertWithWhereUniqueWithoutBranchesInput | gift_cardsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: gift_cardsCreateManyBranchesInputEnvelope
    set?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
    disconnect?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
    delete?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
    connect?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
    update?: gift_cardsUpdateWithWhereUniqueWithoutBranchesInput | gift_cardsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: gift_cardsUpdateManyWithWhereWithoutBranchesInput | gift_cardsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: gift_cardsScalarWhereInput | gift_cardsScalarWhereInput[]
  }

  export type invoicesUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<invoicesCreateWithoutBranchesInput, invoicesUncheckedCreateWithoutBranchesInput> | invoicesCreateWithoutBranchesInput[] | invoicesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutBranchesInput | invoicesCreateOrConnectWithoutBranchesInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutBranchesInput | invoicesUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: invoicesCreateManyBranchesInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutBranchesInput | invoicesUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutBranchesInput | invoicesUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type operatorsUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<operatorsCreateWithoutBranchesInput, operatorsUncheckedCreateWithoutBranchesInput> | operatorsCreateWithoutBranchesInput[] | operatorsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: operatorsCreateOrConnectWithoutBranchesInput | operatorsCreateOrConnectWithoutBranchesInput[]
    upsert?: operatorsUpsertWithWhereUniqueWithoutBranchesInput | operatorsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: operatorsCreateManyBranchesInputEnvelope
    set?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    disconnect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    delete?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    connect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    update?: operatorsUpdateWithWhereUniqueWithoutBranchesInput | operatorsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: operatorsUpdateManyWithWhereWithoutBranchesInput | operatorsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: operatorsScalarWhereInput | operatorsScalarWhereInput[]
  }

  export type packagesUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<packagesCreateWithoutBranchesInput, packagesUncheckedCreateWithoutBranchesInput> | packagesCreateWithoutBranchesInput[] | packagesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutBranchesInput | packagesCreateOrConnectWithoutBranchesInput[]
    upsert?: packagesUpsertWithWhereUniqueWithoutBranchesInput | packagesUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: packagesCreateManyBranchesInputEnvelope
    set?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    disconnect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    delete?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    update?: packagesUpdateWithWhereUniqueWithoutBranchesInput | packagesUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: packagesUpdateManyWithWhereWithoutBranchesInput | packagesUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: packagesScalarWhereInput | packagesScalarWhereInput[]
  }

  export type plansUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<plansCreateWithoutBranchesInput, plansUncheckedCreateWithoutBranchesInput> | plansCreateWithoutBranchesInput[] | plansUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: plansCreateOrConnectWithoutBranchesInput | plansCreateOrConnectWithoutBranchesInput[]
    upsert?: plansUpsertWithWhereUniqueWithoutBranchesInput | plansUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: plansCreateManyBranchesInputEnvelope
    set?: plansWhereUniqueInput | plansWhereUniqueInput[]
    disconnect?: plansWhereUniqueInput | plansWhereUniqueInput[]
    delete?: plansWhereUniqueInput | plansWhereUniqueInput[]
    connect?: plansWhereUniqueInput | plansWhereUniqueInput[]
    update?: plansUpdateWithWhereUniqueWithoutBranchesInput | plansUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: plansUpdateManyWithWhereWithoutBranchesInput | plansUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: plansScalarWhereInput | plansScalarWhereInput[]
  }

  export type productsUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<productsCreateWithoutBranchesInput, productsUncheckedCreateWithoutBranchesInput> | productsCreateWithoutBranchesInput[] | productsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBranchesInput | productsCreateOrConnectWithoutBranchesInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutBranchesInput | productsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: productsCreateManyBranchesInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutBranchesInput | productsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: productsUpdateManyWithWhereWithoutBranchesInput | productsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput> | usersCreateWithoutBranchesInput[] | usersUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBranchesInput | usersCreateOrConnectWithoutBranchesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutBranchesInput | usersUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: usersCreateManyBranchesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutBranchesInput | usersUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutBranchesInput | usersUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type vehiclesUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<vehiclesCreateWithoutBranchesInput, vehiclesUncheckedCreateWithoutBranchesInput> | vehiclesCreateWithoutBranchesInput[] | vehiclesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: vehiclesCreateOrConnectWithoutBranchesInput | vehiclesCreateOrConnectWithoutBranchesInput[]
    upsert?: vehiclesUpsertWithWhereUniqueWithoutBranchesInput | vehiclesUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: vehiclesCreateManyBranchesInputEnvelope
    set?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    disconnect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    delete?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    connect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    update?: vehiclesUpdateWithWhereUniqueWithoutBranchesInput | vehiclesUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: vehiclesUpdateManyWithWhereWithoutBranchesInput | vehiclesUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: vehiclesScalarWhereInput | vehiclesScalarWhereInput[]
  }

  export type activitiesUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<activitiesCreateWithoutBranchesInput, activitiesUncheckedCreateWithoutBranchesInput> | activitiesCreateWithoutBranchesInput[] | activitiesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: activitiesCreateOrConnectWithoutBranchesInput | activitiesCreateOrConnectWithoutBranchesInput[]
    upsert?: activitiesUpsertWithWhereUniqueWithoutBranchesInput | activitiesUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: activitiesCreateManyBranchesInputEnvelope
    set?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    disconnect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    delete?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    connect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    update?: activitiesUpdateWithWhereUniqueWithoutBranchesInput | activitiesUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: activitiesUpdateManyWithWhereWithoutBranchesInput | activitiesUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: activitiesScalarWhereInput | activitiesScalarWhereInput[]
  }

  export type gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<gift_cardsCreateWithoutBranchesInput, gift_cardsUncheckedCreateWithoutBranchesInput> | gift_cardsCreateWithoutBranchesInput[] | gift_cardsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: gift_cardsCreateOrConnectWithoutBranchesInput | gift_cardsCreateOrConnectWithoutBranchesInput[]
    upsert?: gift_cardsUpsertWithWhereUniqueWithoutBranchesInput | gift_cardsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: gift_cardsCreateManyBranchesInputEnvelope
    set?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
    disconnect?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
    delete?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
    connect?: gift_cardsWhereUniqueInput | gift_cardsWhereUniqueInput[]
    update?: gift_cardsUpdateWithWhereUniqueWithoutBranchesInput | gift_cardsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: gift_cardsUpdateManyWithWhereWithoutBranchesInput | gift_cardsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: gift_cardsScalarWhereInput | gift_cardsScalarWhereInput[]
  }

  export type invoicesUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<invoicesCreateWithoutBranchesInput, invoicesUncheckedCreateWithoutBranchesInput> | invoicesCreateWithoutBranchesInput[] | invoicesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutBranchesInput | invoicesCreateOrConnectWithoutBranchesInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutBranchesInput | invoicesUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: invoicesCreateManyBranchesInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutBranchesInput | invoicesUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutBranchesInput | invoicesUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type operatorsUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<operatorsCreateWithoutBranchesInput, operatorsUncheckedCreateWithoutBranchesInput> | operatorsCreateWithoutBranchesInput[] | operatorsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: operatorsCreateOrConnectWithoutBranchesInput | operatorsCreateOrConnectWithoutBranchesInput[]
    upsert?: operatorsUpsertWithWhereUniqueWithoutBranchesInput | operatorsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: operatorsCreateManyBranchesInputEnvelope
    set?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    disconnect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    delete?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    connect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    update?: operatorsUpdateWithWhereUniqueWithoutBranchesInput | operatorsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: operatorsUpdateManyWithWhereWithoutBranchesInput | operatorsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: operatorsScalarWhereInput | operatorsScalarWhereInput[]
  }

  export type packagesUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<packagesCreateWithoutBranchesInput, packagesUncheckedCreateWithoutBranchesInput> | packagesCreateWithoutBranchesInput[] | packagesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutBranchesInput | packagesCreateOrConnectWithoutBranchesInput[]
    upsert?: packagesUpsertWithWhereUniqueWithoutBranchesInput | packagesUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: packagesCreateManyBranchesInputEnvelope
    set?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    disconnect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    delete?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    update?: packagesUpdateWithWhereUniqueWithoutBranchesInput | packagesUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: packagesUpdateManyWithWhereWithoutBranchesInput | packagesUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: packagesScalarWhereInput | packagesScalarWhereInput[]
  }

  export type plansUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<plansCreateWithoutBranchesInput, plansUncheckedCreateWithoutBranchesInput> | plansCreateWithoutBranchesInput[] | plansUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: plansCreateOrConnectWithoutBranchesInput | plansCreateOrConnectWithoutBranchesInput[]
    upsert?: plansUpsertWithWhereUniqueWithoutBranchesInput | plansUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: plansCreateManyBranchesInputEnvelope
    set?: plansWhereUniqueInput | plansWhereUniqueInput[]
    disconnect?: plansWhereUniqueInput | plansWhereUniqueInput[]
    delete?: plansWhereUniqueInput | plansWhereUniqueInput[]
    connect?: plansWhereUniqueInput | plansWhereUniqueInput[]
    update?: plansUpdateWithWhereUniqueWithoutBranchesInput | plansUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: plansUpdateManyWithWhereWithoutBranchesInput | plansUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: plansScalarWhereInput | plansScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<productsCreateWithoutBranchesInput, productsUncheckedCreateWithoutBranchesInput> | productsCreateWithoutBranchesInput[] | productsUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBranchesInput | productsCreateOrConnectWithoutBranchesInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutBranchesInput | productsUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: productsCreateManyBranchesInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutBranchesInput | productsUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: productsUpdateManyWithWhereWithoutBranchesInput | productsUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput> | usersCreateWithoutBranchesInput[] | usersUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBranchesInput | usersCreateOrConnectWithoutBranchesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutBranchesInput | usersUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: usersCreateManyBranchesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutBranchesInput | usersUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutBranchesInput | usersUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type vehiclesUncheckedUpdateManyWithoutBranchesNestedInput = {
    create?: XOR<vehiclesCreateWithoutBranchesInput, vehiclesUncheckedCreateWithoutBranchesInput> | vehiclesCreateWithoutBranchesInput[] | vehiclesUncheckedCreateWithoutBranchesInput[]
    connectOrCreate?: vehiclesCreateOrConnectWithoutBranchesInput | vehiclesCreateOrConnectWithoutBranchesInput[]
    upsert?: vehiclesUpsertWithWhereUniqueWithoutBranchesInput | vehiclesUpsertWithWhereUniqueWithoutBranchesInput[]
    createMany?: vehiclesCreateManyBranchesInputEnvelope
    set?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    disconnect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    delete?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    connect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    update?: vehiclesUpdateWithWhereUniqueWithoutBranchesInput | vehiclesUpdateWithWhereUniqueWithoutBranchesInput[]
    updateMany?: vehiclesUpdateManyWithWhereWithoutBranchesInput | vehiclesUpdateManyWithWhereWithoutBranchesInput[]
    deleteMany?: vehiclesScalarWhereInput | vehiclesScalarWhereInput[]
  }

  export type productsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput> | productsCreateWithoutCategoriesInput[] | productsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutCategoriesInput | productsCreateOrConnectWithoutCategoriesInput[]
    createMany?: productsCreateManyCategoriesInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput> | productsCreateWithoutCategoriesInput[] | productsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutCategoriesInput | productsCreateOrConnectWithoutCategoriesInput[]
    createMany?: productsCreateManyCategoriesInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type productsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput> | productsCreateWithoutCategoriesInput[] | productsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutCategoriesInput | productsCreateOrConnectWithoutCategoriesInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutCategoriesInput | productsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: productsCreateManyCategoriesInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutCategoriesInput | productsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: productsUpdateManyWithWhereWithoutCategoriesInput | productsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput> | productsCreateWithoutCategoriesInput[] | productsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutCategoriesInput | productsCreateOrConnectWithoutCategoriesInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutCategoriesInput | productsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: productsCreateManyCategoriesInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutCategoriesInput | productsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: productsUpdateManyWithWhereWithoutCategoriesInput | productsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type branchesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<branchesCreateWithoutCompaniesInput, branchesUncheckedCreateWithoutCompaniesInput> | branchesCreateWithoutCompaniesInput[] | branchesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: branchesCreateOrConnectWithoutCompaniesInput | branchesCreateOrConnectWithoutCompaniesInput[]
    createMany?: branchesCreateManyCompaniesInputEnvelope
    connect?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
  }

  export type branchesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<branchesCreateWithoutCompaniesInput, branchesUncheckedCreateWithoutCompaniesInput> | branchesCreateWithoutCompaniesInput[] | branchesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: branchesCreateOrConnectWithoutCompaniesInput | branchesCreateOrConnectWithoutCompaniesInput[]
    createMany?: branchesCreateManyCompaniesInputEnvelope
    connect?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
  }

  export type branchesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<branchesCreateWithoutCompaniesInput, branchesUncheckedCreateWithoutCompaniesInput> | branchesCreateWithoutCompaniesInput[] | branchesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: branchesCreateOrConnectWithoutCompaniesInput | branchesCreateOrConnectWithoutCompaniesInput[]
    upsert?: branchesUpsertWithWhereUniqueWithoutCompaniesInput | branchesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: branchesCreateManyCompaniesInputEnvelope
    set?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
    disconnect?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
    delete?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
    connect?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
    update?: branchesUpdateWithWhereUniqueWithoutCompaniesInput | branchesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: branchesUpdateManyWithWhereWithoutCompaniesInput | branchesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: branchesScalarWhereInput | branchesScalarWhereInput[]
  }

  export type branchesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<branchesCreateWithoutCompaniesInput, branchesUncheckedCreateWithoutCompaniesInput> | branchesCreateWithoutCompaniesInput[] | branchesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: branchesCreateOrConnectWithoutCompaniesInput | branchesCreateOrConnectWithoutCompaniesInput[]
    upsert?: branchesUpsertWithWhereUniqueWithoutCompaniesInput | branchesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: branchesCreateManyCompaniesInputEnvelope
    set?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
    disconnect?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
    delete?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
    connect?: branchesWhereUniqueInput | branchesWhereUniqueInput[]
    update?: branchesUpdateWithWhereUniqueWithoutCompaniesInput | branchesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: branchesUpdateManyWithWhereWithoutCompaniesInput | branchesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: branchesScalarWhereInput | branchesScalarWhereInput[]
  }

  export type email_campaignsCreatetest_recipientsInput = {
    set: string[]
  }

  export type email_templatesCreateNestedOneWithoutEmail_campaignsInput = {
    create?: XOR<email_templatesCreateWithoutEmail_campaignsInput, email_templatesUncheckedCreateWithoutEmail_campaignsInput>
    connectOrCreate?: email_templatesCreateOrConnectWithoutEmail_campaignsInput
    connect?: email_templatesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutEmail_campaignsInput = {
    create?: XOR<usersCreateWithoutEmail_campaignsInput, usersUncheckedCreateWithoutEmail_campaignsInput>
    connectOrCreate?: usersCreateOrConnectWithoutEmail_campaignsInput
    connect?: usersWhereUniqueInput
  }

  export type email_campaignsUpdatetest_recipientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type email_templatesUpdateOneWithoutEmail_campaignsNestedInput = {
    create?: XOR<email_templatesCreateWithoutEmail_campaignsInput, email_templatesUncheckedCreateWithoutEmail_campaignsInput>
    connectOrCreate?: email_templatesCreateOrConnectWithoutEmail_campaignsInput
    upsert?: email_templatesUpsertWithoutEmail_campaignsInput
    disconnect?: email_templatesWhereInput | boolean
    delete?: email_templatesWhereInput | boolean
    connect?: email_templatesWhereUniqueInput
    update?: XOR<XOR<email_templatesUpdateToOneWithWhereWithoutEmail_campaignsInput, email_templatesUpdateWithoutEmail_campaignsInput>, email_templatesUncheckedUpdateWithoutEmail_campaignsInput>
  }

  export type usersUpdateOneWithoutEmail_campaignsNestedInput = {
    create?: XOR<usersCreateWithoutEmail_campaignsInput, usersUncheckedCreateWithoutEmail_campaignsInput>
    connectOrCreate?: usersCreateOrConnectWithoutEmail_campaignsInput
    upsert?: usersUpsertWithoutEmail_campaignsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutEmail_campaignsInput, usersUpdateWithoutEmail_campaignsInput>, usersUncheckedUpdateWithoutEmail_campaignsInput>
  }

  export type email_campaignsCreateNestedManyWithoutEmail_templatesInput = {
    create?: XOR<email_campaignsCreateWithoutEmail_templatesInput, email_campaignsUncheckedCreateWithoutEmail_templatesInput> | email_campaignsCreateWithoutEmail_templatesInput[] | email_campaignsUncheckedCreateWithoutEmail_templatesInput[]
    connectOrCreate?: email_campaignsCreateOrConnectWithoutEmail_templatesInput | email_campaignsCreateOrConnectWithoutEmail_templatesInput[]
    createMany?: email_campaignsCreateManyEmail_templatesInputEnvelope
    connect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
  }

  export type operatorsCreateNestedOneWithoutEmail_templatesInput = {
    create?: XOR<operatorsCreateWithoutEmail_templatesInput, operatorsUncheckedCreateWithoutEmail_templatesInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutEmail_templatesInput
    connect?: operatorsWhereUniqueInput
  }

  export type email_campaignsUncheckedCreateNestedManyWithoutEmail_templatesInput = {
    create?: XOR<email_campaignsCreateWithoutEmail_templatesInput, email_campaignsUncheckedCreateWithoutEmail_templatesInput> | email_campaignsCreateWithoutEmail_templatesInput[] | email_campaignsUncheckedCreateWithoutEmail_templatesInput[]
    connectOrCreate?: email_campaignsCreateOrConnectWithoutEmail_templatesInput | email_campaignsCreateOrConnectWithoutEmail_templatesInput[]
    createMany?: email_campaignsCreateManyEmail_templatesInputEnvelope
    connect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
  }

  export type email_campaignsUpdateManyWithoutEmail_templatesNestedInput = {
    create?: XOR<email_campaignsCreateWithoutEmail_templatesInput, email_campaignsUncheckedCreateWithoutEmail_templatesInput> | email_campaignsCreateWithoutEmail_templatesInput[] | email_campaignsUncheckedCreateWithoutEmail_templatesInput[]
    connectOrCreate?: email_campaignsCreateOrConnectWithoutEmail_templatesInput | email_campaignsCreateOrConnectWithoutEmail_templatesInput[]
    upsert?: email_campaignsUpsertWithWhereUniqueWithoutEmail_templatesInput | email_campaignsUpsertWithWhereUniqueWithoutEmail_templatesInput[]
    createMany?: email_campaignsCreateManyEmail_templatesInputEnvelope
    set?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    disconnect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    delete?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    connect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    update?: email_campaignsUpdateWithWhereUniqueWithoutEmail_templatesInput | email_campaignsUpdateWithWhereUniqueWithoutEmail_templatesInput[]
    updateMany?: email_campaignsUpdateManyWithWhereWithoutEmail_templatesInput | email_campaignsUpdateManyWithWhereWithoutEmail_templatesInput[]
    deleteMany?: email_campaignsScalarWhereInput | email_campaignsScalarWhereInput[]
  }

  export type operatorsUpdateOneWithoutEmail_templatesNestedInput = {
    create?: XOR<operatorsCreateWithoutEmail_templatesInput, operatorsUncheckedCreateWithoutEmail_templatesInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutEmail_templatesInput
    upsert?: operatorsUpsertWithoutEmail_templatesInput
    disconnect?: operatorsWhereInput | boolean
    delete?: operatorsWhereInput | boolean
    connect?: operatorsWhereUniqueInput
    update?: XOR<XOR<operatorsUpdateToOneWithWhereWithoutEmail_templatesInput, operatorsUpdateWithoutEmail_templatesInput>, operatorsUncheckedUpdateWithoutEmail_templatesInput>
  }

  export type email_campaignsUncheckedUpdateManyWithoutEmail_templatesNestedInput = {
    create?: XOR<email_campaignsCreateWithoutEmail_templatesInput, email_campaignsUncheckedCreateWithoutEmail_templatesInput> | email_campaignsCreateWithoutEmail_templatesInput[] | email_campaignsUncheckedCreateWithoutEmail_templatesInput[]
    connectOrCreate?: email_campaignsCreateOrConnectWithoutEmail_templatesInput | email_campaignsCreateOrConnectWithoutEmail_templatesInput[]
    upsert?: email_campaignsUpsertWithWhereUniqueWithoutEmail_templatesInput | email_campaignsUpsertWithWhereUniqueWithoutEmail_templatesInput[]
    createMany?: email_campaignsCreateManyEmail_templatesInputEnvelope
    set?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    disconnect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    delete?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    connect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    update?: email_campaignsUpdateWithWhereUniqueWithoutEmail_templatesInput | email_campaignsUpdateWithWhereUniqueWithoutEmail_templatesInput[]
    updateMany?: email_campaignsUpdateManyWithWhereWithoutEmail_templatesInput | email_campaignsUpdateManyWithWhereWithoutEmail_templatesInput[]
    deleteMany?: email_campaignsScalarWhereInput | email_campaignsScalarWhereInput[]
  }

  export type gift_cardsCreateusage_historyInput = {
    set: InputJsonValue[]
  }

  export type branchesCreateNestedOneWithoutGift_cardsInput = {
    create?: XOR<branchesCreateWithoutGift_cardsInput, branchesUncheckedCreateWithoutGift_cardsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutGift_cardsInput
    connect?: branchesWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumpayment_method_enumFieldUpdateOperationsInput = {
    set?: $Enums.payment_method_enum | null
  }

  export type gift_cardsUpdateusage_historyInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type branchesUpdateOneWithoutGift_cardsNestedInput = {
    create?: XOR<branchesCreateWithoutGift_cardsInput, branchesUncheckedCreateWithoutGift_cardsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutGift_cardsInput
    upsert?: branchesUpsertWithoutGift_cardsInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutGift_cardsInput, branchesUpdateWithoutGift_cardsInput>, branchesUncheckedUpdateWithoutGift_cardsInput>
  }

  export type invoice_itemsCreateserial_numbersInput = {
    set: string[]
  }

  export type invoicesCreateNestedOneWithoutInvoice_itemsInput = {
    create?: XOR<invoicesCreateWithoutInvoice_itemsInput, invoicesUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutInvoice_itemsInput
    connect?: invoicesWhereUniqueInput
  }

  export type plansCreateNestedOneWithoutInvoice_itemsInput = {
    create?: XOR<plansCreateWithoutInvoice_itemsInput, plansUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: plansCreateOrConnectWithoutInvoice_itemsInput
    connect?: plansWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutInvoice_itemsInput = {
    create?: XOR<productsCreateWithoutInvoice_itemsInput, productsUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: productsCreateOrConnectWithoutInvoice_itemsInput
    connect?: productsWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type invoice_itemsUpdateserial_numbersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type invoicesUpdateOneRequiredWithoutInvoice_itemsNestedInput = {
    create?: XOR<invoicesCreateWithoutInvoice_itemsInput, invoicesUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutInvoice_itemsInput
    upsert?: invoicesUpsertWithoutInvoice_itemsInput
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutInvoice_itemsInput, invoicesUpdateWithoutInvoice_itemsInput>, invoicesUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type plansUpdateOneWithoutInvoice_itemsNestedInput = {
    create?: XOR<plansCreateWithoutInvoice_itemsInput, plansUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: plansCreateOrConnectWithoutInvoice_itemsInput
    upsert?: plansUpsertWithoutInvoice_itemsInput
    disconnect?: plansWhereInput | boolean
    delete?: plansWhereInput | boolean
    connect?: plansWhereUniqueInput
    update?: XOR<XOR<plansUpdateToOneWithWhereWithoutInvoice_itemsInput, plansUpdateWithoutInvoice_itemsInput>, plansUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type productsUpdateOneWithoutInvoice_itemsNestedInput = {
    create?: XOR<productsCreateWithoutInvoice_itemsInput, productsUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: productsCreateOrConnectWithoutInvoice_itemsInput
    upsert?: productsUpsertWithoutInvoice_itemsInput
    disconnect?: productsWhereInput | boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutInvoice_itemsInput, productsUpdateWithoutInvoice_itemsInput>, productsUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type invoicesCreateNestedOneWithoutInvoice_packagesInput = {
    create?: XOR<invoicesCreateWithoutInvoice_packagesInput, invoicesUncheckedCreateWithoutInvoice_packagesInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutInvoice_packagesInput
    connect?: invoicesWhereUniqueInput
  }

  export type packagesCreateNestedOneWithoutInvoice_packagesInput = {
    create?: XOR<packagesCreateWithoutInvoice_packagesInput, packagesUncheckedCreateWithoutInvoice_packagesInput>
    connectOrCreate?: packagesCreateOrConnectWithoutInvoice_packagesInput
    connect?: packagesWhereUniqueInput
  }

  export type invoicesUpdateOneRequiredWithoutInvoice_packagesNestedInput = {
    create?: XOR<invoicesCreateWithoutInvoice_packagesInput, invoicesUncheckedCreateWithoutInvoice_packagesInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutInvoice_packagesInput
    upsert?: invoicesUpsertWithoutInvoice_packagesInput
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutInvoice_packagesInput, invoicesUpdateWithoutInvoice_packagesInput>, invoicesUncheckedUpdateWithoutInvoice_packagesInput>
  }

  export type packagesUpdateOneRequiredWithoutInvoice_packagesNestedInput = {
    create?: XOR<packagesCreateWithoutInvoice_packagesInput, packagesUncheckedCreateWithoutInvoice_packagesInput>
    connectOrCreate?: packagesCreateOrConnectWithoutInvoice_packagesInput
    upsert?: packagesUpsertWithoutInvoice_packagesInput
    connect?: packagesWhereUniqueInput
    update?: XOR<XOR<packagesUpdateToOneWithWhereWithoutInvoice_packagesInput, packagesUpdateWithoutInvoice_packagesInput>, packagesUncheckedUpdateWithoutInvoice_packagesInput>
  }

  export type invoice_itemsCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput> | invoice_itemsCreateWithoutInvoicesInput[] | invoice_itemsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutInvoicesInput | invoice_itemsCreateOrConnectWithoutInvoicesInput[]
    createMany?: invoice_itemsCreateManyInvoicesInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type invoice_packagesCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<invoice_packagesCreateWithoutInvoicesInput, invoice_packagesUncheckedCreateWithoutInvoicesInput> | invoice_packagesCreateWithoutInvoicesInput[] | invoice_packagesUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_packagesCreateOrConnectWithoutInvoicesInput | invoice_packagesCreateOrConnectWithoutInvoicesInput[]
    createMany?: invoice_packagesCreateManyInvoicesInputEnvelope
    connect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
  }

  export type branchesCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<branchesCreateWithoutInvoicesInput, branchesUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutInvoicesInput
    connect?: branchesWhereUniqueInput
  }

  export type operatorsCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<operatorsCreateWithoutInvoicesInput, operatorsUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutInvoicesInput
    connect?: operatorsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: usersCreateOrConnectWithoutInvoicesInput
    connect?: usersWhereUniqueInput
  }

  export type paymentsCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput> | paymentsCreateWithoutInvoicesInput[] | paymentsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoicesInput | paymentsCreateOrConnectWithoutInvoicesInput[]
    createMany?: paymentsCreateManyInvoicesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput> | invoice_itemsCreateWithoutInvoicesInput[] | invoice_itemsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutInvoicesInput | invoice_itemsCreateOrConnectWithoutInvoicesInput[]
    createMany?: invoice_itemsCreateManyInvoicesInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type invoice_packagesUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<invoice_packagesCreateWithoutInvoicesInput, invoice_packagesUncheckedCreateWithoutInvoicesInput> | invoice_packagesCreateWithoutInvoicesInput[] | invoice_packagesUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_packagesCreateOrConnectWithoutInvoicesInput | invoice_packagesCreateOrConnectWithoutInvoicesInput[]
    createMany?: invoice_packagesCreateManyInvoicesInputEnvelope
    connect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput> | paymentsCreateWithoutInvoicesInput[] | paymentsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoicesInput | paymentsCreateOrConnectWithoutInvoicesInput[]
    createMany?: paymentsCreateManyInvoicesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type Enuminvoice_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.invoice_status_enum
  }

  export type NullableEnuminvoice_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.invoice_type_enum | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type invoice_itemsUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput> | invoice_itemsCreateWithoutInvoicesInput[] | invoice_itemsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutInvoicesInput | invoice_itemsCreateOrConnectWithoutInvoicesInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput | invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: invoice_itemsCreateManyInvoicesInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput | invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutInvoicesInput | invoice_itemsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type invoice_packagesUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<invoice_packagesCreateWithoutInvoicesInput, invoice_packagesUncheckedCreateWithoutInvoicesInput> | invoice_packagesCreateWithoutInvoicesInput[] | invoice_packagesUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_packagesCreateOrConnectWithoutInvoicesInput | invoice_packagesCreateOrConnectWithoutInvoicesInput[]
    upsert?: invoice_packagesUpsertWithWhereUniqueWithoutInvoicesInput | invoice_packagesUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: invoice_packagesCreateManyInvoicesInputEnvelope
    set?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    disconnect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    delete?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    connect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    update?: invoice_packagesUpdateWithWhereUniqueWithoutInvoicesInput | invoice_packagesUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: invoice_packagesUpdateManyWithWhereWithoutInvoicesInput | invoice_packagesUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: invoice_packagesScalarWhereInput | invoice_packagesScalarWhereInput[]
  }

  export type branchesUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<branchesCreateWithoutInvoicesInput, branchesUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutInvoicesInput
    upsert?: branchesUpsertWithoutInvoicesInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutInvoicesInput, branchesUpdateWithoutInvoicesInput>, branchesUncheckedUpdateWithoutInvoicesInput>
  }

  export type operatorsUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<operatorsCreateWithoutInvoicesInput, operatorsUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutInvoicesInput
    upsert?: operatorsUpsertWithoutInvoicesInput
    disconnect?: operatorsWhereInput | boolean
    delete?: operatorsWhereInput | boolean
    connect?: operatorsWhereUniqueInput
    update?: XOR<XOR<operatorsUpdateToOneWithWhereWithoutInvoicesInput, operatorsUpdateWithoutInvoicesInput>, operatorsUncheckedUpdateWithoutInvoicesInput>
  }

  export type usersUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: usersCreateOrConnectWithoutInvoicesInput
    upsert?: usersUpsertWithoutInvoicesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutInvoicesInput, usersUpdateWithoutInvoicesInput>, usersUncheckedUpdateWithoutInvoicesInput>
  }

  export type paymentsUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput> | paymentsCreateWithoutInvoicesInput[] | paymentsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoicesInput | paymentsCreateOrConnectWithoutInvoicesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutInvoicesInput | paymentsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: paymentsCreateManyInvoicesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutInvoicesInput | paymentsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutInvoicesInput | paymentsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput> | invoice_itemsCreateWithoutInvoicesInput[] | invoice_itemsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutInvoicesInput | invoice_itemsCreateOrConnectWithoutInvoicesInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput | invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: invoice_itemsCreateManyInvoicesInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput | invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutInvoicesInput | invoice_itemsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type invoice_packagesUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<invoice_packagesCreateWithoutInvoicesInput, invoice_packagesUncheckedCreateWithoutInvoicesInput> | invoice_packagesCreateWithoutInvoicesInput[] | invoice_packagesUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_packagesCreateOrConnectWithoutInvoicesInput | invoice_packagesCreateOrConnectWithoutInvoicesInput[]
    upsert?: invoice_packagesUpsertWithWhereUniqueWithoutInvoicesInput | invoice_packagesUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: invoice_packagesCreateManyInvoicesInputEnvelope
    set?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    disconnect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    delete?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    connect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    update?: invoice_packagesUpdateWithWhereUniqueWithoutInvoicesInput | invoice_packagesUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: invoice_packagesUpdateManyWithWhereWithoutInvoicesInput | invoice_packagesUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: invoice_packagesScalarWhereInput | invoice_packagesScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput> | paymentsCreateWithoutInvoicesInput[] | paymentsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoicesInput | paymentsCreateOrConnectWithoutInvoicesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutInvoicesInput | paymentsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: paymentsCreateManyInvoicesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutInvoicesInput | paymentsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutInvoicesInput | paymentsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutNotification_preferencesInput = {
    create?: XOR<usersCreateWithoutNotification_preferencesInput, usersUncheckedCreateWithoutNotification_preferencesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotification_preferencesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNotification_preferencesNestedInput = {
    create?: XOR<usersCreateWithoutNotification_preferencesInput, usersUncheckedCreateWithoutNotification_preferencesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotification_preferencesInput
    upsert?: usersUpsertWithoutNotification_preferencesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotification_preferencesInput, usersUpdateWithoutNotification_preferencesInput>, usersUncheckedUpdateWithoutNotification_preferencesInput>
  }

  export type usersCreateNestedOneWithoutNotification_usersInput = {
    create?: XOR<usersCreateWithoutNotification_usersInput, usersUncheckedCreateWithoutNotification_usersInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotification_usersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNotification_usersNestedInput = {
    create?: XOR<usersCreateWithoutNotification_usersInput, usersUncheckedCreateWithoutNotification_usersInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotification_usersInput
    upsert?: usersUpsertWithoutNotification_usersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotification_usersInput, usersUpdateWithoutNotification_usersInput>, usersUncheckedUpdateWithoutNotification_usersInput>
  }

  export type operatorsCreateNestedOneWithoutNotifications_operatorInput = {
    create?: XOR<operatorsCreateWithoutNotifications_operatorInput, operatorsUncheckedCreateWithoutNotifications_operatorInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutNotifications_operatorInput
    connect?: operatorsWhereUniqueInput
  }

  export type operatorsUpdateOneRequiredWithoutNotifications_operatorNestedInput = {
    create?: XOR<operatorsCreateWithoutNotifications_operatorInput, operatorsUncheckedCreateWithoutNotifications_operatorInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutNotifications_operatorInput
    upsert?: operatorsUpsertWithoutNotifications_operatorInput
    connect?: operatorsWhereUniqueInput
    update?: XOR<XOR<operatorsUpdateToOneWithWhereWithoutNotifications_operatorInput, operatorsUpdateWithoutNotifications_operatorInput>, operatorsUncheckedUpdateWithoutNotifications_operatorInput>
  }

  export type operatorsCreateNestedManyWithoutOperator_typesInput = {
    create?: XOR<operatorsCreateWithoutOperator_typesInput, operatorsUncheckedCreateWithoutOperator_typesInput> | operatorsCreateWithoutOperator_typesInput[] | operatorsUncheckedCreateWithoutOperator_typesInput[]
    connectOrCreate?: operatorsCreateOrConnectWithoutOperator_typesInput | operatorsCreateOrConnectWithoutOperator_typesInput[]
    createMany?: operatorsCreateManyOperator_typesInputEnvelope
    connect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
  }

  export type operatorsUncheckedCreateNestedManyWithoutOperator_typesInput = {
    create?: XOR<operatorsCreateWithoutOperator_typesInput, operatorsUncheckedCreateWithoutOperator_typesInput> | operatorsCreateWithoutOperator_typesInput[] | operatorsUncheckedCreateWithoutOperator_typesInput[]
    connectOrCreate?: operatorsCreateOrConnectWithoutOperator_typesInput | operatorsCreateOrConnectWithoutOperator_typesInput[]
    createMany?: operatorsCreateManyOperator_typesInputEnvelope
    connect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
  }

  export type operatorsUpdateManyWithoutOperator_typesNestedInput = {
    create?: XOR<operatorsCreateWithoutOperator_typesInput, operatorsUncheckedCreateWithoutOperator_typesInput> | operatorsCreateWithoutOperator_typesInput[] | operatorsUncheckedCreateWithoutOperator_typesInput[]
    connectOrCreate?: operatorsCreateOrConnectWithoutOperator_typesInput | operatorsCreateOrConnectWithoutOperator_typesInput[]
    upsert?: operatorsUpsertWithWhereUniqueWithoutOperator_typesInput | operatorsUpsertWithWhereUniqueWithoutOperator_typesInput[]
    createMany?: operatorsCreateManyOperator_typesInputEnvelope
    set?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    disconnect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    delete?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    connect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    update?: operatorsUpdateWithWhereUniqueWithoutOperator_typesInput | operatorsUpdateWithWhereUniqueWithoutOperator_typesInput[]
    updateMany?: operatorsUpdateManyWithWhereWithoutOperator_typesInput | operatorsUpdateManyWithWhereWithoutOperator_typesInput[]
    deleteMany?: operatorsScalarWhereInput | operatorsScalarWhereInput[]
  }

  export type operatorsUncheckedUpdateManyWithoutOperator_typesNestedInput = {
    create?: XOR<operatorsCreateWithoutOperator_typesInput, operatorsUncheckedCreateWithoutOperator_typesInput> | operatorsCreateWithoutOperator_typesInput[] | operatorsUncheckedCreateWithoutOperator_typesInput[]
    connectOrCreate?: operatorsCreateOrConnectWithoutOperator_typesInput | operatorsCreateOrConnectWithoutOperator_typesInput[]
    upsert?: operatorsUpsertWithWhereUniqueWithoutOperator_typesInput | operatorsUpsertWithWhereUniqueWithoutOperator_typesInput[]
    createMany?: operatorsCreateManyOperator_typesInputEnvelope
    set?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    disconnect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    delete?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    connect?: operatorsWhereUniqueInput | operatorsWhereUniqueInput[]
    update?: operatorsUpdateWithWhereUniqueWithoutOperator_typesInput | operatorsUpdateWithWhereUniqueWithoutOperator_typesInput[]
    updateMany?: operatorsUpdateManyWithWhereWithoutOperator_typesInput | operatorsUpdateManyWithWhereWithoutOperator_typesInput[]
    deleteMany?: operatorsScalarWhereInput | operatorsScalarWhereInput[]
  }

  export type operatorsCreateskillsInput = {
    set: string[]
  }

  export type activitiesCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<activitiesCreateWithoutOperatorsInput, activitiesUncheckedCreateWithoutOperatorsInput> | activitiesCreateWithoutOperatorsInput[] | activitiesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: activitiesCreateOrConnectWithoutOperatorsInput | activitiesCreateOrConnectWithoutOperatorsInput[]
    createMany?: activitiesCreateManyOperatorsInputEnvelope
    connect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
  }

  export type email_templatesCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<email_templatesCreateWithoutOperatorsInput, email_templatesUncheckedCreateWithoutOperatorsInput> | email_templatesCreateWithoutOperatorsInput[] | email_templatesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: email_templatesCreateOrConnectWithoutOperatorsInput | email_templatesCreateOrConnectWithoutOperatorsInput[]
    createMany?: email_templatesCreateManyOperatorsInputEnvelope
    connect?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
  }

  export type invoicesCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<invoicesCreateWithoutOperatorsInput, invoicesUncheckedCreateWithoutOperatorsInput> | invoicesCreateWithoutOperatorsInput[] | invoicesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutOperatorsInput | invoicesCreateOrConnectWithoutOperatorsInput[]
    createMany?: invoicesCreateManyOperatorsInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type notifications_operatorCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<notifications_operatorCreateWithoutOperatorsInput, notifications_operatorUncheckedCreateWithoutOperatorsInput> | notifications_operatorCreateWithoutOperatorsInput[] | notifications_operatorUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: notifications_operatorCreateOrConnectWithoutOperatorsInput | notifications_operatorCreateOrConnectWithoutOperatorsInput[]
    createMany?: notifications_operatorCreateManyOperatorsInputEnvelope
    connect?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
  }

  export type branchesCreateNestedOneWithoutOperatorsInput = {
    create?: XOR<branchesCreateWithoutOperatorsInput, branchesUncheckedCreateWithoutOperatorsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutOperatorsInput
    connect?: branchesWhereUniqueInput
  }

  export type operator_typesCreateNestedOneWithoutOperatorsInput = {
    create?: XOR<operator_typesCreateWithoutOperatorsInput, operator_typesUncheckedCreateWithoutOperatorsInput>
    connectOrCreate?: operator_typesCreateOrConnectWithoutOperatorsInput
    connect?: operator_typesWhereUniqueInput
  }

  export type packagesCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<packagesCreateWithoutOperatorsInput, packagesUncheckedCreateWithoutOperatorsInput> | packagesCreateWithoutOperatorsInput[] | packagesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutOperatorsInput | packagesCreateOrConnectWithoutOperatorsInput[]
    createMany?: packagesCreateManyOperatorsInputEnvelope
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
  }

  export type activitiesUncheckedCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<activitiesCreateWithoutOperatorsInput, activitiesUncheckedCreateWithoutOperatorsInput> | activitiesCreateWithoutOperatorsInput[] | activitiesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: activitiesCreateOrConnectWithoutOperatorsInput | activitiesCreateOrConnectWithoutOperatorsInput[]
    createMany?: activitiesCreateManyOperatorsInputEnvelope
    connect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
  }

  export type email_templatesUncheckedCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<email_templatesCreateWithoutOperatorsInput, email_templatesUncheckedCreateWithoutOperatorsInput> | email_templatesCreateWithoutOperatorsInput[] | email_templatesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: email_templatesCreateOrConnectWithoutOperatorsInput | email_templatesCreateOrConnectWithoutOperatorsInput[]
    createMany?: email_templatesCreateManyOperatorsInputEnvelope
    connect?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
  }

  export type invoicesUncheckedCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<invoicesCreateWithoutOperatorsInput, invoicesUncheckedCreateWithoutOperatorsInput> | invoicesCreateWithoutOperatorsInput[] | invoicesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutOperatorsInput | invoicesCreateOrConnectWithoutOperatorsInput[]
    createMany?: invoicesCreateManyOperatorsInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type notifications_operatorUncheckedCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<notifications_operatorCreateWithoutOperatorsInput, notifications_operatorUncheckedCreateWithoutOperatorsInput> | notifications_operatorCreateWithoutOperatorsInput[] | notifications_operatorUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: notifications_operatorCreateOrConnectWithoutOperatorsInput | notifications_operatorCreateOrConnectWithoutOperatorsInput[]
    createMany?: notifications_operatorCreateManyOperatorsInputEnvelope
    connect?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
  }

  export type packagesUncheckedCreateNestedManyWithoutOperatorsInput = {
    create?: XOR<packagesCreateWithoutOperatorsInput, packagesUncheckedCreateWithoutOperatorsInput> | packagesCreateWithoutOperatorsInput[] | packagesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutOperatorsInput | packagesCreateOrConnectWithoutOperatorsInput[]
    createMany?: packagesCreateManyOperatorsInputEnvelope
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
  }

  export type Enumoperator_role_enumFieldUpdateOperationsInput = {
    set?: $Enums.operator_role_enum
  }

  export type Enumoperator_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.operator_status_enum
  }

  export type operatorsUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type activitiesUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<activitiesCreateWithoutOperatorsInput, activitiesUncheckedCreateWithoutOperatorsInput> | activitiesCreateWithoutOperatorsInput[] | activitiesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: activitiesCreateOrConnectWithoutOperatorsInput | activitiesCreateOrConnectWithoutOperatorsInput[]
    upsert?: activitiesUpsertWithWhereUniqueWithoutOperatorsInput | activitiesUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: activitiesCreateManyOperatorsInputEnvelope
    set?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    disconnect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    delete?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    connect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    update?: activitiesUpdateWithWhereUniqueWithoutOperatorsInput | activitiesUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: activitiesUpdateManyWithWhereWithoutOperatorsInput | activitiesUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: activitiesScalarWhereInput | activitiesScalarWhereInput[]
  }

  export type email_templatesUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<email_templatesCreateWithoutOperatorsInput, email_templatesUncheckedCreateWithoutOperatorsInput> | email_templatesCreateWithoutOperatorsInput[] | email_templatesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: email_templatesCreateOrConnectWithoutOperatorsInput | email_templatesCreateOrConnectWithoutOperatorsInput[]
    upsert?: email_templatesUpsertWithWhereUniqueWithoutOperatorsInput | email_templatesUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: email_templatesCreateManyOperatorsInputEnvelope
    set?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
    disconnect?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
    delete?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
    connect?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
    update?: email_templatesUpdateWithWhereUniqueWithoutOperatorsInput | email_templatesUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: email_templatesUpdateManyWithWhereWithoutOperatorsInput | email_templatesUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: email_templatesScalarWhereInput | email_templatesScalarWhereInput[]
  }

  export type invoicesUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<invoicesCreateWithoutOperatorsInput, invoicesUncheckedCreateWithoutOperatorsInput> | invoicesCreateWithoutOperatorsInput[] | invoicesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutOperatorsInput | invoicesCreateOrConnectWithoutOperatorsInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutOperatorsInput | invoicesUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: invoicesCreateManyOperatorsInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutOperatorsInput | invoicesUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutOperatorsInput | invoicesUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type notifications_operatorUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<notifications_operatorCreateWithoutOperatorsInput, notifications_operatorUncheckedCreateWithoutOperatorsInput> | notifications_operatorCreateWithoutOperatorsInput[] | notifications_operatorUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: notifications_operatorCreateOrConnectWithoutOperatorsInput | notifications_operatorCreateOrConnectWithoutOperatorsInput[]
    upsert?: notifications_operatorUpsertWithWhereUniqueWithoutOperatorsInput | notifications_operatorUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: notifications_operatorCreateManyOperatorsInputEnvelope
    set?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
    disconnect?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
    delete?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
    connect?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
    update?: notifications_operatorUpdateWithWhereUniqueWithoutOperatorsInput | notifications_operatorUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: notifications_operatorUpdateManyWithWhereWithoutOperatorsInput | notifications_operatorUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: notifications_operatorScalarWhereInput | notifications_operatorScalarWhereInput[]
  }

  export type branchesUpdateOneRequiredWithoutOperatorsNestedInput = {
    create?: XOR<branchesCreateWithoutOperatorsInput, branchesUncheckedCreateWithoutOperatorsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutOperatorsInput
    upsert?: branchesUpsertWithoutOperatorsInput
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutOperatorsInput, branchesUpdateWithoutOperatorsInput>, branchesUncheckedUpdateWithoutOperatorsInput>
  }

  export type operator_typesUpdateOneRequiredWithoutOperatorsNestedInput = {
    create?: XOR<operator_typesCreateWithoutOperatorsInput, operator_typesUncheckedCreateWithoutOperatorsInput>
    connectOrCreate?: operator_typesCreateOrConnectWithoutOperatorsInput
    upsert?: operator_typesUpsertWithoutOperatorsInput
    connect?: operator_typesWhereUniqueInput
    update?: XOR<XOR<operator_typesUpdateToOneWithWhereWithoutOperatorsInput, operator_typesUpdateWithoutOperatorsInput>, operator_typesUncheckedUpdateWithoutOperatorsInput>
  }

  export type packagesUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<packagesCreateWithoutOperatorsInput, packagesUncheckedCreateWithoutOperatorsInput> | packagesCreateWithoutOperatorsInput[] | packagesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutOperatorsInput | packagesCreateOrConnectWithoutOperatorsInput[]
    upsert?: packagesUpsertWithWhereUniqueWithoutOperatorsInput | packagesUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: packagesCreateManyOperatorsInputEnvelope
    set?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    disconnect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    delete?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    update?: packagesUpdateWithWhereUniqueWithoutOperatorsInput | packagesUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: packagesUpdateManyWithWhereWithoutOperatorsInput | packagesUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: packagesScalarWhereInput | packagesScalarWhereInput[]
  }

  export type activitiesUncheckedUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<activitiesCreateWithoutOperatorsInput, activitiesUncheckedCreateWithoutOperatorsInput> | activitiesCreateWithoutOperatorsInput[] | activitiesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: activitiesCreateOrConnectWithoutOperatorsInput | activitiesCreateOrConnectWithoutOperatorsInput[]
    upsert?: activitiesUpsertWithWhereUniqueWithoutOperatorsInput | activitiesUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: activitiesCreateManyOperatorsInputEnvelope
    set?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    disconnect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    delete?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    connect?: activitiesWhereUniqueInput | activitiesWhereUniqueInput[]
    update?: activitiesUpdateWithWhereUniqueWithoutOperatorsInput | activitiesUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: activitiesUpdateManyWithWhereWithoutOperatorsInput | activitiesUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: activitiesScalarWhereInput | activitiesScalarWhereInput[]
  }

  export type email_templatesUncheckedUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<email_templatesCreateWithoutOperatorsInput, email_templatesUncheckedCreateWithoutOperatorsInput> | email_templatesCreateWithoutOperatorsInput[] | email_templatesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: email_templatesCreateOrConnectWithoutOperatorsInput | email_templatesCreateOrConnectWithoutOperatorsInput[]
    upsert?: email_templatesUpsertWithWhereUniqueWithoutOperatorsInput | email_templatesUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: email_templatesCreateManyOperatorsInputEnvelope
    set?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
    disconnect?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
    delete?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
    connect?: email_templatesWhereUniqueInput | email_templatesWhereUniqueInput[]
    update?: email_templatesUpdateWithWhereUniqueWithoutOperatorsInput | email_templatesUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: email_templatesUpdateManyWithWhereWithoutOperatorsInput | email_templatesUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: email_templatesScalarWhereInput | email_templatesScalarWhereInput[]
  }

  export type invoicesUncheckedUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<invoicesCreateWithoutOperatorsInput, invoicesUncheckedCreateWithoutOperatorsInput> | invoicesCreateWithoutOperatorsInput[] | invoicesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutOperatorsInput | invoicesCreateOrConnectWithoutOperatorsInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutOperatorsInput | invoicesUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: invoicesCreateManyOperatorsInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutOperatorsInput | invoicesUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutOperatorsInput | invoicesUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type notifications_operatorUncheckedUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<notifications_operatorCreateWithoutOperatorsInput, notifications_operatorUncheckedCreateWithoutOperatorsInput> | notifications_operatorCreateWithoutOperatorsInput[] | notifications_operatorUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: notifications_operatorCreateOrConnectWithoutOperatorsInput | notifications_operatorCreateOrConnectWithoutOperatorsInput[]
    upsert?: notifications_operatorUpsertWithWhereUniqueWithoutOperatorsInput | notifications_operatorUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: notifications_operatorCreateManyOperatorsInputEnvelope
    set?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
    disconnect?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
    delete?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
    connect?: notifications_operatorWhereUniqueInput | notifications_operatorWhereUniqueInput[]
    update?: notifications_operatorUpdateWithWhereUniqueWithoutOperatorsInput | notifications_operatorUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: notifications_operatorUpdateManyWithWhereWithoutOperatorsInput | notifications_operatorUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: notifications_operatorScalarWhereInput | notifications_operatorScalarWhereInput[]
  }

  export type packagesUncheckedUpdateManyWithoutOperatorsNestedInput = {
    create?: XOR<packagesCreateWithoutOperatorsInput, packagesUncheckedCreateWithoutOperatorsInput> | packagesCreateWithoutOperatorsInput[] | packagesUncheckedCreateWithoutOperatorsInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutOperatorsInput | packagesCreateOrConnectWithoutOperatorsInput[]
    upsert?: packagesUpsertWithWhereUniqueWithoutOperatorsInput | packagesUpsertWithWhereUniqueWithoutOperatorsInput[]
    createMany?: packagesCreateManyOperatorsInputEnvelope
    set?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    disconnect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    delete?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    update?: packagesUpdateWithWhereUniqueWithoutOperatorsInput | packagesUpdateWithWhereUniqueWithoutOperatorsInput[]
    updateMany?: packagesUpdateManyWithWhereWithoutOperatorsInput | packagesUpdateManyWithWhereWithoutOperatorsInput[]
    deleteMany?: packagesScalarWhereInput | packagesScalarWhereInput[]
  }

  export type packagesCreateshipping_stagesInput = {
    set: InputJsonValue[]
  }

  export type invoice_packagesCreateNestedManyWithoutPackagesInput = {
    create?: XOR<invoice_packagesCreateWithoutPackagesInput, invoice_packagesUncheckedCreateWithoutPackagesInput> | invoice_packagesCreateWithoutPackagesInput[] | invoice_packagesUncheckedCreateWithoutPackagesInput[]
    connectOrCreate?: invoice_packagesCreateOrConnectWithoutPackagesInput | invoice_packagesCreateOrConnectWithoutPackagesInput[]
    createMany?: invoice_packagesCreateManyPackagesInputEnvelope
    connect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
  }

  export type branchesCreateNestedOneWithoutPackagesInput = {
    create?: XOR<branchesCreateWithoutPackagesInput, branchesUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutPackagesInput
    connect?: branchesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPackagesInput = {
    create?: XOR<usersCreateWithoutPackagesInput, usersUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutPackagesInput
    connect?: usersWhereUniqueInput
  }

  export type operatorsCreateNestedOneWithoutPackagesInput = {
    create?: XOR<operatorsCreateWithoutPackagesInput, operatorsUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutPackagesInput
    connect?: operatorsWhereUniqueInput
  }

  export type invoice_packagesUncheckedCreateNestedManyWithoutPackagesInput = {
    create?: XOR<invoice_packagesCreateWithoutPackagesInput, invoice_packagesUncheckedCreateWithoutPackagesInput> | invoice_packagesCreateWithoutPackagesInput[] | invoice_packagesUncheckedCreateWithoutPackagesInput[]
    connectOrCreate?: invoice_packagesCreateOrConnectWithoutPackagesInput | invoice_packagesCreateOrConnectWithoutPackagesInput[]
    createMany?: invoice_packagesCreateManyPackagesInputEnvelope
    connect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
  }

  export type Enumpackage_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.package_status_enum
  }

  export type packagesUpdateshipping_stagesInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type invoice_packagesUpdateManyWithoutPackagesNestedInput = {
    create?: XOR<invoice_packagesCreateWithoutPackagesInput, invoice_packagesUncheckedCreateWithoutPackagesInput> | invoice_packagesCreateWithoutPackagesInput[] | invoice_packagesUncheckedCreateWithoutPackagesInput[]
    connectOrCreate?: invoice_packagesCreateOrConnectWithoutPackagesInput | invoice_packagesCreateOrConnectWithoutPackagesInput[]
    upsert?: invoice_packagesUpsertWithWhereUniqueWithoutPackagesInput | invoice_packagesUpsertWithWhereUniqueWithoutPackagesInput[]
    createMany?: invoice_packagesCreateManyPackagesInputEnvelope
    set?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    disconnect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    delete?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    connect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    update?: invoice_packagesUpdateWithWhereUniqueWithoutPackagesInput | invoice_packagesUpdateWithWhereUniqueWithoutPackagesInput[]
    updateMany?: invoice_packagesUpdateManyWithWhereWithoutPackagesInput | invoice_packagesUpdateManyWithWhereWithoutPackagesInput[]
    deleteMany?: invoice_packagesScalarWhereInput | invoice_packagesScalarWhereInput[]
  }

  export type branchesUpdateOneWithoutPackagesNestedInput = {
    create?: XOR<branchesCreateWithoutPackagesInput, branchesUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutPackagesInput
    upsert?: branchesUpsertWithoutPackagesInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutPackagesInput, branchesUpdateWithoutPackagesInput>, branchesUncheckedUpdateWithoutPackagesInput>
  }

  export type usersUpdateOneWithoutPackagesNestedInput = {
    create?: XOR<usersCreateWithoutPackagesInput, usersUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutPackagesInput
    upsert?: usersUpsertWithoutPackagesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPackagesInput, usersUpdateWithoutPackagesInput>, usersUncheckedUpdateWithoutPackagesInput>
  }

  export type operatorsUpdateOneWithoutPackagesNestedInput = {
    create?: XOR<operatorsCreateWithoutPackagesInput, operatorsUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: operatorsCreateOrConnectWithoutPackagesInput
    upsert?: operatorsUpsertWithoutPackagesInput
    disconnect?: operatorsWhereInput | boolean
    delete?: operatorsWhereInput | boolean
    connect?: operatorsWhereUniqueInput
    update?: XOR<XOR<operatorsUpdateToOneWithWhereWithoutPackagesInput, operatorsUpdateWithoutPackagesInput>, operatorsUncheckedUpdateWithoutPackagesInput>
  }

  export type invoice_packagesUncheckedUpdateManyWithoutPackagesNestedInput = {
    create?: XOR<invoice_packagesCreateWithoutPackagesInput, invoice_packagesUncheckedCreateWithoutPackagesInput> | invoice_packagesCreateWithoutPackagesInput[] | invoice_packagesUncheckedCreateWithoutPackagesInput[]
    connectOrCreate?: invoice_packagesCreateOrConnectWithoutPackagesInput | invoice_packagesCreateOrConnectWithoutPackagesInput[]
    upsert?: invoice_packagesUpsertWithWhereUniqueWithoutPackagesInput | invoice_packagesUpsertWithWhereUniqueWithoutPackagesInput[]
    createMany?: invoice_packagesCreateManyPackagesInputEnvelope
    set?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    disconnect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    delete?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    connect?: invoice_packagesWhereUniqueInput | invoice_packagesWhereUniqueInput[]
    update?: invoice_packagesUpdateWithWhereUniqueWithoutPackagesInput | invoice_packagesUpdateWithWhereUniqueWithoutPackagesInput[]
    updateMany?: invoice_packagesUpdateManyWithWhereWithoutPackagesInput | invoice_packagesUpdateManyWithWhereWithoutPackagesInput[]
    deleteMany?: invoice_packagesScalarWhereInput | invoice_packagesScalarWhereInput[]
  }

  export type payment_methodsCreateNestedManyWithoutPayment_typesInput = {
    create?: XOR<payment_methodsCreateWithoutPayment_typesInput, payment_methodsUncheckedCreateWithoutPayment_typesInput> | payment_methodsCreateWithoutPayment_typesInput[] | payment_methodsUncheckedCreateWithoutPayment_typesInput[]
    connectOrCreate?: payment_methodsCreateOrConnectWithoutPayment_typesInput | payment_methodsCreateOrConnectWithoutPayment_typesInput[]
    createMany?: payment_methodsCreateManyPayment_typesInputEnvelope
    connect?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
  }

  export type payment_methodsUncheckedCreateNestedManyWithoutPayment_typesInput = {
    create?: XOR<payment_methodsCreateWithoutPayment_typesInput, payment_methodsUncheckedCreateWithoutPayment_typesInput> | payment_methodsCreateWithoutPayment_typesInput[] | payment_methodsUncheckedCreateWithoutPayment_typesInput[]
    connectOrCreate?: payment_methodsCreateOrConnectWithoutPayment_typesInput | payment_methodsCreateOrConnectWithoutPayment_typesInput[]
    createMany?: payment_methodsCreateManyPayment_typesInputEnvelope
    connect?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
  }

  export type payment_methodsUpdateManyWithoutPayment_typesNestedInput = {
    create?: XOR<payment_methodsCreateWithoutPayment_typesInput, payment_methodsUncheckedCreateWithoutPayment_typesInput> | payment_methodsCreateWithoutPayment_typesInput[] | payment_methodsUncheckedCreateWithoutPayment_typesInput[]
    connectOrCreate?: payment_methodsCreateOrConnectWithoutPayment_typesInput | payment_methodsCreateOrConnectWithoutPayment_typesInput[]
    upsert?: payment_methodsUpsertWithWhereUniqueWithoutPayment_typesInput | payment_methodsUpsertWithWhereUniqueWithoutPayment_typesInput[]
    createMany?: payment_methodsCreateManyPayment_typesInputEnvelope
    set?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
    disconnect?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
    delete?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
    connect?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
    update?: payment_methodsUpdateWithWhereUniqueWithoutPayment_typesInput | payment_methodsUpdateWithWhereUniqueWithoutPayment_typesInput[]
    updateMany?: payment_methodsUpdateManyWithWhereWithoutPayment_typesInput | payment_methodsUpdateManyWithWhereWithoutPayment_typesInput[]
    deleteMany?: payment_methodsScalarWhereInput | payment_methodsScalarWhereInput[]
  }

  export type payment_methodsUncheckedUpdateManyWithoutPayment_typesNestedInput = {
    create?: XOR<payment_methodsCreateWithoutPayment_typesInput, payment_methodsUncheckedCreateWithoutPayment_typesInput> | payment_methodsCreateWithoutPayment_typesInput[] | payment_methodsUncheckedCreateWithoutPayment_typesInput[]
    connectOrCreate?: payment_methodsCreateOrConnectWithoutPayment_typesInput | payment_methodsCreateOrConnectWithoutPayment_typesInput[]
    upsert?: payment_methodsUpsertWithWhereUniqueWithoutPayment_typesInput | payment_methodsUpsertWithWhereUniqueWithoutPayment_typesInput[]
    createMany?: payment_methodsCreateManyPayment_typesInputEnvelope
    set?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
    disconnect?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
    delete?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
    connect?: payment_methodsWhereUniqueInput | payment_methodsWhereUniqueInput[]
    update?: payment_methodsUpdateWithWhereUniqueWithoutPayment_typesInput | payment_methodsUpdateWithWhereUniqueWithoutPayment_typesInput[]
    updateMany?: payment_methodsUpdateManyWithWhereWithoutPayment_typesInput | payment_methodsUpdateManyWithWhereWithoutPayment_typesInput[]
    deleteMany?: payment_methodsScalarWhereInput | payment_methodsScalarWhereInput[]
  }

  export type payment_methodsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<payment_methodsCreateWithoutPaymentsInput, payment_methodsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: payment_methodsCreateOrConnectWithoutPaymentsInput
    connect?: payment_methodsWhereUniqueInput
  }

  export type invoicesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutPaymentsInput
    connect?: invoicesWhereUniqueInput
  }

  export type transactionsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<transactionsCreateWithoutPaymentsInput, transactionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutPaymentsInput
    connect?: transactionsWhereUniqueInput
  }

  export type Enumpayment_method_enumFieldUpdateOperationsInput = {
    set?: $Enums.payment_method_enum
  }

  export type Enumpayment_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.payment_status_enum
  }

  export type payment_methodsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<payment_methodsCreateWithoutPaymentsInput, payment_methodsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: payment_methodsCreateOrConnectWithoutPaymentsInput
    upsert?: payment_methodsUpsertWithoutPaymentsInput
    disconnect?: payment_methodsWhereInput | boolean
    delete?: payment_methodsWhereInput | boolean
    connect?: payment_methodsWhereUniqueInput
    update?: XOR<XOR<payment_methodsUpdateToOneWithWhereWithoutPaymentsInput, payment_methodsUpdateWithoutPaymentsInput>, payment_methodsUncheckedUpdateWithoutPaymentsInput>
  }

  export type invoicesUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutPaymentsInput
    upsert?: invoicesUpsertWithoutPaymentsInput
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutPaymentsInput, invoicesUpdateWithoutPaymentsInput>, invoicesUncheckedUpdateWithoutPaymentsInput>
  }

  export type transactionsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<transactionsCreateWithoutPaymentsInput, transactionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutPaymentsInput
    upsert?: transactionsUpsertWithoutPaymentsInput
    disconnect?: transactionsWhereInput | boolean
    delete?: transactionsWhereInput | boolean
    connect?: transactionsWhereUniqueInput
    update?: XOR<XOR<transactionsUpdateToOneWithWhereWithoutPaymentsInput, transactionsUpdateWithoutPaymentsInput>, transactionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type plansCreateNestedOneWithoutPlan_addressesInput = {
    create?: XOR<plansCreateWithoutPlan_addressesInput, plansUncheckedCreateWithoutPlan_addressesInput>
    connectOrCreate?: plansCreateOrConnectWithoutPlan_addressesInput
    connect?: plansWhereUniqueInput
  }

  export type plansUpdateOneRequiredWithoutPlan_addressesNestedInput = {
    create?: XOR<plansCreateWithoutPlan_addressesInput, plansUncheckedCreateWithoutPlan_addressesInput>
    connectOrCreate?: plansCreateOrConnectWithoutPlan_addressesInput
    upsert?: plansUpsertWithoutPlan_addressesInput
    connect?: plansWhereUniqueInput
    update?: XOR<XOR<plansUpdateToOneWithWhereWithoutPlan_addressesInput, plansUpdateWithoutPlan_addressesInput>, plansUncheckedUpdateWithoutPlan_addressesInput>
  }

  export type plansCreateNestedOneWithoutPlan_featuresInput = {
    create?: XOR<plansCreateWithoutPlan_featuresInput, plansUncheckedCreateWithoutPlan_featuresInput>
    connectOrCreate?: plansCreateOrConnectWithoutPlan_featuresInput
    connect?: plansWhereUniqueInput
  }

  export type plansUpdateOneRequiredWithoutPlan_featuresNestedInput = {
    create?: XOR<plansCreateWithoutPlan_featuresInput, plansUncheckedCreateWithoutPlan_featuresInput>
    connectOrCreate?: plansCreateOrConnectWithoutPlan_featuresInput
    upsert?: plansUpsertWithoutPlan_featuresInput
    connect?: plansWhereUniqueInput
    update?: XOR<XOR<plansUpdateToOneWithWhereWithoutPlan_featuresInput, plansUpdateWithoutPlan_featuresInput>, plansUncheckedUpdateWithoutPlan_featuresInput>
  }

  export type invoice_itemsCreateNestedManyWithoutPlansInput = {
    create?: XOR<invoice_itemsCreateWithoutPlansInput, invoice_itemsUncheckedCreateWithoutPlansInput> | invoice_itemsCreateWithoutPlansInput[] | invoice_itemsUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutPlansInput | invoice_itemsCreateOrConnectWithoutPlansInput[]
    createMany?: invoice_itemsCreateManyPlansInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type plan_addressesCreateNestedManyWithoutPlansInput = {
    create?: XOR<plan_addressesCreateWithoutPlansInput, plan_addressesUncheckedCreateWithoutPlansInput> | plan_addressesCreateWithoutPlansInput[] | plan_addressesUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: plan_addressesCreateOrConnectWithoutPlansInput | plan_addressesCreateOrConnectWithoutPlansInput[]
    createMany?: plan_addressesCreateManyPlansInputEnvelope
    connect?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
  }

  export type plan_featuresCreateNestedManyWithoutPlansInput = {
    create?: XOR<plan_featuresCreateWithoutPlansInput, plan_featuresUncheckedCreateWithoutPlansInput> | plan_featuresCreateWithoutPlansInput[] | plan_featuresUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: plan_featuresCreateOrConnectWithoutPlansInput | plan_featuresCreateOrConnectWithoutPlansInput[]
    createMany?: plan_featuresCreateManyPlansInputEnvelope
    connect?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
  }

  export type branchesCreateNestedOneWithoutPlansInput = {
    create?: XOR<branchesCreateWithoutPlansInput, branchesUncheckedCreateWithoutPlansInput>
    connectOrCreate?: branchesCreateOrConnectWithoutPlansInput
    connect?: branchesWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutPlansInput = {
    create?: XOR<usersCreateWithoutPlansInput, usersUncheckedCreateWithoutPlansInput> | usersCreateWithoutPlansInput[] | usersUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: usersCreateOrConnectWithoutPlansInput | usersCreateOrConnectWithoutPlansInput[]
    createMany?: usersCreateManyPlansInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type invoice_itemsUncheckedCreateNestedManyWithoutPlansInput = {
    create?: XOR<invoice_itemsCreateWithoutPlansInput, invoice_itemsUncheckedCreateWithoutPlansInput> | invoice_itemsCreateWithoutPlansInput[] | invoice_itemsUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutPlansInput | invoice_itemsCreateOrConnectWithoutPlansInput[]
    createMany?: invoice_itemsCreateManyPlansInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type plan_addressesUncheckedCreateNestedManyWithoutPlansInput = {
    create?: XOR<plan_addressesCreateWithoutPlansInput, plan_addressesUncheckedCreateWithoutPlansInput> | plan_addressesCreateWithoutPlansInput[] | plan_addressesUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: plan_addressesCreateOrConnectWithoutPlansInput | plan_addressesCreateOrConnectWithoutPlansInput[]
    createMany?: plan_addressesCreateManyPlansInputEnvelope
    connect?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
  }

  export type plan_featuresUncheckedCreateNestedManyWithoutPlansInput = {
    create?: XOR<plan_featuresCreateWithoutPlansInput, plan_featuresUncheckedCreateWithoutPlansInput> | plan_featuresCreateWithoutPlansInput[] | plan_featuresUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: plan_featuresCreateOrConnectWithoutPlansInput | plan_featuresCreateOrConnectWithoutPlansInput[]
    createMany?: plan_featuresCreateManyPlansInputEnvelope
    connect?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutPlansInput = {
    create?: XOR<usersCreateWithoutPlansInput, usersUncheckedCreateWithoutPlansInput> | usersCreateWithoutPlansInput[] | usersUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: usersCreateOrConnectWithoutPlansInput | usersCreateOrConnectWithoutPlansInput[]
    createMany?: usersCreateManyPlansInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type invoice_itemsUpdateManyWithoutPlansNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutPlansInput, invoice_itemsUncheckedCreateWithoutPlansInput> | invoice_itemsCreateWithoutPlansInput[] | invoice_itemsUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutPlansInput | invoice_itemsCreateOrConnectWithoutPlansInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutPlansInput | invoice_itemsUpsertWithWhereUniqueWithoutPlansInput[]
    createMany?: invoice_itemsCreateManyPlansInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutPlansInput | invoice_itemsUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutPlansInput | invoice_itemsUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type plan_addressesUpdateManyWithoutPlansNestedInput = {
    create?: XOR<plan_addressesCreateWithoutPlansInput, plan_addressesUncheckedCreateWithoutPlansInput> | plan_addressesCreateWithoutPlansInput[] | plan_addressesUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: plan_addressesCreateOrConnectWithoutPlansInput | plan_addressesCreateOrConnectWithoutPlansInput[]
    upsert?: plan_addressesUpsertWithWhereUniqueWithoutPlansInput | plan_addressesUpsertWithWhereUniqueWithoutPlansInput[]
    createMany?: plan_addressesCreateManyPlansInputEnvelope
    set?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
    disconnect?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
    delete?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
    connect?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
    update?: plan_addressesUpdateWithWhereUniqueWithoutPlansInput | plan_addressesUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: plan_addressesUpdateManyWithWhereWithoutPlansInput | plan_addressesUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: plan_addressesScalarWhereInput | plan_addressesScalarWhereInput[]
  }

  export type plan_featuresUpdateManyWithoutPlansNestedInput = {
    create?: XOR<plan_featuresCreateWithoutPlansInput, plan_featuresUncheckedCreateWithoutPlansInput> | plan_featuresCreateWithoutPlansInput[] | plan_featuresUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: plan_featuresCreateOrConnectWithoutPlansInput | plan_featuresCreateOrConnectWithoutPlansInput[]
    upsert?: plan_featuresUpsertWithWhereUniqueWithoutPlansInput | plan_featuresUpsertWithWhereUniqueWithoutPlansInput[]
    createMany?: plan_featuresCreateManyPlansInputEnvelope
    set?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
    disconnect?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
    delete?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
    connect?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
    update?: plan_featuresUpdateWithWhereUniqueWithoutPlansInput | plan_featuresUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: plan_featuresUpdateManyWithWhereWithoutPlansInput | plan_featuresUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: plan_featuresScalarWhereInput | plan_featuresScalarWhereInput[]
  }

  export type branchesUpdateOneWithoutPlansNestedInput = {
    create?: XOR<branchesCreateWithoutPlansInput, branchesUncheckedCreateWithoutPlansInput>
    connectOrCreate?: branchesCreateOrConnectWithoutPlansInput
    upsert?: branchesUpsertWithoutPlansInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutPlansInput, branchesUpdateWithoutPlansInput>, branchesUncheckedUpdateWithoutPlansInput>
  }

  export type usersUpdateManyWithoutPlansNestedInput = {
    create?: XOR<usersCreateWithoutPlansInput, usersUncheckedCreateWithoutPlansInput> | usersCreateWithoutPlansInput[] | usersUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: usersCreateOrConnectWithoutPlansInput | usersCreateOrConnectWithoutPlansInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutPlansInput | usersUpsertWithWhereUniqueWithoutPlansInput[]
    createMany?: usersCreateManyPlansInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutPlansInput | usersUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: usersUpdateManyWithWhereWithoutPlansInput | usersUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type invoice_itemsUncheckedUpdateManyWithoutPlansNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutPlansInput, invoice_itemsUncheckedCreateWithoutPlansInput> | invoice_itemsCreateWithoutPlansInput[] | invoice_itemsUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutPlansInput | invoice_itemsCreateOrConnectWithoutPlansInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutPlansInput | invoice_itemsUpsertWithWhereUniqueWithoutPlansInput[]
    createMany?: invoice_itemsCreateManyPlansInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutPlansInput | invoice_itemsUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutPlansInput | invoice_itemsUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type plan_addressesUncheckedUpdateManyWithoutPlansNestedInput = {
    create?: XOR<plan_addressesCreateWithoutPlansInput, plan_addressesUncheckedCreateWithoutPlansInput> | plan_addressesCreateWithoutPlansInput[] | plan_addressesUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: plan_addressesCreateOrConnectWithoutPlansInput | plan_addressesCreateOrConnectWithoutPlansInput[]
    upsert?: plan_addressesUpsertWithWhereUniqueWithoutPlansInput | plan_addressesUpsertWithWhereUniqueWithoutPlansInput[]
    createMany?: plan_addressesCreateManyPlansInputEnvelope
    set?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
    disconnect?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
    delete?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
    connect?: plan_addressesWhereUniqueInput | plan_addressesWhereUniqueInput[]
    update?: plan_addressesUpdateWithWhereUniqueWithoutPlansInput | plan_addressesUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: plan_addressesUpdateManyWithWhereWithoutPlansInput | plan_addressesUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: plan_addressesScalarWhereInput | plan_addressesScalarWhereInput[]
  }

  export type plan_featuresUncheckedUpdateManyWithoutPlansNestedInput = {
    create?: XOR<plan_featuresCreateWithoutPlansInput, plan_featuresUncheckedCreateWithoutPlansInput> | plan_featuresCreateWithoutPlansInput[] | plan_featuresUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: plan_featuresCreateOrConnectWithoutPlansInput | plan_featuresCreateOrConnectWithoutPlansInput[]
    upsert?: plan_featuresUpsertWithWhereUniqueWithoutPlansInput | plan_featuresUpsertWithWhereUniqueWithoutPlansInput[]
    createMany?: plan_featuresCreateManyPlansInputEnvelope
    set?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
    disconnect?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
    delete?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
    connect?: plan_featuresWhereUniqueInput | plan_featuresWhereUniqueInput[]
    update?: plan_featuresUpdateWithWhereUniqueWithoutPlansInput | plan_featuresUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: plan_featuresUpdateManyWithWhereWithoutPlansInput | plan_featuresUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: plan_featuresScalarWhereInput | plan_featuresScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutPlansNestedInput = {
    create?: XOR<usersCreateWithoutPlansInput, usersUncheckedCreateWithoutPlansInput> | usersCreateWithoutPlansInput[] | usersUncheckedCreateWithoutPlansInput[]
    connectOrCreate?: usersCreateOrConnectWithoutPlansInput | usersCreateOrConnectWithoutPlansInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutPlansInput | usersUpsertWithWhereUniqueWithoutPlansInput[]
    createMany?: usersCreateManyPlansInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutPlansInput | usersUpdateWithWhereUniqueWithoutPlansInput[]
    updateMany?: usersUpdateManyWithWhereWithoutPlansInput | usersUpdateManyWithWhereWithoutPlansInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type productsCreateimagesInput = {
    set: string[]
  }

  export type productsCreatetagsInput = {
    set: string[]
  }

  export type invoice_itemsCreateNestedManyWithoutProductsInput = {
    create?: XOR<invoice_itemsCreateWithoutProductsInput, invoice_itemsUncheckedCreateWithoutProductsInput> | invoice_itemsCreateWithoutProductsInput[] | invoice_itemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutProductsInput | invoice_itemsCreateOrConnectWithoutProductsInput[]
    createMany?: invoice_itemsCreateManyProductsInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type branchesCreateNestedOneWithoutProductsInput = {
    create?: XOR<branchesCreateWithoutProductsInput, branchesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutProductsInput
    connect?: branchesWhereUniqueInput
  }

  export type categoriesCreateNestedOneWithoutProductsInput = {
    create?: XOR<categoriesCreateWithoutProductsInput, categoriesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutProductsInput
    connect?: categoriesWhereUniqueInput
  }

  export type invoice_itemsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<invoice_itemsCreateWithoutProductsInput, invoice_itemsUncheckedCreateWithoutProductsInput> | invoice_itemsCreateWithoutProductsInput[] | invoice_itemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutProductsInput | invoice_itemsCreateOrConnectWithoutProductsInput[]
    createMany?: invoice_itemsCreateManyProductsInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type NullableEnumproduct_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.product_status_enum | null
  }

  export type productsUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type productsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type invoice_itemsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutProductsInput, invoice_itemsUncheckedCreateWithoutProductsInput> | invoice_itemsCreateWithoutProductsInput[] | invoice_itemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutProductsInput | invoice_itemsCreateOrConnectWithoutProductsInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutProductsInput | invoice_itemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: invoice_itemsCreateManyProductsInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutProductsInput | invoice_itemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutProductsInput | invoice_itemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type branchesUpdateOneWithoutProductsNestedInput = {
    create?: XOR<branchesCreateWithoutProductsInput, branchesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutProductsInput
    upsert?: branchesUpsertWithoutProductsInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutProductsInput, branchesUpdateWithoutProductsInput>, branchesUncheckedUpdateWithoutProductsInput>
  }

  export type categoriesUpdateOneWithoutProductsNestedInput = {
    create?: XOR<categoriesCreateWithoutProductsInput, categoriesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutProductsInput
    upsert?: categoriesUpsertWithoutProductsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutProductsInput, categoriesUpdateWithoutProductsInput>, categoriesUncheckedUpdateWithoutProductsInput>
  }

  export type invoice_itemsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutProductsInput, invoice_itemsUncheckedCreateWithoutProductsInput> | invoice_itemsCreateWithoutProductsInput[] | invoice_itemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutProductsInput | invoice_itemsCreateOrConnectWithoutProductsInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutProductsInput | invoice_itemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: invoice_itemsCreateManyProductsInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutProductsInput | invoice_itemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutProductsInput | invoice_itemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type usersCreateNestedManyWithoutType_usersInput = {
    create?: XOR<usersCreateWithoutType_usersInput, usersUncheckedCreateWithoutType_usersInput> | usersCreateWithoutType_usersInput[] | usersUncheckedCreateWithoutType_usersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutType_usersInput | usersCreateOrConnectWithoutType_usersInput[]
    createMany?: usersCreateManyType_usersInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutType_usersInput = {
    create?: XOR<usersCreateWithoutType_usersInput, usersUncheckedCreateWithoutType_usersInput> | usersCreateWithoutType_usersInput[] | usersUncheckedCreateWithoutType_usersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutType_usersInput | usersCreateOrConnectWithoutType_usersInput[]
    createMany?: usersCreateManyType_usersInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutType_usersNestedInput = {
    create?: XOR<usersCreateWithoutType_usersInput, usersUncheckedCreateWithoutType_usersInput> | usersCreateWithoutType_usersInput[] | usersUncheckedCreateWithoutType_usersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutType_usersInput | usersCreateOrConnectWithoutType_usersInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutType_usersInput | usersUpsertWithWhereUniqueWithoutType_usersInput[]
    createMany?: usersCreateManyType_usersInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutType_usersInput | usersUpdateWithWhereUniqueWithoutType_usersInput[]
    updateMany?: usersUpdateManyWithWhereWithoutType_usersInput | usersUpdateManyWithWhereWithoutType_usersInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutType_usersNestedInput = {
    create?: XOR<usersCreateWithoutType_usersInput, usersUncheckedCreateWithoutType_usersInput> | usersCreateWithoutType_usersInput[] | usersUncheckedCreateWithoutType_usersInput[]
    connectOrCreate?: usersCreateOrConnectWithoutType_usersInput | usersCreateOrConnectWithoutType_usersInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutType_usersInput | usersUpsertWithWhereUniqueWithoutType_usersInput[]
    createMany?: usersCreateManyType_usersInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutType_usersInput | usersUpdateWithWhereUniqueWithoutType_usersInput[]
    updateMany?: usersUpdateManyWithWhereWithoutType_usersInput | usersUpdateManyWithWhereWithoutType_usersInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type email_campaignsCreateNestedManyWithoutUsersInput = {
    create?: XOR<email_campaignsCreateWithoutUsersInput, email_campaignsUncheckedCreateWithoutUsersInput> | email_campaignsCreateWithoutUsersInput[] | email_campaignsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: email_campaignsCreateOrConnectWithoutUsersInput | email_campaignsCreateOrConnectWithoutUsersInput[]
    createMany?: email_campaignsCreateManyUsersInputEnvelope
    connect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
  }

  export type invoicesCreateNestedManyWithoutUsersInput = {
    create?: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput> | invoicesCreateWithoutUsersInput[] | invoicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutUsersInput | invoicesCreateOrConnectWithoutUsersInput[]
    createMany?: invoicesCreateManyUsersInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type notification_preferencesCreateNestedManyWithoutUsersInput = {
    create?: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput> | notification_preferencesCreateWithoutUsersInput[] | notification_preferencesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_preferencesCreateOrConnectWithoutUsersInput | notification_preferencesCreateOrConnectWithoutUsersInput[]
    createMany?: notification_preferencesCreateManyUsersInputEnvelope
    connect?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
  }

  export type notification_usersCreateNestedManyWithoutUsersInput = {
    create?: XOR<notification_usersCreateWithoutUsersInput, notification_usersUncheckedCreateWithoutUsersInput> | notification_usersCreateWithoutUsersInput[] | notification_usersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_usersCreateOrConnectWithoutUsersInput | notification_usersCreateOrConnectWithoutUsersInput[]
    createMany?: notification_usersCreateManyUsersInputEnvelope
    connect?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
  }

  export type packagesCreateNestedManyWithoutUsersInput = {
    create?: XOR<packagesCreateWithoutUsersInput, packagesUncheckedCreateWithoutUsersInput> | packagesCreateWithoutUsersInput[] | packagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutUsersInput | packagesCreateOrConnectWithoutUsersInput[]
    createMany?: packagesCreateManyUsersInputEnvelope
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
  }

  export type saved_cardsCreateNestedManyWithoutUsersInput = {
    create?: XOR<saved_cardsCreateWithoutUsersInput, saved_cardsUncheckedCreateWithoutUsersInput> | saved_cardsCreateWithoutUsersInput[] | saved_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: saved_cardsCreateOrConnectWithoutUsersInput | saved_cardsCreateOrConnectWithoutUsersInput[]
    createMany?: saved_cardsCreateManyUsersInputEnvelope
    connect?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
  }

  export type branchesCreateNestedOneWithoutUsersInput = {
    create?: XOR<branchesCreateWithoutUsersInput, branchesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: branchesCreateOrConnectWithoutUsersInput
    connect?: branchesWhereUniqueInput
  }

  export type plansCreateNestedOneWithoutUsersInput = {
    create?: XOR<plansCreateWithoutUsersInput, plansUncheckedCreateWithoutUsersInput>
    connectOrCreate?: plansCreateOrConnectWithoutUsersInput
    connect?: plansWhereUniqueInput
  }

  export type referral_sourcesCreateNestedOneWithoutUsersInput = {
    create?: XOR<referral_sourcesCreateWithoutUsersInput, referral_sourcesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: referral_sourcesCreateOrConnectWithoutUsersInput
    connect?: referral_sourcesWhereUniqueInput
  }

  export type type_usersCreateNestedOneWithoutUsersInput = {
    create?: XOR<type_usersCreateWithoutUsersInput, type_usersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: type_usersCreateOrConnectWithoutUsersInput
    connect?: type_usersWhereUniqueInput
  }

  export type walletsCreateNestedManyWithoutUsersInput = {
    create?: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput> | walletsCreateWithoutUsersInput[] | walletsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: walletsCreateOrConnectWithoutUsersInput | walletsCreateOrConnectWithoutUsersInput[]
    createMany?: walletsCreateManyUsersInputEnvelope
    connect?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
  }

  export type email_campaignsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<email_campaignsCreateWithoutUsersInput, email_campaignsUncheckedCreateWithoutUsersInput> | email_campaignsCreateWithoutUsersInput[] | email_campaignsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: email_campaignsCreateOrConnectWithoutUsersInput | email_campaignsCreateOrConnectWithoutUsersInput[]
    createMany?: email_campaignsCreateManyUsersInputEnvelope
    connect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
  }

  export type invoicesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput> | invoicesCreateWithoutUsersInput[] | invoicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutUsersInput | invoicesCreateOrConnectWithoutUsersInput[]
    createMany?: invoicesCreateManyUsersInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type notification_preferencesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput> | notification_preferencesCreateWithoutUsersInput[] | notification_preferencesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_preferencesCreateOrConnectWithoutUsersInput | notification_preferencesCreateOrConnectWithoutUsersInput[]
    createMany?: notification_preferencesCreateManyUsersInputEnvelope
    connect?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
  }

  export type notification_usersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notification_usersCreateWithoutUsersInput, notification_usersUncheckedCreateWithoutUsersInput> | notification_usersCreateWithoutUsersInput[] | notification_usersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_usersCreateOrConnectWithoutUsersInput | notification_usersCreateOrConnectWithoutUsersInput[]
    createMany?: notification_usersCreateManyUsersInputEnvelope
    connect?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
  }

  export type packagesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<packagesCreateWithoutUsersInput, packagesUncheckedCreateWithoutUsersInput> | packagesCreateWithoutUsersInput[] | packagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutUsersInput | packagesCreateOrConnectWithoutUsersInput[]
    createMany?: packagesCreateManyUsersInputEnvelope
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
  }

  export type saved_cardsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<saved_cardsCreateWithoutUsersInput, saved_cardsUncheckedCreateWithoutUsersInput> | saved_cardsCreateWithoutUsersInput[] | saved_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: saved_cardsCreateOrConnectWithoutUsersInput | saved_cardsCreateOrConnectWithoutUsersInput[]
    createMany?: saved_cardsCreateManyUsersInputEnvelope
    connect?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
  }

  export type walletsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput> | walletsCreateWithoutUsersInput[] | walletsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: walletsCreateOrConnectWithoutUsersInput | walletsCreateOrConnectWithoutUsersInput[]
    createMany?: walletsCreateManyUsersInputEnvelope
    connect?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
  }

  export type email_campaignsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<email_campaignsCreateWithoutUsersInput, email_campaignsUncheckedCreateWithoutUsersInput> | email_campaignsCreateWithoutUsersInput[] | email_campaignsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: email_campaignsCreateOrConnectWithoutUsersInput | email_campaignsCreateOrConnectWithoutUsersInput[]
    upsert?: email_campaignsUpsertWithWhereUniqueWithoutUsersInput | email_campaignsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: email_campaignsCreateManyUsersInputEnvelope
    set?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    disconnect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    delete?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    connect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    update?: email_campaignsUpdateWithWhereUniqueWithoutUsersInput | email_campaignsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: email_campaignsUpdateManyWithWhereWithoutUsersInput | email_campaignsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: email_campaignsScalarWhereInput | email_campaignsScalarWhereInput[]
  }

  export type invoicesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput> | invoicesCreateWithoutUsersInput[] | invoicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutUsersInput | invoicesCreateOrConnectWithoutUsersInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutUsersInput | invoicesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: invoicesCreateManyUsersInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutUsersInput | invoicesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutUsersInput | invoicesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type notification_preferencesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput> | notification_preferencesCreateWithoutUsersInput[] | notification_preferencesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_preferencesCreateOrConnectWithoutUsersInput | notification_preferencesCreateOrConnectWithoutUsersInput[]
    upsert?: notification_preferencesUpsertWithWhereUniqueWithoutUsersInput | notification_preferencesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notification_preferencesCreateManyUsersInputEnvelope
    set?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
    disconnect?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
    delete?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
    connect?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
    update?: notification_preferencesUpdateWithWhereUniqueWithoutUsersInput | notification_preferencesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notification_preferencesUpdateManyWithWhereWithoutUsersInput | notification_preferencesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notification_preferencesScalarWhereInput | notification_preferencesScalarWhereInput[]
  }

  export type notification_usersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notification_usersCreateWithoutUsersInput, notification_usersUncheckedCreateWithoutUsersInput> | notification_usersCreateWithoutUsersInput[] | notification_usersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_usersCreateOrConnectWithoutUsersInput | notification_usersCreateOrConnectWithoutUsersInput[]
    upsert?: notification_usersUpsertWithWhereUniqueWithoutUsersInput | notification_usersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notification_usersCreateManyUsersInputEnvelope
    set?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
    disconnect?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
    delete?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
    connect?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
    update?: notification_usersUpdateWithWhereUniqueWithoutUsersInput | notification_usersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notification_usersUpdateManyWithWhereWithoutUsersInput | notification_usersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notification_usersScalarWhereInput | notification_usersScalarWhereInput[]
  }

  export type packagesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<packagesCreateWithoutUsersInput, packagesUncheckedCreateWithoutUsersInput> | packagesCreateWithoutUsersInput[] | packagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutUsersInput | packagesCreateOrConnectWithoutUsersInput[]
    upsert?: packagesUpsertWithWhereUniqueWithoutUsersInput | packagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: packagesCreateManyUsersInputEnvelope
    set?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    disconnect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    delete?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    update?: packagesUpdateWithWhereUniqueWithoutUsersInput | packagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: packagesUpdateManyWithWhereWithoutUsersInput | packagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: packagesScalarWhereInput | packagesScalarWhereInput[]
  }

  export type saved_cardsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<saved_cardsCreateWithoutUsersInput, saved_cardsUncheckedCreateWithoutUsersInput> | saved_cardsCreateWithoutUsersInput[] | saved_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: saved_cardsCreateOrConnectWithoutUsersInput | saved_cardsCreateOrConnectWithoutUsersInput[]
    upsert?: saved_cardsUpsertWithWhereUniqueWithoutUsersInput | saved_cardsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: saved_cardsCreateManyUsersInputEnvelope
    set?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
    disconnect?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
    delete?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
    connect?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
    update?: saved_cardsUpdateWithWhereUniqueWithoutUsersInput | saved_cardsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: saved_cardsUpdateManyWithWhereWithoutUsersInput | saved_cardsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: saved_cardsScalarWhereInput | saved_cardsScalarWhereInput[]
  }

  export type branchesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<branchesCreateWithoutUsersInput, branchesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: branchesCreateOrConnectWithoutUsersInput
    upsert?: branchesUpsertWithoutUsersInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutUsersInput, branchesUpdateWithoutUsersInput>, branchesUncheckedUpdateWithoutUsersInput>
  }

  export type plansUpdateOneWithoutUsersNestedInput = {
    create?: XOR<plansCreateWithoutUsersInput, plansUncheckedCreateWithoutUsersInput>
    connectOrCreate?: plansCreateOrConnectWithoutUsersInput
    upsert?: plansUpsertWithoutUsersInput
    disconnect?: plansWhereInput | boolean
    delete?: plansWhereInput | boolean
    connect?: plansWhereUniqueInput
    update?: XOR<XOR<plansUpdateToOneWithWhereWithoutUsersInput, plansUpdateWithoutUsersInput>, plansUncheckedUpdateWithoutUsersInput>
  }

  export type referral_sourcesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<referral_sourcesCreateWithoutUsersInput, referral_sourcesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: referral_sourcesCreateOrConnectWithoutUsersInput
    upsert?: referral_sourcesUpsertWithoutUsersInput
    disconnect?: referral_sourcesWhereInput | boolean
    delete?: referral_sourcesWhereInput | boolean
    connect?: referral_sourcesWhereUniqueInput
    update?: XOR<XOR<referral_sourcesUpdateToOneWithWhereWithoutUsersInput, referral_sourcesUpdateWithoutUsersInput>, referral_sourcesUncheckedUpdateWithoutUsersInput>
  }

  export type type_usersUpdateOneWithoutUsersNestedInput = {
    create?: XOR<type_usersCreateWithoutUsersInput, type_usersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: type_usersCreateOrConnectWithoutUsersInput
    upsert?: type_usersUpsertWithoutUsersInput
    disconnect?: type_usersWhereInput | boolean
    delete?: type_usersWhereInput | boolean
    connect?: type_usersWhereUniqueInput
    update?: XOR<XOR<type_usersUpdateToOneWithWhereWithoutUsersInput, type_usersUpdateWithoutUsersInput>, type_usersUncheckedUpdateWithoutUsersInput>
  }

  export type walletsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput> | walletsCreateWithoutUsersInput[] | walletsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: walletsCreateOrConnectWithoutUsersInput | walletsCreateOrConnectWithoutUsersInput[]
    upsert?: walletsUpsertWithWhereUniqueWithoutUsersInput | walletsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: walletsCreateManyUsersInputEnvelope
    set?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
    disconnect?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
    delete?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
    connect?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
    update?: walletsUpdateWithWhereUniqueWithoutUsersInput | walletsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: walletsUpdateManyWithWhereWithoutUsersInput | walletsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: walletsScalarWhereInput | walletsScalarWhereInput[]
  }

  export type email_campaignsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<email_campaignsCreateWithoutUsersInput, email_campaignsUncheckedCreateWithoutUsersInput> | email_campaignsCreateWithoutUsersInput[] | email_campaignsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: email_campaignsCreateOrConnectWithoutUsersInput | email_campaignsCreateOrConnectWithoutUsersInput[]
    upsert?: email_campaignsUpsertWithWhereUniqueWithoutUsersInput | email_campaignsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: email_campaignsCreateManyUsersInputEnvelope
    set?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    disconnect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    delete?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    connect?: email_campaignsWhereUniqueInput | email_campaignsWhereUniqueInput[]
    update?: email_campaignsUpdateWithWhereUniqueWithoutUsersInput | email_campaignsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: email_campaignsUpdateManyWithWhereWithoutUsersInput | email_campaignsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: email_campaignsScalarWhereInput | email_campaignsScalarWhereInput[]
  }

  export type invoicesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput> | invoicesCreateWithoutUsersInput[] | invoicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutUsersInput | invoicesCreateOrConnectWithoutUsersInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutUsersInput | invoicesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: invoicesCreateManyUsersInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutUsersInput | invoicesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutUsersInput | invoicesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput> | notification_preferencesCreateWithoutUsersInput[] | notification_preferencesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_preferencesCreateOrConnectWithoutUsersInput | notification_preferencesCreateOrConnectWithoutUsersInput[]
    upsert?: notification_preferencesUpsertWithWhereUniqueWithoutUsersInput | notification_preferencesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notification_preferencesCreateManyUsersInputEnvelope
    set?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
    disconnect?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
    delete?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
    connect?: notification_preferencesWhereUniqueInput | notification_preferencesWhereUniqueInput[]
    update?: notification_preferencesUpdateWithWhereUniqueWithoutUsersInput | notification_preferencesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notification_preferencesUpdateManyWithWhereWithoutUsersInput | notification_preferencesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notification_preferencesScalarWhereInput | notification_preferencesScalarWhereInput[]
  }

  export type notification_usersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notification_usersCreateWithoutUsersInput, notification_usersUncheckedCreateWithoutUsersInput> | notification_usersCreateWithoutUsersInput[] | notification_usersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_usersCreateOrConnectWithoutUsersInput | notification_usersCreateOrConnectWithoutUsersInput[]
    upsert?: notification_usersUpsertWithWhereUniqueWithoutUsersInput | notification_usersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notification_usersCreateManyUsersInputEnvelope
    set?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
    disconnect?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
    delete?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
    connect?: notification_usersWhereUniqueInput | notification_usersWhereUniqueInput[]
    update?: notification_usersUpdateWithWhereUniqueWithoutUsersInput | notification_usersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notification_usersUpdateManyWithWhereWithoutUsersInput | notification_usersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notification_usersScalarWhereInput | notification_usersScalarWhereInput[]
  }

  export type packagesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<packagesCreateWithoutUsersInput, packagesUncheckedCreateWithoutUsersInput> | packagesCreateWithoutUsersInput[] | packagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutUsersInput | packagesCreateOrConnectWithoutUsersInput[]
    upsert?: packagesUpsertWithWhereUniqueWithoutUsersInput | packagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: packagesCreateManyUsersInputEnvelope
    set?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    disconnect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    delete?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    update?: packagesUpdateWithWhereUniqueWithoutUsersInput | packagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: packagesUpdateManyWithWhereWithoutUsersInput | packagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: packagesScalarWhereInput | packagesScalarWhereInput[]
  }

  export type saved_cardsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<saved_cardsCreateWithoutUsersInput, saved_cardsUncheckedCreateWithoutUsersInput> | saved_cardsCreateWithoutUsersInput[] | saved_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: saved_cardsCreateOrConnectWithoutUsersInput | saved_cardsCreateOrConnectWithoutUsersInput[]
    upsert?: saved_cardsUpsertWithWhereUniqueWithoutUsersInput | saved_cardsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: saved_cardsCreateManyUsersInputEnvelope
    set?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
    disconnect?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
    delete?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
    connect?: saved_cardsWhereUniqueInput | saved_cardsWhereUniqueInput[]
    update?: saved_cardsUpdateWithWhereUniqueWithoutUsersInput | saved_cardsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: saved_cardsUpdateManyWithWhereWithoutUsersInput | saved_cardsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: saved_cardsScalarWhereInput | saved_cardsScalarWhereInput[]
  }

  export type walletsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput> | walletsCreateWithoutUsersInput[] | walletsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: walletsCreateOrConnectWithoutUsersInput | walletsCreateOrConnectWithoutUsersInput[]
    upsert?: walletsUpsertWithWhereUniqueWithoutUsersInput | walletsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: walletsCreateManyUsersInputEnvelope
    set?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
    disconnect?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
    delete?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
    connect?: walletsWhereUniqueInput | walletsWhereUniqueInput[]
    update?: walletsUpdateWithWhereUniqueWithoutUsersInput | walletsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: walletsUpdateManyWithWhereWithoutUsersInput | walletsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: walletsScalarWhereInput | walletsScalarWhereInput[]
  }

  export type branchesCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<branchesCreateWithoutVehiclesInput, branchesUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutVehiclesInput
    connect?: branchesWhereUniqueInput
  }

  export type branchesUpdateOneWithoutVehiclesNestedInput = {
    create?: XOR<branchesCreateWithoutVehiclesInput, branchesUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutVehiclesInput
    upsert?: branchesUpsertWithoutVehiclesInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutVehiclesInput, branchesUpdateWithoutVehiclesInput>, branchesUncheckedUpdateWithoutVehiclesInput>
  }

  export type usersCreateNestedOneWithoutWalletsInput = {
    create?: XOR<usersCreateWithoutWalletsInput, usersUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutWalletsNestedInput = {
    create?: XOR<usersCreateWithoutWalletsInput, usersUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletsInput
    upsert?: usersUpsertWithoutWalletsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWalletsInput, usersUpdateWithoutWalletsInput>, usersUncheckedUpdateWithoutWalletsInput>
  }

  export type usersCreateNestedOneWithoutSaved_cardsInput = {
    create?: XOR<usersCreateWithoutSaved_cardsInput, usersUncheckedCreateWithoutSaved_cardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSaved_cardsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSaved_cardsNestedInput = {
    create?: XOR<usersCreateWithoutSaved_cardsInput, usersUncheckedCreateWithoutSaved_cardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSaved_cardsInput
    upsert?: usersUpsertWithoutSaved_cardsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSaved_cardsInput, usersUpdateWithoutSaved_cardsInput>, usersUncheckedUpdateWithoutSaved_cardsInput>
  }

  export type payment_typesCreateNestedOneWithoutPayment_methodsInput = {
    create?: XOR<payment_typesCreateWithoutPayment_methodsInput, payment_typesUncheckedCreateWithoutPayment_methodsInput>
    connectOrCreate?: payment_typesCreateOrConnectWithoutPayment_methodsInput
    connect?: payment_typesWhereUniqueInput
  }

  export type paymentsCreateNestedManyWithoutPayment_methodsInput = {
    create?: XOR<paymentsCreateWithoutPayment_methodsInput, paymentsUncheckedCreateWithoutPayment_methodsInput> | paymentsCreateWithoutPayment_methodsInput[] | paymentsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayment_methodsInput | paymentsCreateOrConnectWithoutPayment_methodsInput[]
    createMany?: paymentsCreateManyPayment_methodsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type transactionsCreateNestedManyWithoutPayment_methodsInput = {
    create?: XOR<transactionsCreateWithoutPayment_methodsInput, transactionsUncheckedCreateWithoutPayment_methodsInput> | transactionsCreateWithoutPayment_methodsInput[] | transactionsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutPayment_methodsInput | transactionsCreateOrConnectWithoutPayment_methodsInput[]
    createMany?: transactionsCreateManyPayment_methodsInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutPayment_methodsInput = {
    create?: XOR<paymentsCreateWithoutPayment_methodsInput, paymentsUncheckedCreateWithoutPayment_methodsInput> | paymentsCreateWithoutPayment_methodsInput[] | paymentsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayment_methodsInput | paymentsCreateOrConnectWithoutPayment_methodsInput[]
    createMany?: paymentsCreateManyPayment_methodsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutPayment_methodsInput = {
    create?: XOR<transactionsCreateWithoutPayment_methodsInput, transactionsUncheckedCreateWithoutPayment_methodsInput> | transactionsCreateWithoutPayment_methodsInput[] | transactionsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutPayment_methodsInput | transactionsCreateOrConnectWithoutPayment_methodsInput[]
    createMany?: transactionsCreateManyPayment_methodsInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type payment_typesUpdateOneWithoutPayment_methodsNestedInput = {
    create?: XOR<payment_typesCreateWithoutPayment_methodsInput, payment_typesUncheckedCreateWithoutPayment_methodsInput>
    connectOrCreate?: payment_typesCreateOrConnectWithoutPayment_methodsInput
    upsert?: payment_typesUpsertWithoutPayment_methodsInput
    disconnect?: payment_typesWhereInput | boolean
    delete?: payment_typesWhereInput | boolean
    connect?: payment_typesWhereUniqueInput
    update?: XOR<XOR<payment_typesUpdateToOneWithWhereWithoutPayment_methodsInput, payment_typesUpdateWithoutPayment_methodsInput>, payment_typesUncheckedUpdateWithoutPayment_methodsInput>
  }

  export type paymentsUpdateManyWithoutPayment_methodsNestedInput = {
    create?: XOR<paymentsCreateWithoutPayment_methodsInput, paymentsUncheckedCreateWithoutPayment_methodsInput> | paymentsCreateWithoutPayment_methodsInput[] | paymentsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayment_methodsInput | paymentsCreateOrConnectWithoutPayment_methodsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput | paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput[]
    createMany?: paymentsCreateManyPayment_methodsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput | paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutPayment_methodsInput | paymentsUpdateManyWithWhereWithoutPayment_methodsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type transactionsUpdateManyWithoutPayment_methodsNestedInput = {
    create?: XOR<transactionsCreateWithoutPayment_methodsInput, transactionsUncheckedCreateWithoutPayment_methodsInput> | transactionsCreateWithoutPayment_methodsInput[] | transactionsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutPayment_methodsInput | transactionsCreateOrConnectWithoutPayment_methodsInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutPayment_methodsInput | transactionsUpsertWithWhereUniqueWithoutPayment_methodsInput[]
    createMany?: transactionsCreateManyPayment_methodsInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutPayment_methodsInput | transactionsUpdateWithWhereUniqueWithoutPayment_methodsInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutPayment_methodsInput | transactionsUpdateManyWithWhereWithoutPayment_methodsInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutPayment_methodsNestedInput = {
    create?: XOR<paymentsCreateWithoutPayment_methodsInput, paymentsUncheckedCreateWithoutPayment_methodsInput> | paymentsCreateWithoutPayment_methodsInput[] | paymentsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayment_methodsInput | paymentsCreateOrConnectWithoutPayment_methodsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput | paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput[]
    createMany?: paymentsCreateManyPayment_methodsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput | paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutPayment_methodsInput | paymentsUpdateManyWithWhereWithoutPayment_methodsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutPayment_methodsNestedInput = {
    create?: XOR<transactionsCreateWithoutPayment_methodsInput, transactionsUncheckedCreateWithoutPayment_methodsInput> | transactionsCreateWithoutPayment_methodsInput[] | transactionsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutPayment_methodsInput | transactionsCreateOrConnectWithoutPayment_methodsInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutPayment_methodsInput | transactionsUpsertWithWhereUniqueWithoutPayment_methodsInput[]
    createMany?: transactionsCreateManyPayment_methodsInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutPayment_methodsInput | transactionsUpdateWithWhereUniqueWithoutPayment_methodsInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutPayment_methodsInput | transactionsUpdateManyWithWhereWithoutPayment_methodsInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type transaction_categoriesCreateNestedOneWithoutOther_transaction_categoriesInput = {
    create?: XOR<transaction_categoriesCreateWithoutOther_transaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutOther_transaction_categoriesInput>
    connectOrCreate?: transaction_categoriesCreateOrConnectWithoutOther_transaction_categoriesInput
    connect?: transaction_categoriesWhereUniqueInput
  }

  export type transaction_categoriesCreateNestedManyWithoutTransaction_categoriesInput = {
    create?: XOR<transaction_categoriesCreateWithoutTransaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput> | transaction_categoriesCreateWithoutTransaction_categoriesInput[] | transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput[]
    connectOrCreate?: transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput | transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput[]
    createMany?: transaction_categoriesCreateManyTransaction_categoriesInputEnvelope
    connect?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
  }

  export type transactionsCreateNestedManyWithoutTransaction_categoriesInput = {
    create?: XOR<transactionsCreateWithoutTransaction_categoriesInput, transactionsUncheckedCreateWithoutTransaction_categoriesInput> | transactionsCreateWithoutTransaction_categoriesInput[] | transactionsUncheckedCreateWithoutTransaction_categoriesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutTransaction_categoriesInput | transactionsCreateOrConnectWithoutTransaction_categoriesInput[]
    createMany?: transactionsCreateManyTransaction_categoriesInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transaction_categoriesUncheckedCreateNestedManyWithoutTransaction_categoriesInput = {
    create?: XOR<transaction_categoriesCreateWithoutTransaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput> | transaction_categoriesCreateWithoutTransaction_categoriesInput[] | transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput[]
    connectOrCreate?: transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput | transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput[]
    createMany?: transaction_categoriesCreateManyTransaction_categoriesInputEnvelope
    connect?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutTransaction_categoriesInput = {
    create?: XOR<transactionsCreateWithoutTransaction_categoriesInput, transactionsUncheckedCreateWithoutTransaction_categoriesInput> | transactionsCreateWithoutTransaction_categoriesInput[] | transactionsUncheckedCreateWithoutTransaction_categoriesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutTransaction_categoriesInput | transactionsCreateOrConnectWithoutTransaction_categoriesInput[]
    createMany?: transactionsCreateManyTransaction_categoriesInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transaction_categoriesUpdateOneWithoutOther_transaction_categoriesNestedInput = {
    create?: XOR<transaction_categoriesCreateWithoutOther_transaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutOther_transaction_categoriesInput>
    connectOrCreate?: transaction_categoriesCreateOrConnectWithoutOther_transaction_categoriesInput
    upsert?: transaction_categoriesUpsertWithoutOther_transaction_categoriesInput
    disconnect?: transaction_categoriesWhereInput | boolean
    delete?: transaction_categoriesWhereInput | boolean
    connect?: transaction_categoriesWhereUniqueInput
    update?: XOR<XOR<transaction_categoriesUpdateToOneWithWhereWithoutOther_transaction_categoriesInput, transaction_categoriesUpdateWithoutOther_transaction_categoriesInput>, transaction_categoriesUncheckedUpdateWithoutOther_transaction_categoriesInput>
  }

  export type transaction_categoriesUpdateManyWithoutTransaction_categoriesNestedInput = {
    create?: XOR<transaction_categoriesCreateWithoutTransaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput> | transaction_categoriesCreateWithoutTransaction_categoriesInput[] | transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput[]
    connectOrCreate?: transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput | transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput[]
    upsert?: transaction_categoriesUpsertWithWhereUniqueWithoutTransaction_categoriesInput | transaction_categoriesUpsertWithWhereUniqueWithoutTransaction_categoriesInput[]
    createMany?: transaction_categoriesCreateManyTransaction_categoriesInputEnvelope
    set?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
    disconnect?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
    delete?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
    connect?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
    update?: transaction_categoriesUpdateWithWhereUniqueWithoutTransaction_categoriesInput | transaction_categoriesUpdateWithWhereUniqueWithoutTransaction_categoriesInput[]
    updateMany?: transaction_categoriesUpdateManyWithWhereWithoutTransaction_categoriesInput | transaction_categoriesUpdateManyWithWhereWithoutTransaction_categoriesInput[]
    deleteMany?: transaction_categoriesScalarWhereInput | transaction_categoriesScalarWhereInput[]
  }

  export type transactionsUpdateManyWithoutTransaction_categoriesNestedInput = {
    create?: XOR<transactionsCreateWithoutTransaction_categoriesInput, transactionsUncheckedCreateWithoutTransaction_categoriesInput> | transactionsCreateWithoutTransaction_categoriesInput[] | transactionsUncheckedCreateWithoutTransaction_categoriesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutTransaction_categoriesInput | transactionsCreateOrConnectWithoutTransaction_categoriesInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutTransaction_categoriesInput | transactionsUpsertWithWhereUniqueWithoutTransaction_categoriesInput[]
    createMany?: transactionsCreateManyTransaction_categoriesInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutTransaction_categoriesInput | transactionsUpdateWithWhereUniqueWithoutTransaction_categoriesInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutTransaction_categoriesInput | transactionsUpdateManyWithWhereWithoutTransaction_categoriesInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type transaction_categoriesUncheckedUpdateManyWithoutTransaction_categoriesNestedInput = {
    create?: XOR<transaction_categoriesCreateWithoutTransaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput> | transaction_categoriesCreateWithoutTransaction_categoriesInput[] | transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput[]
    connectOrCreate?: transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput | transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput[]
    upsert?: transaction_categoriesUpsertWithWhereUniqueWithoutTransaction_categoriesInput | transaction_categoriesUpsertWithWhereUniqueWithoutTransaction_categoriesInput[]
    createMany?: transaction_categoriesCreateManyTransaction_categoriesInputEnvelope
    set?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
    disconnect?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
    delete?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
    connect?: transaction_categoriesWhereUniqueInput | transaction_categoriesWhereUniqueInput[]
    update?: transaction_categoriesUpdateWithWhereUniqueWithoutTransaction_categoriesInput | transaction_categoriesUpdateWithWhereUniqueWithoutTransaction_categoriesInput[]
    updateMany?: transaction_categoriesUpdateManyWithWhereWithoutTransaction_categoriesInput | transaction_categoriesUpdateManyWithWhereWithoutTransaction_categoriesInput[]
    deleteMany?: transaction_categoriesScalarWhereInput | transaction_categoriesScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutTransaction_categoriesNestedInput = {
    create?: XOR<transactionsCreateWithoutTransaction_categoriesInput, transactionsUncheckedCreateWithoutTransaction_categoriesInput> | transactionsCreateWithoutTransaction_categoriesInput[] | transactionsUncheckedCreateWithoutTransaction_categoriesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutTransaction_categoriesInput | transactionsCreateOrConnectWithoutTransaction_categoriesInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutTransaction_categoriesInput | transactionsUpsertWithWhereUniqueWithoutTransaction_categoriesInput[]
    createMany?: transactionsCreateManyTransaction_categoriesInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutTransaction_categoriesInput | transactionsUpdateWithWhereUniqueWithoutTransaction_categoriesInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutTransaction_categoriesInput | transactionsUpdateManyWithWhereWithoutTransaction_categoriesInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type paymentsCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<paymentsCreateWithoutTransactionsInput, paymentsUncheckedCreateWithoutTransactionsInput> | paymentsCreateWithoutTransactionsInput[] | paymentsUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutTransactionsInput | paymentsCreateOrConnectWithoutTransactionsInput[]
    createMany?: paymentsCreateManyTransactionsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type transaction_categoriesCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<transaction_categoriesCreateWithoutTransactionsInput, transaction_categoriesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: transaction_categoriesCreateOrConnectWithoutTransactionsInput
    connect?: transaction_categoriesWhereUniqueInput
  }

  export type payment_methodsCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<payment_methodsCreateWithoutTransactionsInput, payment_methodsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: payment_methodsCreateOrConnectWithoutTransactionsInput
    connect?: payment_methodsWhereUniqueInput
  }

  export type transaction_typesCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<transaction_typesCreateWithoutTransactionsInput, transaction_typesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: transaction_typesCreateOrConnectWithoutTransactionsInput
    connect?: transaction_typesWhereUniqueInput
  }

  export type paymentsUncheckedCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<paymentsCreateWithoutTransactionsInput, paymentsUncheckedCreateWithoutTransactionsInput> | paymentsCreateWithoutTransactionsInput[] | paymentsUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutTransactionsInput | paymentsCreateOrConnectWithoutTransactionsInput[]
    createMany?: paymentsCreateManyTransactionsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type paymentsUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<paymentsCreateWithoutTransactionsInput, paymentsUncheckedCreateWithoutTransactionsInput> | paymentsCreateWithoutTransactionsInput[] | paymentsUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutTransactionsInput | paymentsCreateOrConnectWithoutTransactionsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutTransactionsInput | paymentsUpsertWithWhereUniqueWithoutTransactionsInput[]
    createMany?: paymentsCreateManyTransactionsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutTransactionsInput | paymentsUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutTransactionsInput | paymentsUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type transaction_categoriesUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<transaction_categoriesCreateWithoutTransactionsInput, transaction_categoriesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: transaction_categoriesCreateOrConnectWithoutTransactionsInput
    upsert?: transaction_categoriesUpsertWithoutTransactionsInput
    disconnect?: transaction_categoriesWhereInput | boolean
    delete?: transaction_categoriesWhereInput | boolean
    connect?: transaction_categoriesWhereUniqueInput
    update?: XOR<XOR<transaction_categoriesUpdateToOneWithWhereWithoutTransactionsInput, transaction_categoriesUpdateWithoutTransactionsInput>, transaction_categoriesUncheckedUpdateWithoutTransactionsInput>
  }

  export type payment_methodsUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<payment_methodsCreateWithoutTransactionsInput, payment_methodsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: payment_methodsCreateOrConnectWithoutTransactionsInput
    upsert?: payment_methodsUpsertWithoutTransactionsInput
    disconnect?: payment_methodsWhereInput | boolean
    delete?: payment_methodsWhereInput | boolean
    connect?: payment_methodsWhereUniqueInput
    update?: XOR<XOR<payment_methodsUpdateToOneWithWhereWithoutTransactionsInput, payment_methodsUpdateWithoutTransactionsInput>, payment_methodsUncheckedUpdateWithoutTransactionsInput>
  }

  export type transaction_typesUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<transaction_typesCreateWithoutTransactionsInput, transaction_typesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: transaction_typesCreateOrConnectWithoutTransactionsInput
    upsert?: transaction_typesUpsertWithoutTransactionsInput
    disconnect?: transaction_typesWhereInput | boolean
    delete?: transaction_typesWhereInput | boolean
    connect?: transaction_typesWhereUniqueInput
    update?: XOR<XOR<transaction_typesUpdateToOneWithWhereWithoutTransactionsInput, transaction_typesUpdateWithoutTransactionsInput>, transaction_typesUncheckedUpdateWithoutTransactionsInput>
  }

  export type paymentsUncheckedUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<paymentsCreateWithoutTransactionsInput, paymentsUncheckedCreateWithoutTransactionsInput> | paymentsCreateWithoutTransactionsInput[] | paymentsUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutTransactionsInput | paymentsCreateOrConnectWithoutTransactionsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutTransactionsInput | paymentsUpsertWithWhereUniqueWithoutTransactionsInput[]
    createMany?: paymentsCreateManyTransactionsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutTransactionsInput | paymentsUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutTransactionsInput | paymentsUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type transactionsCreateNestedManyWithoutTransaction_typesInput = {
    create?: XOR<transactionsCreateWithoutTransaction_typesInput, transactionsUncheckedCreateWithoutTransaction_typesInput> | transactionsCreateWithoutTransaction_typesInput[] | transactionsUncheckedCreateWithoutTransaction_typesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutTransaction_typesInput | transactionsCreateOrConnectWithoutTransaction_typesInput[]
    createMany?: transactionsCreateManyTransaction_typesInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutTransaction_typesInput = {
    create?: XOR<transactionsCreateWithoutTransaction_typesInput, transactionsUncheckedCreateWithoutTransaction_typesInput> | transactionsCreateWithoutTransaction_typesInput[] | transactionsUncheckedCreateWithoutTransaction_typesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutTransaction_typesInput | transactionsCreateOrConnectWithoutTransaction_typesInput[]
    createMany?: transactionsCreateManyTransaction_typesInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transactionsUpdateManyWithoutTransaction_typesNestedInput = {
    create?: XOR<transactionsCreateWithoutTransaction_typesInput, transactionsUncheckedCreateWithoutTransaction_typesInput> | transactionsCreateWithoutTransaction_typesInput[] | transactionsUncheckedCreateWithoutTransaction_typesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutTransaction_typesInput | transactionsCreateOrConnectWithoutTransaction_typesInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutTransaction_typesInput | transactionsUpsertWithWhereUniqueWithoutTransaction_typesInput[]
    createMany?: transactionsCreateManyTransaction_typesInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutTransaction_typesInput | transactionsUpdateWithWhereUniqueWithoutTransaction_typesInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutTransaction_typesInput | transactionsUpdateManyWithWhereWithoutTransaction_typesInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutTransaction_typesNestedInput = {
    create?: XOR<transactionsCreateWithoutTransaction_typesInput, transactionsUncheckedCreateWithoutTransaction_typesInput> | transactionsCreateWithoutTransaction_typesInput[] | transactionsUncheckedCreateWithoutTransaction_typesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutTransaction_typesInput | transactionsCreateOrConnectWithoutTransaction_typesInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutTransaction_typesInput | transactionsUpsertWithWhereUniqueWithoutTransaction_typesInput[]
    createMany?: transactionsCreateManyTransaction_typesInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutTransaction_typesInput | transactionsUpdateWithWhereUniqueWithoutTransaction_typesInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutTransaction_typesInput | transactionsUpdateManyWithWhereWithoutTransaction_typesInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type usersCreateNestedManyWithoutReferral_sourcesInput = {
    create?: XOR<usersCreateWithoutReferral_sourcesInput, usersUncheckedCreateWithoutReferral_sourcesInput> | usersCreateWithoutReferral_sourcesInput[] | usersUncheckedCreateWithoutReferral_sourcesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutReferral_sourcesInput | usersCreateOrConnectWithoutReferral_sourcesInput[]
    createMany?: usersCreateManyReferral_sourcesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutReferral_sourcesInput = {
    create?: XOR<usersCreateWithoutReferral_sourcesInput, usersUncheckedCreateWithoutReferral_sourcesInput> | usersCreateWithoutReferral_sourcesInput[] | usersUncheckedCreateWithoutReferral_sourcesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutReferral_sourcesInput | usersCreateOrConnectWithoutReferral_sourcesInput[]
    createMany?: usersCreateManyReferral_sourcesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutReferral_sourcesNestedInput = {
    create?: XOR<usersCreateWithoutReferral_sourcesInput, usersUncheckedCreateWithoutReferral_sourcesInput> | usersCreateWithoutReferral_sourcesInput[] | usersUncheckedCreateWithoutReferral_sourcesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutReferral_sourcesInput | usersCreateOrConnectWithoutReferral_sourcesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutReferral_sourcesInput | usersUpsertWithWhereUniqueWithoutReferral_sourcesInput[]
    createMany?: usersCreateManyReferral_sourcesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutReferral_sourcesInput | usersUpdateWithWhereUniqueWithoutReferral_sourcesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutReferral_sourcesInput | usersUpdateManyWithWhereWithoutReferral_sourcesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutReferral_sourcesNestedInput = {
    create?: XOR<usersCreateWithoutReferral_sourcesInput, usersUncheckedCreateWithoutReferral_sourcesInput> | usersCreateWithoutReferral_sourcesInput[] | usersUncheckedCreateWithoutReferral_sourcesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutReferral_sourcesInput | usersCreateOrConnectWithoutReferral_sourcesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutReferral_sourcesInput | usersUpsertWithWhereUniqueWithoutReferral_sourcesInput[]
    createMany?: usersCreateManyReferral_sourcesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutReferral_sourcesInput | usersUpdateWithWhereUniqueWithoutReferral_sourcesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutReferral_sourcesInput | usersUpdateManyWithWhereWithoutReferral_sourcesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumactivity_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.activity_type_enum | Enumactivity_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.activity_type_enum[] | ListEnumactivity_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.activity_type_enum[] | ListEnumactivity_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumactivity_type_enumFilter<$PrismaModel> | $Enums.activity_type_enum
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumactivity_status_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.activity_status_enum | Enumactivity_status_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.activity_status_enum[] | ListEnumactivity_status_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.activity_status_enum[] | ListEnumactivity_status_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumactivity_status_enumNullableFilter<$PrismaModel> | $Enums.activity_status_enum | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumactivity_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.activity_type_enum | Enumactivity_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.activity_type_enum[] | ListEnumactivity_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.activity_type_enum[] | ListEnumactivity_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumactivity_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.activity_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumactivity_type_enumFilter<$PrismaModel>
    _max?: NestedEnumactivity_type_enumFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumactivity_status_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.activity_status_enum | Enumactivity_status_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.activity_status_enum[] | ListEnumactivity_status_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.activity_status_enum[] | ListEnumactivity_status_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumactivity_status_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.activity_status_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumactivity_status_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumactivity_status_enumNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumpayment_method_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_method_enumNullableFilter<$PrismaModel> | $Enums.payment_method_enum | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumpayment_method_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_method_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_method_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_method_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_method_enumNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnuminvoice_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_status_enum | Enuminvoice_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnuminvoice_status_enumFilter<$PrismaModel> | $Enums.invoice_status_enum
  }

  export type NestedEnuminvoice_type_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_type_enum | Enuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.invoice_type_enum[] | ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.invoice_type_enum[] | ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnuminvoice_type_enumNullableFilter<$PrismaModel> | $Enums.invoice_type_enum | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnuminvoice_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_status_enum | Enuminvoice_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnuminvoice_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.invoice_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminvoice_status_enumFilter<$PrismaModel>
    _max?: NestedEnuminvoice_status_enumFilter<$PrismaModel>
  }

  export type NestedEnuminvoice_type_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_type_enum | Enuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.invoice_type_enum[] | ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.invoice_type_enum[] | ListEnuminvoice_type_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnuminvoice_type_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.invoice_type_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminvoice_type_enumNullableFilter<$PrismaModel>
    _max?: NestedEnuminvoice_type_enumNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumoperator_role_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.operator_role_enum | Enumoperator_role_enumFieldRefInput<$PrismaModel>
    in?: $Enums.operator_role_enum[] | ListEnumoperator_role_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.operator_role_enum[] | ListEnumoperator_role_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumoperator_role_enumFilter<$PrismaModel> | $Enums.operator_role_enum
  }

  export type NestedEnumoperator_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.operator_status_enum | Enumoperator_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.operator_status_enum[] | ListEnumoperator_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.operator_status_enum[] | ListEnumoperator_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumoperator_status_enumFilter<$PrismaModel> | $Enums.operator_status_enum
  }

  export type NestedEnumoperator_role_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.operator_role_enum | Enumoperator_role_enumFieldRefInput<$PrismaModel>
    in?: $Enums.operator_role_enum[] | ListEnumoperator_role_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.operator_role_enum[] | ListEnumoperator_role_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumoperator_role_enumWithAggregatesFilter<$PrismaModel> | $Enums.operator_role_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumoperator_role_enumFilter<$PrismaModel>
    _max?: NestedEnumoperator_role_enumFilter<$PrismaModel>
  }

  export type NestedEnumoperator_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.operator_status_enum | Enumoperator_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.operator_status_enum[] | ListEnumoperator_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.operator_status_enum[] | ListEnumoperator_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumoperator_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.operator_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumoperator_status_enumFilter<$PrismaModel>
    _max?: NestedEnumoperator_status_enumFilter<$PrismaModel>
  }

  export type NestedEnumpackage_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.package_status_enum | Enumpackage_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.package_status_enum[] | ListEnumpackage_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.package_status_enum[] | ListEnumpackage_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpackage_status_enumFilter<$PrismaModel> | $Enums.package_status_enum
  }

  export type NestedEnumpackage_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.package_status_enum | Enumpackage_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.package_status_enum[] | ListEnumpackage_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.package_status_enum[] | ListEnumpackage_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpackage_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.package_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpackage_status_enumFilter<$PrismaModel>
    _max?: NestedEnumpackage_status_enumFilter<$PrismaModel>
  }

  export type NestedEnumpayment_method_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_method_enumFilter<$PrismaModel> | $Enums.payment_method_enum
  }

  export type NestedEnumpayment_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status_enum | Enumpayment_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_status_enumFilter<$PrismaModel> | $Enums.payment_status_enum
  }

  export type NestedEnumpayment_method_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_method_enumWithAggregatesFilter<$PrismaModel> | $Enums.payment_method_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayment_method_enumFilter<$PrismaModel>
    _max?: NestedEnumpayment_method_enumFilter<$PrismaModel>
  }

  export type NestedEnumpayment_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status_enum | Enumpayment_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.payment_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayment_status_enumFilter<$PrismaModel>
    _max?: NestedEnumpayment_status_enumFilter<$PrismaModel>
  }

  export type NestedEnumproduct_status_enumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.product_status_enum | Enumproduct_status_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.product_status_enum[] | ListEnumproduct_status_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.product_status_enum[] | ListEnumproduct_status_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumproduct_status_enumNullableFilter<$PrismaModel> | $Enums.product_status_enum | null
  }

  export type NestedEnumproduct_status_enumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.product_status_enum | Enumproduct_status_enumFieldRefInput<$PrismaModel> | null
    in?: $Enums.product_status_enum[] | ListEnumproduct_status_enumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.product_status_enum[] | ListEnumproduct_status_enumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumproduct_status_enumNullableWithAggregatesFilter<$PrismaModel> | $Enums.product_status_enum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumproduct_status_enumNullableFilter<$PrismaModel>
    _max?: NestedEnumproduct_status_enumNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type branchesCreateWithoutActivitiesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutActivitiesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutActivitiesInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutActivitiesInput, branchesUncheckedCreateWithoutActivitiesInput>
  }

  export type operatorsCreateWithoutActivitiesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    email_templates?: email_templatesCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorCreateNestedManyWithoutOperatorsInput
    branches: branchesCreateNestedOneWithoutOperatorsInput
    operator_types: operator_typesCreateNestedOneWithoutOperatorsInput
    packages?: packagesCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsUncheckedCreateWithoutActivitiesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    email_templates?: email_templatesUncheckedCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorUncheckedCreateNestedManyWithoutOperatorsInput
    packages?: packagesUncheckedCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsCreateOrConnectWithoutActivitiesInput = {
    where: operatorsWhereUniqueInput
    create: XOR<operatorsCreateWithoutActivitiesInput, operatorsUncheckedCreateWithoutActivitiesInput>
  }

  export type branchesUpsertWithoutActivitiesInput = {
    update: XOR<branchesUpdateWithoutActivitiesInput, branchesUncheckedUpdateWithoutActivitiesInput>
    create: XOR<branchesCreateWithoutActivitiesInput, branchesUncheckedCreateWithoutActivitiesInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutActivitiesInput, branchesUncheckedUpdateWithoutActivitiesInput>
  }

  export type branchesUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type operatorsUpsertWithoutActivitiesInput = {
    update: XOR<operatorsUpdateWithoutActivitiesInput, operatorsUncheckedUpdateWithoutActivitiesInput>
    create: XOR<operatorsCreateWithoutActivitiesInput, operatorsUncheckedCreateWithoutActivitiesInput>
    where?: operatorsWhereInput
  }

  export type operatorsUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: operatorsWhereInput
    data: XOR<operatorsUpdateWithoutActivitiesInput, operatorsUncheckedUpdateWithoutActivitiesInput>
  }

  export type operatorsUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email_templates?: email_templatesUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUpdateManyWithoutOperatorsNestedInput
    branches?: branchesUpdateOneRequiredWithoutOperatorsNestedInput
    operator_types?: operator_typesUpdateOneRequiredWithoutOperatorsNestedInput
    packages?: packagesUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email_templates?: email_templatesUncheckedUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUncheckedUpdateManyWithoutOperatorsNestedInput
    packages?: packagesUncheckedUpdateManyWithoutOperatorsNestedInput
  }

  export type activitiesCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    operators?: operatorsCreateNestedOneWithoutActivitiesInput
  }

  export type activitiesUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    operator_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesCreateOrConnectWithoutBranchesInput = {
    where: activitiesWhereUniqueInput
    create: XOR<activitiesCreateWithoutBranchesInput, activitiesUncheckedCreateWithoutBranchesInput>
  }

  export type activitiesCreateManyBranchesInputEnvelope = {
    data: activitiesCreateManyBranchesInput | activitiesCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type companiesCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    email?: string | null
    phone?: string | null
    ruc?: string | null
    logo_url?: string | null
    website?: string | null
    tax_id?: string | null
    business_type?: string | null
    industry?: string | null
    founded_date?: Date | string | null
    is_active?: boolean | null
  }

  export type companiesUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    email?: string | null
    phone?: string | null
    ruc?: string | null
    logo_url?: string | null
    website?: string | null
    tax_id?: string | null
    business_type?: string | null
    industry?: string | null
    founded_date?: Date | string | null
    is_active?: boolean | null
  }

  export type companiesCreateOrConnectWithoutBranchesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutBranchesInput, companiesUncheckedCreateWithoutBranchesInput>
  }

  export type gift_cardsCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    issue_date?: Date | string
    expiry_date?: Date | string | null
    recipient_name?: string | null
    recipient_email?: string | null
    sender_id?: string | null
    redeemed_at?: Date | string | null
    message?: string | null
    payment_method?: $Enums.payment_method_enum | null
    send_date?: Date | string | null
    design_template?: string | null
    is_reloadable?: boolean | null
    access_pin?: string | null
    usage_history?: gift_cardsCreateusage_historyInput | InputJsonValue[]
  }

  export type gift_cardsUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    issue_date?: Date | string
    expiry_date?: Date | string | null
    recipient_name?: string | null
    recipient_email?: string | null
    sender_id?: string | null
    redeemed_at?: Date | string | null
    message?: string | null
    payment_method?: $Enums.payment_method_enum | null
    send_date?: Date | string | null
    design_template?: string | null
    is_reloadable?: boolean | null
    access_pin?: string | null
    usage_history?: gift_cardsCreateusage_historyInput | InputJsonValue[]
  }

  export type gift_cardsCreateOrConnectWithoutBranchesInput = {
    where: gift_cardsWhereUniqueInput
    create: XOR<gift_cardsCreateWithoutBranchesInput, gift_cardsUncheckedCreateWithoutBranchesInput>
  }

  export type gift_cardsCreateManyBranchesInputEnvelope = {
    data: gift_cardsCreateManyBranchesInput | gift_cardsCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type invoicesCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesCreateNestedManyWithoutInvoicesInput
    operators?: operatorsCreateNestedOneWithoutInvoicesInput
    users?: usersCreateNestedOneWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutInvoicesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutBranchesInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutBranchesInput, invoicesUncheckedCreateWithoutBranchesInput>
  }

  export type invoicesCreateManyBranchesInputEnvelope = {
    data: invoicesCreateManyBranchesInput | invoicesCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type operatorsCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorCreateNestedManyWithoutOperatorsInput
    operator_types: operator_typesCreateNestedOneWithoutOperatorsInput
    packages?: packagesCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesUncheckedCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorUncheckedCreateNestedManyWithoutOperatorsInput
    packages?: packagesUncheckedCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsCreateOrConnectWithoutBranchesInput = {
    where: operatorsWhereUniqueInput
    create: XOR<operatorsCreateWithoutBranchesInput, operatorsUncheckedCreateWithoutBranchesInput>
  }

  export type operatorsCreateManyBranchesInputEnvelope = {
    data: operatorsCreateManyBranchesInput | operatorsCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type packagesCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    position?: string | null
    invoice_packages?: invoice_packagesCreateNestedManyWithoutPackagesInput
    users?: usersCreateNestedOneWithoutPackagesInput
    operators?: operatorsCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_reference?: string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    operator_id?: string | null
    position?: string | null
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutPackagesInput
  }

  export type packagesCreateOrConnectWithoutBranchesInput = {
    where: packagesWhereUniqueInput
    create: XOR<packagesCreateWithoutBranchesInput, packagesUncheckedCreateWithoutBranchesInput>
  }

  export type packagesCreateManyBranchesInputEnvelope = {
    data: packagesCreateManyBranchesInput | packagesCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type plansCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsCreateNestedManyWithoutPlansInput
    plan_addresses?: plan_addressesCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresCreateNestedManyWithoutPlansInput
    users?: usersCreateNestedManyWithoutPlansInput
  }

  export type plansUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutPlansInput
    plan_addresses?: plan_addressesUncheckedCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresUncheckedCreateNestedManyWithoutPlansInput
    users?: usersUncheckedCreateNestedManyWithoutPlansInput
  }

  export type plansCreateOrConnectWithoutBranchesInput = {
    where: plansWhereUniqueInput
    create: XOR<plansCreateWithoutBranchesInput, plansUncheckedCreateWithoutBranchesInput>
  }

  export type plansCreateManyBranchesInputEnvelope = {
    data: plansCreateManyBranchesInput | plansCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type productsCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutProductsInput
    categories?: categoriesCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    category_id?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutBranchesInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutBranchesInput, productsUncheckedCreateWithoutBranchesInput>
  }

  export type productsCreateManyBranchesInputEnvelope = {
    data: productsCreateManyBranchesInput | productsCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBranchesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput>
  }

  export type usersCreateManyBranchesInputEnvelope = {
    data: usersCreateManyBranchesInput | usersCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type vehiclesCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    make: string
    model: string
    year?: number | null
    license_plate: string
    status?: string
    color?: string | null
    vin?: string | null
    purchase_date?: Date | string | null
    last_maintenance_date?: Date | string | null
    mileage?: number | null
    fuel_type?: string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUncheckedCreateWithoutBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    make: string
    model: string
    year?: number | null
    license_plate: string
    status?: string
    color?: string | null
    vin?: string | null
    purchase_date?: Date | string | null
    last_maintenance_date?: Date | string | null
    mileage?: number | null
    fuel_type?: string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesCreateOrConnectWithoutBranchesInput = {
    where: vehiclesWhereUniqueInput
    create: XOR<vehiclesCreateWithoutBranchesInput, vehiclesUncheckedCreateWithoutBranchesInput>
  }

  export type vehiclesCreateManyBranchesInputEnvelope = {
    data: vehiclesCreateManyBranchesInput | vehiclesCreateManyBranchesInput[]
    skipDuplicates?: boolean
  }

  export type activitiesUpsertWithWhereUniqueWithoutBranchesInput = {
    where: activitiesWhereUniqueInput
    update: XOR<activitiesUpdateWithoutBranchesInput, activitiesUncheckedUpdateWithoutBranchesInput>
    create: XOR<activitiesCreateWithoutBranchesInput, activitiesUncheckedCreateWithoutBranchesInput>
  }

  export type activitiesUpdateWithWhereUniqueWithoutBranchesInput = {
    where: activitiesWhereUniqueInput
    data: XOR<activitiesUpdateWithoutBranchesInput, activitiesUncheckedUpdateWithoutBranchesInput>
  }

  export type activitiesUpdateManyWithWhereWithoutBranchesInput = {
    where: activitiesScalarWhereInput
    data: XOR<activitiesUpdateManyMutationInput, activitiesUncheckedUpdateManyWithoutBranchesInput>
  }

  export type activitiesScalarWhereInput = {
    AND?: activitiesScalarWhereInput | activitiesScalarWhereInput[]
    OR?: activitiesScalarWhereInput[]
    NOT?: activitiesScalarWhereInput | activitiesScalarWhereInput[]
    id?: UuidFilter<"activities"> | string
    created_at?: DateTimeFilter<"activities"> | Date | string
    action?: StringFilter<"activities"> | string
    type?: Enumactivity_type_enumFilter<"activities"> | $Enums.activity_type_enum
    description?: StringNullableFilter<"activities"> | string | null
    ip_address?: StringNullableFilter<"activities"> | string | null
    user_agent?: StringNullableFilter<"activities"> | string | null
    status?: Enumactivity_status_enumNullableFilter<"activities"> | $Enums.activity_status_enum | null
    operator_id?: UuidNullableFilter<"activities"> | string | null
    branch_id?: UuidNullableFilter<"activities"> | string | null
    entity_type?: StringNullableFilter<"activities"> | string | null
    entity_id?: UuidNullableFilter<"activities"> | string | null
    old_values?: JsonNullableFilter<"activities">
    new_values?: JsonNullableFilter<"activities">
    metadata?: JsonNullableFilter<"activities">
  }

  export type companiesUpsertWithoutBranchesInput = {
    update: XOR<companiesUpdateWithoutBranchesInput, companiesUncheckedUpdateWithoutBranchesInput>
    create: XOR<companiesCreateWithoutBranchesInput, companiesUncheckedCreateWithoutBranchesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutBranchesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutBranchesInput, companiesUncheckedUpdateWithoutBranchesInput>
  }

  export type companiesUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    founded_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type companiesUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    founded_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type gift_cardsUpsertWithWhereUniqueWithoutBranchesInput = {
    where: gift_cardsWhereUniqueInput
    update: XOR<gift_cardsUpdateWithoutBranchesInput, gift_cardsUncheckedUpdateWithoutBranchesInput>
    create: XOR<gift_cardsCreateWithoutBranchesInput, gift_cardsUncheckedCreateWithoutBranchesInput>
  }

  export type gift_cardsUpdateWithWhereUniqueWithoutBranchesInput = {
    where: gift_cardsWhereUniqueInput
    data: XOR<gift_cardsUpdateWithoutBranchesInput, gift_cardsUncheckedUpdateWithoutBranchesInput>
  }

  export type gift_cardsUpdateManyWithWhereWithoutBranchesInput = {
    where: gift_cardsScalarWhereInput
    data: XOR<gift_cardsUpdateManyMutationInput, gift_cardsUncheckedUpdateManyWithoutBranchesInput>
  }

  export type gift_cardsScalarWhereInput = {
    AND?: gift_cardsScalarWhereInput | gift_cardsScalarWhereInput[]
    OR?: gift_cardsScalarWhereInput[]
    NOT?: gift_cardsScalarWhereInput | gift_cardsScalarWhereInput[]
    id?: UuidFilter<"gift_cards"> | string
    created_at?: DateTimeFilter<"gift_cards"> | Date | string
    updated_at?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    code?: StringFilter<"gift_cards"> | string
    amount?: DecimalFilter<"gift_cards"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalNullableFilter<"gift_cards"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"gift_cards"> | string
    issue_date?: DateTimeFilter<"gift_cards"> | Date | string
    expiry_date?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    recipient_name?: StringNullableFilter<"gift_cards"> | string | null
    recipient_email?: StringNullableFilter<"gift_cards"> | string | null
    sender_id?: UuidNullableFilter<"gift_cards"> | string | null
    redeemed_at?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    message?: StringNullableFilter<"gift_cards"> | string | null
    payment_method?: Enumpayment_method_enumNullableFilter<"gift_cards"> | $Enums.payment_method_enum | null
    send_date?: DateTimeNullableFilter<"gift_cards"> | Date | string | null
    design_template?: StringNullableFilter<"gift_cards"> | string | null
    branch_id?: UuidNullableFilter<"gift_cards"> | string | null
    is_reloadable?: BoolNullableFilter<"gift_cards"> | boolean | null
    access_pin?: StringNullableFilter<"gift_cards"> | string | null
    usage_history?: JsonNullableListFilter<"gift_cards">
  }

  export type invoicesUpsertWithWhereUniqueWithoutBranchesInput = {
    where: invoicesWhereUniqueInput
    update: XOR<invoicesUpdateWithoutBranchesInput, invoicesUncheckedUpdateWithoutBranchesInput>
    create: XOR<invoicesCreateWithoutBranchesInput, invoicesUncheckedCreateWithoutBranchesInput>
  }

  export type invoicesUpdateWithWhereUniqueWithoutBranchesInput = {
    where: invoicesWhereUniqueInput
    data: XOR<invoicesUpdateWithoutBranchesInput, invoicesUncheckedUpdateWithoutBranchesInput>
  }

  export type invoicesUpdateManyWithWhereWithoutBranchesInput = {
    where: invoicesScalarWhereInput
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyWithoutBranchesInput>
  }

  export type invoicesScalarWhereInput = {
    AND?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
    OR?: invoicesScalarWhereInput[]
    NOT?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
    id?: UuidFilter<"invoices"> | string
    created_at?: DateTimeFilter<"invoices"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    invoice_number?: StringFilter<"invoices"> | string
    issue_date?: DateTimeFilter<"invoices"> | Date | string
    due_date?: DateTimeFilter<"invoices"> | Date | string
    status?: Enuminvoice_status_enumFilter<"invoices"> | $Enums.invoice_status_enum
    is_paid?: BoolNullableFilter<"invoices"> | boolean | null
    total_amount?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    discount_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    user_id?: UuidNullableFilter<"invoices"> | string | null
    branch_id?: UuidNullableFilter<"invoices"> | string | null
    operator_id?: UuidNullableFilter<"invoices"> | string | null
    billing_address?: JsonNullableFilter<"invoices">
    shipping_address?: JsonNullableFilter<"invoices">
    notes?: StringNullableFilter<"invoices"> | string | null
    payment_terms?: StringNullableFilter<"invoices"> | string | null
    currency?: StringNullableFilter<"invoices"> | string | null
    conversion_rate?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    tracking_number?: StringNullableFilter<"invoices"> | string | null
    shipping_method?: StringNullableFilter<"invoices"> | string | null
    invoice_type?: Enuminvoice_type_enumNullableFilter<"invoices"> | $Enums.invoice_type_enum | null
    commission_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    platform?: StringNullableFilter<"invoices"> | string | null
    external_reference_id?: StringNullableFilter<"invoices"> | string | null
    tax_details?: JsonNullableFilter<"invoices">
    price_plan?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFilter<"invoices"> | boolean
    paid_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: DecimalNullableFilter<"invoices"> | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: DateTimeNullableFilter<"invoices"> | Date | string | null
  }

  export type operatorsUpsertWithWhereUniqueWithoutBranchesInput = {
    where: operatorsWhereUniqueInput
    update: XOR<operatorsUpdateWithoutBranchesInput, operatorsUncheckedUpdateWithoutBranchesInput>
    create: XOR<operatorsCreateWithoutBranchesInput, operatorsUncheckedCreateWithoutBranchesInput>
  }

  export type operatorsUpdateWithWhereUniqueWithoutBranchesInput = {
    where: operatorsWhereUniqueInput
    data: XOR<operatorsUpdateWithoutBranchesInput, operatorsUncheckedUpdateWithoutBranchesInput>
  }

  export type operatorsUpdateManyWithWhereWithoutBranchesInput = {
    where: operatorsScalarWhereInput
    data: XOR<operatorsUpdateManyMutationInput, operatorsUncheckedUpdateManyWithoutBranchesInput>
  }

  export type operatorsScalarWhereInput = {
    AND?: operatorsScalarWhereInput | operatorsScalarWhereInput[]
    OR?: operatorsScalarWhereInput[]
    NOT?: operatorsScalarWhereInput | operatorsScalarWhereInput[]
    id?: UuidFilter<"operators"> | string
    created_at?: DateTimeFilter<"operators"> | Date | string
    updated_at?: DateTimeNullableFilter<"operators"> | Date | string | null
    email?: StringFilter<"operators"> | string
    password?: StringFilter<"operators"> | string
    first_name?: StringFilter<"operators"> | string
    last_name?: StringFilter<"operators"> | string
    phone?: StringNullableFilter<"operators"> | string | null
    photo?: StringNullableFilter<"operators"> | string | null
    role?: Enumoperator_role_enumFilter<"operators"> | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFilter<"operators"> | $Enums.operator_status_enum
    last_login_at?: DateTimeNullableFilter<"operators"> | Date | string | null
    branch_id?: UuidFilter<"operators"> | string
    type_operator_id?: UuidFilter<"operators"> | string
    position?: StringNullableFilter<"operators"> | string | null
    hire_date?: DateTimeNullableFilter<"operators"> | Date | string | null
    birth_date?: DateTimeNullableFilter<"operators"> | Date | string | null
    emergency_contact?: JsonNullableFilter<"operators">
    skills?: StringNullableListFilter<"operators">
    personal_id?: StringNullableFilter<"operators"> | string | null
    address?: StringNullableFilter<"operators"> | string | null
  }

  export type packagesUpsertWithWhereUniqueWithoutBranchesInput = {
    where: packagesWhereUniqueInput
    update: XOR<packagesUpdateWithoutBranchesInput, packagesUncheckedUpdateWithoutBranchesInput>
    create: XOR<packagesCreateWithoutBranchesInput, packagesUncheckedCreateWithoutBranchesInput>
  }

  export type packagesUpdateWithWhereUniqueWithoutBranchesInput = {
    where: packagesWhereUniqueInput
    data: XOR<packagesUpdateWithoutBranchesInput, packagesUncheckedUpdateWithoutBranchesInput>
  }

  export type packagesUpdateManyWithWhereWithoutBranchesInput = {
    where: packagesScalarWhereInput
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyWithoutBranchesInput>
  }

  export type packagesScalarWhereInput = {
    AND?: packagesScalarWhereInput | packagesScalarWhereInput[]
    OR?: packagesScalarWhereInput[]
    NOT?: packagesScalarWhereInput | packagesScalarWhereInput[]
    id?: UuidFilter<"packages"> | string
    created_at?: DateTimeFilter<"packages"> | Date | string
    updated_at?: DateTimeNullableFilter<"packages"> | Date | string | null
    user_reference?: UuidNullableFilter<"packages"> | string | null
    package_status?: Enumpackage_status_enumFilter<"packages"> | $Enums.package_status_enum
    tracking_number?: StringNullableFilter<"packages"> | string | null
    height?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    width?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    length?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    insurance?: BoolNullableFilter<"packages"> | boolean | null
    shipping_stages?: JsonNullableListFilter<"packages">
    branch_id?: UuidNullableFilter<"packages"> | string | null
    notes?: StringNullableFilter<"packages"> | string | null
    declared_value?: DecimalNullableFilter<"packages"> | Decimal | DecimalJsLike | number | string | null
    customs_information?: JsonNullableFilter<"packages">
    is_fragile?: BoolNullableFilter<"packages"> | boolean | null
    estimated_delivery_date?: DateTimeNullableFilter<"packages"> | Date | string | null
    operator_id?: UuidNullableFilter<"packages"> | string | null
    position?: StringNullableFilter<"packages"> | string | null
  }

  export type plansUpsertWithWhereUniqueWithoutBranchesInput = {
    where: plansWhereUniqueInput
    update: XOR<plansUpdateWithoutBranchesInput, plansUncheckedUpdateWithoutBranchesInput>
    create: XOR<plansCreateWithoutBranchesInput, plansUncheckedCreateWithoutBranchesInput>
  }

  export type plansUpdateWithWhereUniqueWithoutBranchesInput = {
    where: plansWhereUniqueInput
    data: XOR<plansUpdateWithoutBranchesInput, plansUncheckedUpdateWithoutBranchesInput>
  }

  export type plansUpdateManyWithWhereWithoutBranchesInput = {
    where: plansScalarWhereInput
    data: XOR<plansUpdateManyMutationInput, plansUncheckedUpdateManyWithoutBranchesInput>
  }

  export type plansScalarWhereInput = {
    AND?: plansScalarWhereInput | plansScalarWhereInput[]
    OR?: plansScalarWhereInput[]
    NOT?: plansScalarWhereInput | plansScalarWhereInput[]
    id?: UuidFilter<"plans"> | string
    created_at?: DateTimeFilter<"plans"> | Date | string
    updated_at?: DateTimeNullableFilter<"plans"> | Date | string | null
    name?: StringFilter<"plans"> | string
    description?: StringNullableFilter<"plans"> | string | null
    price?: DecimalFilter<"plans"> | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFilter<"plans"> | string
    color?: StringNullableFilter<"plans"> | string | null
    is_active?: BoolNullableFilter<"plans"> | boolean | null
    branch_id?: UuidNullableFilter<"plans"> | string | null
    trial_period_days?: IntNullableFilter<"plans"> | number | null
    setup_fee?: DecimalNullableFilter<"plans"> | Decimal | DecimalJsLike | number | string | null
    max_users?: IntNullableFilter<"plans"> | number | null
    discounts?: JsonNullableFilter<"plans">
  }

  export type productsUpsertWithWhereUniqueWithoutBranchesInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutBranchesInput, productsUncheckedUpdateWithoutBranchesInput>
    create: XOR<productsCreateWithoutBranchesInput, productsUncheckedCreateWithoutBranchesInput>
  }

  export type productsUpdateWithWhereUniqueWithoutBranchesInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutBranchesInput, productsUncheckedUpdateWithoutBranchesInput>
  }

  export type productsUpdateManyWithWhereWithoutBranchesInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutBranchesInput>
  }

  export type productsScalarWhereInput = {
    AND?: productsScalarWhereInput | productsScalarWhereInput[]
    OR?: productsScalarWhereInput[]
    NOT?: productsScalarWhereInput | productsScalarWhereInput[]
    id?: UuidFilter<"products"> | string
    created_at?: DateTimeFilter<"products"> | Date | string
    updated_at?: DateTimeNullableFilter<"products"> | Date | string | null
    name?: StringFilter<"products"> | string
    description?: StringNullableFilter<"products"> | string | null
    price?: DecimalFilter<"products"> | Decimal | DecimalJsLike | number | string
    sale_price?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    sku?: StringNullableFilter<"products"> | string | null
    barcode?: StringNullableFilter<"products"> | string | null
    stock_quantity?: IntNullableFilter<"products"> | number | null
    is_active?: BoolNullableFilter<"products"> | boolean | null
    status?: Enumproduct_status_enumNullableFilter<"products"> | $Enums.product_status_enum | null
    category_id?: UuidNullableFilter<"products"> | string | null
    branch_id?: UuidNullableFilter<"products"> | string | null
    weight?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"products">
    images?: StringNullableListFilter<"products">
    tags?: StringNullableListFilter<"products">
    min_stock_alert?: IntNullableFilter<"products"> | number | null
    manufacturer?: StringNullableFilter<"products"> | string | null
    tax_rate?: DecimalNullableFilter<"products"> | Decimal | DecimalJsLike | number | string | null
  }

  export type usersUpsertWithWhereUniqueWithoutBranchesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutBranchesInput, usersUncheckedUpdateWithoutBranchesInput>
    create: XOR<usersCreateWithoutBranchesInput, usersUncheckedCreateWithoutBranchesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutBranchesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutBranchesInput, usersUncheckedUpdateWithoutBranchesInput>
  }

  export type usersUpdateManyWithWhereWithoutBranchesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutBranchesInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: UuidFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    account_status?: BoolNullableFilter<"users"> | boolean | null
    birth_date?: DateTimeNullableFilter<"users"> | Date | string | null
    branch_id?: UuidNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    first_name?: StringNullableFilter<"users"> | string | null
    is_email_verified?: BoolNullableFilter<"users"> | boolean | null
    is_online?: BoolNullableFilter<"users"> | boolean | null
    is_verified?: BoolNullableFilter<"users"> | boolean | null
    last_name?: StringNullableFilter<"users"> | string | null
    last_seen?: DateTimeNullableFilter<"users"> | Date | string | null
    phone?: StringNullableFilter<"users"> | string | null
    photo_url?: StringNullableFilter<"users"> | string | null
    plan_id?: UuidNullableFilter<"users"> | string | null
    type_user_id?: UuidNullableFilter<"users"> | string | null
    shipping_insurance?: BoolFilter<"users"> | boolean
    is_business?: BoolNullableFilter<"users"> | boolean | null
    ruc?: StringNullableFilter<"users"> | string | null
    company_name?: StringNullableFilter<"users"> | string | null
    referral_source_id?: UuidNullableFilter<"users"> | string | null
  }

  export type vehiclesUpsertWithWhereUniqueWithoutBranchesInput = {
    where: vehiclesWhereUniqueInput
    update: XOR<vehiclesUpdateWithoutBranchesInput, vehiclesUncheckedUpdateWithoutBranchesInput>
    create: XOR<vehiclesCreateWithoutBranchesInput, vehiclesUncheckedCreateWithoutBranchesInput>
  }

  export type vehiclesUpdateWithWhereUniqueWithoutBranchesInput = {
    where: vehiclesWhereUniqueInput
    data: XOR<vehiclesUpdateWithoutBranchesInput, vehiclesUncheckedUpdateWithoutBranchesInput>
  }

  export type vehiclesUpdateManyWithWhereWithoutBranchesInput = {
    where: vehiclesScalarWhereInput
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyWithoutBranchesInput>
  }

  export type vehiclesScalarWhereInput = {
    AND?: vehiclesScalarWhereInput | vehiclesScalarWhereInput[]
    OR?: vehiclesScalarWhereInput[]
    NOT?: vehiclesScalarWhereInput | vehiclesScalarWhereInput[]
    id?: UuidFilter<"vehicles"> | string
    created_at?: DateTimeFilter<"vehicles"> | Date | string
    updated_at?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    make?: StringFilter<"vehicles"> | string
    model?: StringFilter<"vehicles"> | string
    year?: IntNullableFilter<"vehicles"> | number | null
    license_plate?: StringFilter<"vehicles"> | string
    status?: StringFilter<"vehicles"> | string
    branch_id?: UuidNullableFilter<"vehicles"> | string | null
    color?: StringNullableFilter<"vehicles"> | string | null
    vin?: StringNullableFilter<"vehicles"> | string | null
    purchase_date?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    last_maintenance_date?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    mileage?: IntNullableFilter<"vehicles"> | number | null
    fuel_type?: StringNullableFilter<"vehicles"> | string | null
    insurance_info?: JsonNullableFilter<"vehicles">
    technical_specs?: JsonNullableFilter<"vehicles">
  }

  export type productsCreateWithoutCategoriesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutProductsInput
    branches?: branchesCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutCategoriesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    branch_id?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutCategoriesInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput>
  }

  export type productsCreateManyCategoriesInputEnvelope = {
    data: productsCreateManyCategoriesInput | productsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type productsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutCategoriesInput, productsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<productsCreateWithoutCategoriesInput, productsUncheckedCreateWithoutCategoriesInput>
  }

  export type productsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutCategoriesInput, productsUncheckedUpdateWithoutCategoriesInput>
  }

  export type productsUpdateManyWithWhereWithoutCategoriesInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type branchesCreateWithoutCompaniesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutCompaniesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutCompaniesInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutCompaniesInput, branchesUncheckedCreateWithoutCompaniesInput>
  }

  export type branchesCreateManyCompaniesInputEnvelope = {
    data: branchesCreateManyCompaniesInput | branchesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type branchesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: branchesWhereUniqueInput
    update: XOR<branchesUpdateWithoutCompaniesInput, branchesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<branchesCreateWithoutCompaniesInput, branchesUncheckedCreateWithoutCompaniesInput>
  }

  export type branchesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: branchesWhereUniqueInput
    data: XOR<branchesUpdateWithoutCompaniesInput, branchesUncheckedUpdateWithoutCompaniesInput>
  }

  export type branchesUpdateManyWithWhereWithoutCompaniesInput = {
    where: branchesScalarWhereInput
    data: XOR<branchesUpdateManyMutationInput, branchesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type branchesScalarWhereInput = {
    AND?: branchesScalarWhereInput | branchesScalarWhereInput[]
    OR?: branchesScalarWhereInput[]
    NOT?: branchesScalarWhereInput | branchesScalarWhereInput[]
    id?: UuidFilter<"branches"> | string
    created_at?: DateTimeFilter<"branches"> | Date | string
    updated_at?: DateTimeNullableFilter<"branches"> | Date | string | null
    name?: StringFilter<"branches"> | string
    address?: StringNullableFilter<"branches"> | string | null
    province?: StringNullableFilter<"branches"> | string | null
    city?: StringNullableFilter<"branches"> | string | null
    postal_code?: StringNullableFilter<"branches"> | string | null
    phone?: StringNullableFilter<"branches"> | string | null
    email?: StringNullableFilter<"branches"> | string | null
    is_active?: BoolNullableFilter<"branches"> | boolean | null
    prefix?: StringNullableFilter<"branches"> | string | null
    company_id?: UuidFilter<"branches"> | string
    manager_name?: StringNullableFilter<"branches"> | string | null
    opening_hours?: JsonNullableFilter<"branches">
    timezone?: StringNullableFilter<"branches"> | string | null
  }

  export type email_templatesCreateWithoutEmail_campaignsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject?: string | null
    body?: string | null
    html_body?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    category?: string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean | null
    version?: number | null
    operators?: operatorsCreateNestedOneWithoutEmail_templatesInput
  }

  export type email_templatesUncheckedCreateWithoutEmail_campaignsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject?: string | null
    body?: string | null
    html_body?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    operator_id?: string | null
    category?: string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean | null
    version?: number | null
  }

  export type email_templatesCreateOrConnectWithoutEmail_campaignsInput = {
    where: email_templatesWhereUniqueInput
    create: XOR<email_templatesCreateWithoutEmail_campaignsInput, email_templatesUncheckedCreateWithoutEmail_campaignsInput>
  }

  export type usersCreateWithoutEmail_campaignsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutEmail_campaignsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutEmail_campaignsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutEmail_campaignsInput, usersUncheckedCreateWithoutEmail_campaignsInput>
  }

  export type email_templatesUpsertWithoutEmail_campaignsInput = {
    update: XOR<email_templatesUpdateWithoutEmail_campaignsInput, email_templatesUncheckedUpdateWithoutEmail_campaignsInput>
    create: XOR<email_templatesCreateWithoutEmail_campaignsInput, email_templatesUncheckedCreateWithoutEmail_campaignsInput>
    where?: email_templatesWhereInput
  }

  export type email_templatesUpdateToOneWithWhereWithoutEmail_campaignsInput = {
    where?: email_templatesWhereInput
    data: XOR<email_templatesUpdateWithoutEmail_campaignsInput, email_templatesUncheckedUpdateWithoutEmail_campaignsInput>
  }

  export type email_templatesUpdateWithoutEmail_campaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    operators?: operatorsUpdateOneWithoutEmail_templatesNestedInput
  }

  export type email_templatesUncheckedUpdateWithoutEmail_campaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersUpsertWithoutEmail_campaignsInput = {
    update: XOR<usersUpdateWithoutEmail_campaignsInput, usersUncheckedUpdateWithoutEmail_campaignsInput>
    create: XOR<usersCreateWithoutEmail_campaignsInput, usersUncheckedCreateWithoutEmail_campaignsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutEmail_campaignsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutEmail_campaignsInput, usersUncheckedUpdateWithoutEmail_campaignsInput>
  }

  export type usersUpdateWithoutEmail_campaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutEmail_campaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type email_campaignsCreateWithoutEmail_templatesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
    users?: usersCreateNestedOneWithoutEmail_campaignsInput
  }

  export type email_campaignsUncheckedCreateWithoutEmail_templatesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    user_id?: string | null
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsCreateOrConnectWithoutEmail_templatesInput = {
    where: email_campaignsWhereUniqueInput
    create: XOR<email_campaignsCreateWithoutEmail_templatesInput, email_campaignsUncheckedCreateWithoutEmail_templatesInput>
  }

  export type email_campaignsCreateManyEmail_templatesInputEnvelope = {
    data: email_campaignsCreateManyEmail_templatesInput | email_campaignsCreateManyEmail_templatesInput[]
    skipDuplicates?: boolean
  }

  export type operatorsCreateWithoutEmail_templatesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorCreateNestedManyWithoutOperatorsInput
    branches: branchesCreateNestedOneWithoutOperatorsInput
    operator_types: operator_typesCreateNestedOneWithoutOperatorsInput
    packages?: packagesCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsUncheckedCreateWithoutEmail_templatesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorUncheckedCreateNestedManyWithoutOperatorsInput
    packages?: packagesUncheckedCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsCreateOrConnectWithoutEmail_templatesInput = {
    where: operatorsWhereUniqueInput
    create: XOR<operatorsCreateWithoutEmail_templatesInput, operatorsUncheckedCreateWithoutEmail_templatesInput>
  }

  export type email_campaignsUpsertWithWhereUniqueWithoutEmail_templatesInput = {
    where: email_campaignsWhereUniqueInput
    update: XOR<email_campaignsUpdateWithoutEmail_templatesInput, email_campaignsUncheckedUpdateWithoutEmail_templatesInput>
    create: XOR<email_campaignsCreateWithoutEmail_templatesInput, email_campaignsUncheckedCreateWithoutEmail_templatesInput>
  }

  export type email_campaignsUpdateWithWhereUniqueWithoutEmail_templatesInput = {
    where: email_campaignsWhereUniqueInput
    data: XOR<email_campaignsUpdateWithoutEmail_templatesInput, email_campaignsUncheckedUpdateWithoutEmail_templatesInput>
  }

  export type email_campaignsUpdateManyWithWhereWithoutEmail_templatesInput = {
    where: email_campaignsScalarWhereInput
    data: XOR<email_campaignsUpdateManyMutationInput, email_campaignsUncheckedUpdateManyWithoutEmail_templatesInput>
  }

  export type email_campaignsScalarWhereInput = {
    AND?: email_campaignsScalarWhereInput | email_campaignsScalarWhereInput[]
    OR?: email_campaignsScalarWhereInput[]
    NOT?: email_campaignsScalarWhereInput | email_campaignsScalarWhereInput[]
    id?: UuidFilter<"email_campaigns"> | string
    created_at?: DateTimeFilter<"email_campaigns"> | Date | string
    updated_at?: DateTimeNullableFilter<"email_campaigns"> | Date | string | null
    name?: StringFilter<"email_campaigns"> | string
    subject?: StringFilter<"email_campaigns"> | string
    status?: StringFilter<"email_campaigns"> | string
    recipients?: JsonNullableFilter<"email_campaigns">
    send_to_all?: BoolNullableFilter<"email_campaigns"> | boolean | null
    tracking?: BoolNullableFilter<"email_campaigns"> | boolean | null
    tracking_id?: UuidNullableFilter<"email_campaigns"> | string | null
    stats?: JsonNullableFilter<"email_campaigns">
    user_id?: UuidNullableFilter<"email_campaigns"> | string | null
    template_id?: UuidNullableFilter<"email_campaigns"> | string | null
    scheduled_for?: DateTimeNullableFilter<"email_campaigns"> | Date | string | null
    sender_name?: StringNullableFilter<"email_campaigns"> | string | null
    sender_email?: StringNullableFilter<"email_campaigns"> | string | null
    reply_to?: StringNullableFilter<"email_campaigns"> | string | null
    segment_criteria?: JsonNullableFilter<"email_campaigns">
    test_recipients?: StringNullableListFilter<"email_campaigns">
    is_recurring?: BoolNullableFilter<"email_campaigns"> | boolean | null
    recurrence_pattern?: JsonNullableFilter<"email_campaigns">
  }

  export type operatorsUpsertWithoutEmail_templatesInput = {
    update: XOR<operatorsUpdateWithoutEmail_templatesInput, operatorsUncheckedUpdateWithoutEmail_templatesInput>
    create: XOR<operatorsCreateWithoutEmail_templatesInput, operatorsUncheckedCreateWithoutEmail_templatesInput>
    where?: operatorsWhereInput
  }

  export type operatorsUpdateToOneWithWhereWithoutEmail_templatesInput = {
    where?: operatorsWhereInput
    data: XOR<operatorsUpdateWithoutEmail_templatesInput, operatorsUncheckedUpdateWithoutEmail_templatesInput>
  }

  export type operatorsUpdateWithoutEmail_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUpdateManyWithoutOperatorsNestedInput
    branches?: branchesUpdateOneRequiredWithoutOperatorsNestedInput
    operator_types?: operator_typesUpdateOneRequiredWithoutOperatorsNestedInput
    packages?: packagesUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateWithoutEmail_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUncheckedUpdateManyWithoutOperatorsNestedInput
    packages?: packagesUncheckedUpdateManyWithoutOperatorsNestedInput
  }

  export type branchesCreateWithoutGift_cardsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutGift_cardsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutGift_cardsInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutGift_cardsInput, branchesUncheckedCreateWithoutGift_cardsInput>
  }

  export type branchesUpsertWithoutGift_cardsInput = {
    update: XOR<branchesUpdateWithoutGift_cardsInput, branchesUncheckedUpdateWithoutGift_cardsInput>
    create: XOR<branchesCreateWithoutGift_cardsInput, branchesUncheckedCreateWithoutGift_cardsInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutGift_cardsInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutGift_cardsInput, branchesUncheckedUpdateWithoutGift_cardsInput>
  }

  export type branchesUpdateWithoutGift_cardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutGift_cardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type invoicesCreateWithoutInvoice_itemsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_packages?: invoice_packagesCreateNestedManyWithoutInvoicesInput
    branches?: branchesCreateNestedOneWithoutInvoicesInput
    operators?: operatorsCreateNestedOneWithoutInvoicesInput
    users?: usersCreateNestedOneWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutInvoice_itemsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    branch_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutInvoicesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutInvoice_itemsInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutInvoice_itemsInput, invoicesUncheckedCreateWithoutInvoice_itemsInput>
  }

  export type plansCreateWithoutInvoice_itemsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    plan_addresses?: plan_addressesCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresCreateNestedManyWithoutPlansInput
    branches?: branchesCreateNestedOneWithoutPlansInput
    users?: usersCreateNestedManyWithoutPlansInput
  }

  export type plansUncheckedCreateWithoutInvoice_itemsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    branch_id?: string | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    plan_addresses?: plan_addressesUncheckedCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresUncheckedCreateNestedManyWithoutPlansInput
    users?: usersUncheckedCreateNestedManyWithoutPlansInput
  }

  export type plansCreateOrConnectWithoutInvoice_itemsInput = {
    where: plansWhereUniqueInput
    create: XOR<plansCreateWithoutInvoice_itemsInput, plansUncheckedCreateWithoutInvoice_itemsInput>
  }

  export type productsCreateWithoutInvoice_itemsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    branches?: branchesCreateNestedOneWithoutProductsInput
    categories?: categoriesCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutInvoice_itemsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    category_id?: string | null
    branch_id?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
  }

  export type productsCreateOrConnectWithoutInvoice_itemsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutInvoice_itemsInput, productsUncheckedCreateWithoutInvoice_itemsInput>
  }

  export type invoicesUpsertWithoutInvoice_itemsInput = {
    update: XOR<invoicesUpdateWithoutInvoice_itemsInput, invoicesUncheckedUpdateWithoutInvoice_itemsInput>
    create: XOR<invoicesCreateWithoutInvoice_itemsInput, invoicesUncheckedCreateWithoutInvoice_itemsInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutInvoice_itemsInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutInvoice_itemsInput, invoicesUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type invoicesUpdateWithoutInvoice_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_packages?: invoice_packagesUpdateManyWithoutInvoicesNestedInput
    branches?: branchesUpdateOneWithoutInvoicesNestedInput
    operators?: operatorsUpdateOneWithoutInvoicesNestedInput
    users?: usersUpdateOneWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutInvoice_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type plansUpsertWithoutInvoice_itemsInput = {
    update: XOR<plansUpdateWithoutInvoice_itemsInput, plansUncheckedUpdateWithoutInvoice_itemsInput>
    create: XOR<plansCreateWithoutInvoice_itemsInput, plansUncheckedCreateWithoutInvoice_itemsInput>
    where?: plansWhereInput
  }

  export type plansUpdateToOneWithWhereWithoutInvoice_itemsInput = {
    where?: plansWhereInput
    data: XOR<plansUpdateWithoutInvoice_itemsInput, plansUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type plansUpdateWithoutInvoice_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    plan_addresses?: plan_addressesUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUpdateManyWithoutPlansNestedInput
    branches?: branchesUpdateOneWithoutPlansNestedInput
    users?: usersUpdateManyWithoutPlansNestedInput
  }

  export type plansUncheckedUpdateWithoutInvoice_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    plan_addresses?: plan_addressesUncheckedUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUncheckedUpdateManyWithoutPlansNestedInput
    users?: usersUncheckedUpdateManyWithoutPlansNestedInput
  }

  export type productsUpsertWithoutInvoice_itemsInput = {
    update: XOR<productsUpdateWithoutInvoice_itemsInput, productsUncheckedUpdateWithoutInvoice_itemsInput>
    create: XOR<productsCreateWithoutInvoice_itemsInput, productsUncheckedCreateWithoutInvoice_itemsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutInvoice_itemsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutInvoice_itemsInput, productsUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type productsUpdateWithoutInvoice_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    branches?: branchesUpdateOneWithoutProductsNestedInput
    categories?: categoriesUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutInvoice_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type invoicesCreateWithoutInvoice_packagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
    branches?: branchesCreateNestedOneWithoutInvoicesInput
    operators?: operatorsCreateNestedOneWithoutInvoicesInput
    users?: usersCreateNestedOneWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutInvoice_packagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    branch_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutInvoice_packagesInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutInvoice_packagesInput, invoicesUncheckedCreateWithoutInvoice_packagesInput>
  }

  export type packagesCreateWithoutInvoice_packagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    position?: string | null
    branches?: branchesCreateNestedOneWithoutPackagesInput
    users?: usersCreateNestedOneWithoutPackagesInput
    operators?: operatorsCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateWithoutInvoice_packagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_reference?: string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    branch_id?: string | null
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    operator_id?: string | null
    position?: string | null
  }

  export type packagesCreateOrConnectWithoutInvoice_packagesInput = {
    where: packagesWhereUniqueInput
    create: XOR<packagesCreateWithoutInvoice_packagesInput, packagesUncheckedCreateWithoutInvoice_packagesInput>
  }

  export type invoicesUpsertWithoutInvoice_packagesInput = {
    update: XOR<invoicesUpdateWithoutInvoice_packagesInput, invoicesUncheckedUpdateWithoutInvoice_packagesInput>
    create: XOR<invoicesCreateWithoutInvoice_packagesInput, invoicesUncheckedCreateWithoutInvoice_packagesInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutInvoice_packagesInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutInvoice_packagesInput, invoicesUncheckedUpdateWithoutInvoice_packagesInput>
  }

  export type invoicesUpdateWithoutInvoice_packagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
    branches?: branchesUpdateOneWithoutInvoicesNestedInput
    operators?: operatorsUpdateOneWithoutInvoicesNestedInput
    users?: usersUpdateOneWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutInvoice_packagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type packagesUpsertWithoutInvoice_packagesInput = {
    update: XOR<packagesUpdateWithoutInvoice_packagesInput, packagesUncheckedUpdateWithoutInvoice_packagesInput>
    create: XOR<packagesCreateWithoutInvoice_packagesInput, packagesUncheckedCreateWithoutInvoice_packagesInput>
    where?: packagesWhereInput
  }

  export type packagesUpdateToOneWithWhereWithoutInvoice_packagesInput = {
    where?: packagesWhereInput
    data: XOR<packagesUpdateWithoutInvoice_packagesInput, packagesUncheckedUpdateWithoutInvoice_packagesInput>
  }

  export type packagesUpdateWithoutInvoice_packagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    branches?: branchesUpdateOneWithoutPackagesNestedInput
    users?: usersUpdateOneWithoutPackagesNestedInput
    operators?: operatorsUpdateOneWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateWithoutInvoice_packagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_reference?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoice_itemsCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
    plans?: plansCreateNestedOneWithoutInvoice_itemsInput
    products?: productsCreateNestedOneWithoutInvoice_itemsInput
  }

  export type invoice_itemsUncheckedCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    product_id?: string | null
    plan_id?: string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
  }

  export type invoice_itemsCreateOrConnectWithoutInvoicesInput = {
    where: invoice_itemsWhereUniqueInput
    create: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput>
  }

  export type invoice_itemsCreateManyInvoicesInputEnvelope = {
    data: invoice_itemsCreateManyInvoicesInput | invoice_itemsCreateManyInvoicesInput[]
    skipDuplicates?: boolean
  }

  export type invoice_packagesCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    packages: packagesCreateNestedOneWithoutInvoice_packagesInput
  }

  export type invoice_packagesUncheckedCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_id: string
  }

  export type invoice_packagesCreateOrConnectWithoutInvoicesInput = {
    where: invoice_packagesWhereUniqueInput
    create: XOR<invoice_packagesCreateWithoutInvoicesInput, invoice_packagesUncheckedCreateWithoutInvoicesInput>
  }

  export type invoice_packagesCreateManyInvoicesInputEnvelope = {
    data: invoice_packagesCreateManyInvoicesInput | invoice_packagesCreateManyInvoicesInput[]
    skipDuplicates?: boolean
  }

  export type branchesCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutInvoicesInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutInvoicesInput, branchesUncheckedCreateWithoutInvoicesInput>
  }

  export type operatorsCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorCreateNestedManyWithoutOperatorsInput
    branches: branchesCreateNestedOneWithoutOperatorsInput
    operator_types: operator_typesCreateNestedOneWithoutOperatorsInput
    packages?: packagesCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsUncheckedCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesUncheckedCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorUncheckedCreateNestedManyWithoutOperatorsInput
    packages?: packagesUncheckedCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsCreateOrConnectWithoutInvoicesInput = {
    where: operatorsWhereUniqueInput
    create: XOR<operatorsCreateWithoutInvoicesInput, operatorsUncheckedCreateWithoutInvoicesInput>
  }

  export type usersCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutInvoicesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput>
  }

  export type paymentsCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    payment_methods?: payment_methodsCreateNestedOneWithoutPaymentsInput
    transactions?: transactionsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    transaction_id?: string | null
    payment_method_id?: string | null
  }

  export type paymentsCreateOrConnectWithoutInvoicesInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput>
  }

  export type paymentsCreateManyInvoicesInputEnvelope = {
    data: paymentsCreateManyInvoicesInput | paymentsCreateManyInvoicesInput[]
    skipDuplicates?: boolean
  }

  export type invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: invoice_itemsWhereUniqueInput
    update: XOR<invoice_itemsUpdateWithoutInvoicesInput, invoice_itemsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput>
  }

  export type invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: invoice_itemsWhereUniqueInput
    data: XOR<invoice_itemsUpdateWithoutInvoicesInput, invoice_itemsUncheckedUpdateWithoutInvoicesInput>
  }

  export type invoice_itemsUpdateManyWithWhereWithoutInvoicesInput = {
    where: invoice_itemsScalarWhereInput
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type invoice_itemsScalarWhereInput = {
    AND?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
    OR?: invoice_itemsScalarWhereInput[]
    NOT?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
    id?: UuidFilter<"invoice_items"> | string
    created_at?: DateTimeFilter<"invoice_items"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoice_items"> | Date | string | null
    invoice_id?: UuidFilter<"invoice_items"> | string
    product_id?: UuidNullableFilter<"invoice_items"> | string | null
    plan_id?: UuidNullableFilter<"invoice_items"> | string | null
    description?: StringFilter<"invoice_items"> | string
    quantity?: IntFilter<"invoice_items"> | number
    unit_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    discount_rate?: DecimalNullableFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string | null
    tax_rate?: DecimalNullableFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string | null
    item_order?: IntNullableFilter<"invoice_items"> | number | null
    unit_of_measure?: StringNullableFilter<"invoice_items"> | string | null
    is_taxable?: BoolNullableFilter<"invoice_items"> | boolean | null
    serial_numbers?: StringNullableListFilter<"invoice_items">
  }

  export type invoice_packagesUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: invoice_packagesWhereUniqueInput
    update: XOR<invoice_packagesUpdateWithoutInvoicesInput, invoice_packagesUncheckedUpdateWithoutInvoicesInput>
    create: XOR<invoice_packagesCreateWithoutInvoicesInput, invoice_packagesUncheckedCreateWithoutInvoicesInput>
  }

  export type invoice_packagesUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: invoice_packagesWhereUniqueInput
    data: XOR<invoice_packagesUpdateWithoutInvoicesInput, invoice_packagesUncheckedUpdateWithoutInvoicesInput>
  }

  export type invoice_packagesUpdateManyWithWhereWithoutInvoicesInput = {
    where: invoice_packagesScalarWhereInput
    data: XOR<invoice_packagesUpdateManyMutationInput, invoice_packagesUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type invoice_packagesScalarWhereInput = {
    AND?: invoice_packagesScalarWhereInput | invoice_packagesScalarWhereInput[]
    OR?: invoice_packagesScalarWhereInput[]
    NOT?: invoice_packagesScalarWhereInput | invoice_packagesScalarWhereInput[]
    id?: UuidFilter<"invoice_packages"> | string
    created_at?: DateTimeFilter<"invoice_packages"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoice_packages"> | Date | string | null
    invoice_id?: UuidFilter<"invoice_packages"> | string
    package_id?: UuidFilter<"invoice_packages"> | string
  }

  export type branchesUpsertWithoutInvoicesInput = {
    update: XOR<branchesUpdateWithoutInvoicesInput, branchesUncheckedUpdateWithoutInvoicesInput>
    create: XOR<branchesCreateWithoutInvoicesInput, branchesUncheckedCreateWithoutInvoicesInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutInvoicesInput, branchesUncheckedUpdateWithoutInvoicesInput>
  }

  export type branchesUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type operatorsUpsertWithoutInvoicesInput = {
    update: XOR<operatorsUpdateWithoutInvoicesInput, operatorsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<operatorsCreateWithoutInvoicesInput, operatorsUncheckedCreateWithoutInvoicesInput>
    where?: operatorsWhereInput
  }

  export type operatorsUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: operatorsWhereInput
    data: XOR<operatorsUpdateWithoutInvoicesInput, operatorsUncheckedUpdateWithoutInvoicesInput>
  }

  export type operatorsUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUpdateManyWithoutOperatorsNestedInput
    branches?: branchesUpdateOneRequiredWithoutOperatorsNestedInput
    operator_types?: operator_typesUpdateOneRequiredWithoutOperatorsNestedInput
    packages?: packagesUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUncheckedUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUncheckedUpdateManyWithoutOperatorsNestedInput
    packages?: packagesUncheckedUpdateManyWithoutOperatorsNestedInput
  }

  export type usersUpsertWithoutInvoicesInput = {
    update: XOR<usersUpdateWithoutInvoicesInput, usersUncheckedUpdateWithoutInvoicesInput>
    create: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutInvoicesInput, usersUncheckedUpdateWithoutInvoicesInput>
  }

  export type usersUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type paymentsUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutInvoicesInput, paymentsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutInvoicesInput, paymentsUncheckedUpdateWithoutInvoicesInput>
  }

  export type paymentsUpdateManyWithWhereWithoutInvoicesInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: UuidFilter<"payments"> | string
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    invoice_id?: UuidFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: Enumpayment_method_enumFilter<"payments"> | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFilter<"payments"> | $Enums.payment_status_enum
    payment_provider?: StringNullableFilter<"payments"> | string | null
    currency?: StringNullableFilter<"payments"> | string | null
    exchange_rate?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    fees?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    payer_details?: JsonNullableFilter<"payments">
    receipt_url?: StringNullableFilter<"payments"> | string | null
    notes?: StringNullableFilter<"payments"> | string | null
    transaction_id?: UuidNullableFilter<"payments"> | string | null
    payment_method_id?: UuidNullableFilter<"payments"> | string | null
  }

  export type usersCreateWithoutNotification_preferencesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotification_preferencesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotification_preferencesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotification_preferencesInput, usersUncheckedCreateWithoutNotification_preferencesInput>
  }

  export type usersUpsertWithoutNotification_preferencesInput = {
    update: XOR<usersUpdateWithoutNotification_preferencesInput, usersUncheckedUpdateWithoutNotification_preferencesInput>
    create: XOR<usersCreateWithoutNotification_preferencesInput, usersUncheckedCreateWithoutNotification_preferencesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotification_preferencesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotification_preferencesInput, usersUncheckedUpdateWithoutNotification_preferencesInput>
  }

  export type usersUpdateWithoutNotification_preferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotification_preferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutNotification_usersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotification_usersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotification_usersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotification_usersInput, usersUncheckedCreateWithoutNotification_usersInput>
  }

  export type usersUpsertWithoutNotification_usersInput = {
    update: XOR<usersUpdateWithoutNotification_usersInput, usersUncheckedUpdateWithoutNotification_usersInput>
    create: XOR<usersCreateWithoutNotification_usersInput, usersUncheckedCreateWithoutNotification_usersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotification_usersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotification_usersInput, usersUncheckedUpdateWithoutNotification_usersInput>
  }

  export type usersUpdateWithoutNotification_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotification_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type operatorsCreateWithoutNotifications_operatorInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesCreateNestedManyWithoutOperatorsInput
    branches: branchesCreateNestedOneWithoutOperatorsInput
    operator_types: operator_typesCreateNestedOneWithoutOperatorsInput
    packages?: packagesCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsUncheckedCreateWithoutNotifications_operatorInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesUncheckedCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutOperatorsInput
    packages?: packagesUncheckedCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsCreateOrConnectWithoutNotifications_operatorInput = {
    where: operatorsWhereUniqueInput
    create: XOR<operatorsCreateWithoutNotifications_operatorInput, operatorsUncheckedCreateWithoutNotifications_operatorInput>
  }

  export type operatorsUpsertWithoutNotifications_operatorInput = {
    update: XOR<operatorsUpdateWithoutNotifications_operatorInput, operatorsUncheckedUpdateWithoutNotifications_operatorInput>
    create: XOR<operatorsCreateWithoutNotifications_operatorInput, operatorsUncheckedCreateWithoutNotifications_operatorInput>
    where?: operatorsWhereInput
  }

  export type operatorsUpdateToOneWithWhereWithoutNotifications_operatorInput = {
    where?: operatorsWhereInput
    data: XOR<operatorsUpdateWithoutNotifications_operatorInput, operatorsUncheckedUpdateWithoutNotifications_operatorInput>
  }

  export type operatorsUpdateWithoutNotifications_operatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUpdateManyWithoutOperatorsNestedInput
    branches?: branchesUpdateOneRequiredWithoutOperatorsNestedInput
    operator_types?: operator_typesUpdateOneRequiredWithoutOperatorsNestedInput
    packages?: packagesUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateWithoutNotifications_operatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUncheckedUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutOperatorsNestedInput
    packages?: packagesUncheckedUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsCreateWithoutOperator_typesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorCreateNestedManyWithoutOperatorsInput
    branches: branchesCreateNestedOneWithoutOperatorsInput
    packages?: packagesCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsUncheckedCreateWithoutOperator_typesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesUncheckedCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorUncheckedCreateNestedManyWithoutOperatorsInput
    packages?: packagesUncheckedCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsCreateOrConnectWithoutOperator_typesInput = {
    where: operatorsWhereUniqueInput
    create: XOR<operatorsCreateWithoutOperator_typesInput, operatorsUncheckedCreateWithoutOperator_typesInput>
  }

  export type operatorsCreateManyOperator_typesInputEnvelope = {
    data: operatorsCreateManyOperator_typesInput | operatorsCreateManyOperator_typesInput[]
    skipDuplicates?: boolean
  }

  export type operatorsUpsertWithWhereUniqueWithoutOperator_typesInput = {
    where: operatorsWhereUniqueInput
    update: XOR<operatorsUpdateWithoutOperator_typesInput, operatorsUncheckedUpdateWithoutOperator_typesInput>
    create: XOR<operatorsCreateWithoutOperator_typesInput, operatorsUncheckedCreateWithoutOperator_typesInput>
  }

  export type operatorsUpdateWithWhereUniqueWithoutOperator_typesInput = {
    where: operatorsWhereUniqueInput
    data: XOR<operatorsUpdateWithoutOperator_typesInput, operatorsUncheckedUpdateWithoutOperator_typesInput>
  }

  export type operatorsUpdateManyWithWhereWithoutOperator_typesInput = {
    where: operatorsScalarWhereInput
    data: XOR<operatorsUpdateManyMutationInput, operatorsUncheckedUpdateManyWithoutOperator_typesInput>
  }

  export type activitiesCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    branches?: branchesCreateNestedOneWithoutActivitiesInput
  }

  export type activitiesUncheckedCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    branch_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesCreateOrConnectWithoutOperatorsInput = {
    where: activitiesWhereUniqueInput
    create: XOR<activitiesCreateWithoutOperatorsInput, activitiesUncheckedCreateWithoutOperatorsInput>
  }

  export type activitiesCreateManyOperatorsInputEnvelope = {
    data: activitiesCreateManyOperatorsInput | activitiesCreateManyOperatorsInput[]
    skipDuplicates?: boolean
  }

  export type email_templatesCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject?: string | null
    body?: string | null
    html_body?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    category?: string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean | null
    version?: number | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutEmail_templatesInput
  }

  export type email_templatesUncheckedCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject?: string | null
    body?: string | null
    html_body?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    category?: string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean | null
    version?: number | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutEmail_templatesInput
  }

  export type email_templatesCreateOrConnectWithoutOperatorsInput = {
    where: email_templatesWhereUniqueInput
    create: XOR<email_templatesCreateWithoutOperatorsInput, email_templatesUncheckedCreateWithoutOperatorsInput>
  }

  export type email_templatesCreateManyOperatorsInputEnvelope = {
    data: email_templatesCreateManyOperatorsInput | email_templatesCreateManyOperatorsInput[]
    skipDuplicates?: boolean
  }

  export type invoicesCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesCreateNestedManyWithoutInvoicesInput
    branches?: branchesCreateNestedOneWithoutInvoicesInput
    users?: usersCreateNestedOneWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    branch_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutInvoicesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutOperatorsInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutOperatorsInput, invoicesUncheckedCreateWithoutOperatorsInput>
  }

  export type invoicesCreateManyOperatorsInputEnvelope = {
    data: invoicesCreateManyOperatorsInput | invoicesCreateManyOperatorsInput[]
    skipDuplicates?: boolean
  }

  export type notifications_operatorCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: string | null
    priority?: string | null
    action_required?: boolean | null
    action_type?: string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: Date | string | null
  }

  export type notifications_operatorUncheckedCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: string | null
    priority?: string | null
    action_required?: boolean | null
    action_type?: string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: Date | string | null
  }

  export type notifications_operatorCreateOrConnectWithoutOperatorsInput = {
    where: notifications_operatorWhereUniqueInput
    create: XOR<notifications_operatorCreateWithoutOperatorsInput, notifications_operatorUncheckedCreateWithoutOperatorsInput>
  }

  export type notifications_operatorCreateManyOperatorsInputEnvelope = {
    data: notifications_operatorCreateManyOperatorsInput | notifications_operatorCreateManyOperatorsInput[]
    skipDuplicates?: boolean
  }

  export type branchesCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutOperatorsInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutOperatorsInput, branchesUncheckedCreateWithoutOperatorsInput>
  }

  export type operator_typesCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type operator_typesUncheckedCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type operator_typesCreateOrConnectWithoutOperatorsInput = {
    where: operator_typesWhereUniqueInput
    create: XOR<operator_typesCreateWithoutOperatorsInput, operator_typesUncheckedCreateWithoutOperatorsInput>
  }

  export type packagesCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    position?: string | null
    invoice_packages?: invoice_packagesCreateNestedManyWithoutPackagesInput
    branches?: branchesCreateNestedOneWithoutPackagesInput
    users?: usersCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateWithoutOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_reference?: string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    branch_id?: string | null
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    position?: string | null
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutPackagesInput
  }

  export type packagesCreateOrConnectWithoutOperatorsInput = {
    where: packagesWhereUniqueInput
    create: XOR<packagesCreateWithoutOperatorsInput, packagesUncheckedCreateWithoutOperatorsInput>
  }

  export type packagesCreateManyOperatorsInputEnvelope = {
    data: packagesCreateManyOperatorsInput | packagesCreateManyOperatorsInput[]
    skipDuplicates?: boolean
  }

  export type activitiesUpsertWithWhereUniqueWithoutOperatorsInput = {
    where: activitiesWhereUniqueInput
    update: XOR<activitiesUpdateWithoutOperatorsInput, activitiesUncheckedUpdateWithoutOperatorsInput>
    create: XOR<activitiesCreateWithoutOperatorsInput, activitiesUncheckedCreateWithoutOperatorsInput>
  }

  export type activitiesUpdateWithWhereUniqueWithoutOperatorsInput = {
    where: activitiesWhereUniqueInput
    data: XOR<activitiesUpdateWithoutOperatorsInput, activitiesUncheckedUpdateWithoutOperatorsInput>
  }

  export type activitiesUpdateManyWithWhereWithoutOperatorsInput = {
    where: activitiesScalarWhereInput
    data: XOR<activitiesUpdateManyMutationInput, activitiesUncheckedUpdateManyWithoutOperatorsInput>
  }

  export type email_templatesUpsertWithWhereUniqueWithoutOperatorsInput = {
    where: email_templatesWhereUniqueInput
    update: XOR<email_templatesUpdateWithoutOperatorsInput, email_templatesUncheckedUpdateWithoutOperatorsInput>
    create: XOR<email_templatesCreateWithoutOperatorsInput, email_templatesUncheckedCreateWithoutOperatorsInput>
  }

  export type email_templatesUpdateWithWhereUniqueWithoutOperatorsInput = {
    where: email_templatesWhereUniqueInput
    data: XOR<email_templatesUpdateWithoutOperatorsInput, email_templatesUncheckedUpdateWithoutOperatorsInput>
  }

  export type email_templatesUpdateManyWithWhereWithoutOperatorsInput = {
    where: email_templatesScalarWhereInput
    data: XOR<email_templatesUpdateManyMutationInput, email_templatesUncheckedUpdateManyWithoutOperatorsInput>
  }

  export type email_templatesScalarWhereInput = {
    AND?: email_templatesScalarWhereInput | email_templatesScalarWhereInput[]
    OR?: email_templatesScalarWhereInput[]
    NOT?: email_templatesScalarWhereInput | email_templatesScalarWhereInput[]
    id?: UuidFilter<"email_templates"> | string
    created_at?: DateTimeFilter<"email_templates"> | Date | string
    updated_at?: DateTimeNullableFilter<"email_templates"> | Date | string | null
    name?: StringFilter<"email_templates"> | string
    subject?: StringNullableFilter<"email_templates"> | string | null
    body?: StringNullableFilter<"email_templates"> | string | null
    html_body?: StringNullableFilter<"email_templates"> | string | null
    elements?: JsonNullableFilter<"email_templates">
    editor_settings?: JsonNullableFilter<"email_templates">
    thumbnail?: StringNullableFilter<"email_templates"> | string | null
    operator_id?: UuidNullableFilter<"email_templates"> | string | null
    category?: StringNullableFilter<"email_templates"> | string | null
    variables?: JsonNullableFilter<"email_templates">
    is_default?: BoolNullableFilter<"email_templates"> | boolean | null
    version?: IntNullableFilter<"email_templates"> | number | null
  }

  export type invoicesUpsertWithWhereUniqueWithoutOperatorsInput = {
    where: invoicesWhereUniqueInput
    update: XOR<invoicesUpdateWithoutOperatorsInput, invoicesUncheckedUpdateWithoutOperatorsInput>
    create: XOR<invoicesCreateWithoutOperatorsInput, invoicesUncheckedCreateWithoutOperatorsInput>
  }

  export type invoicesUpdateWithWhereUniqueWithoutOperatorsInput = {
    where: invoicesWhereUniqueInput
    data: XOR<invoicesUpdateWithoutOperatorsInput, invoicesUncheckedUpdateWithoutOperatorsInput>
  }

  export type invoicesUpdateManyWithWhereWithoutOperatorsInput = {
    where: invoicesScalarWhereInput
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyWithoutOperatorsInput>
  }

  export type notifications_operatorUpsertWithWhereUniqueWithoutOperatorsInput = {
    where: notifications_operatorWhereUniqueInput
    update: XOR<notifications_operatorUpdateWithoutOperatorsInput, notifications_operatorUncheckedUpdateWithoutOperatorsInput>
    create: XOR<notifications_operatorCreateWithoutOperatorsInput, notifications_operatorUncheckedCreateWithoutOperatorsInput>
  }

  export type notifications_operatorUpdateWithWhereUniqueWithoutOperatorsInput = {
    where: notifications_operatorWhereUniqueInput
    data: XOR<notifications_operatorUpdateWithoutOperatorsInput, notifications_operatorUncheckedUpdateWithoutOperatorsInput>
  }

  export type notifications_operatorUpdateManyWithWhereWithoutOperatorsInput = {
    where: notifications_operatorScalarWhereInput
    data: XOR<notifications_operatorUpdateManyMutationInput, notifications_operatorUncheckedUpdateManyWithoutOperatorsInput>
  }

  export type notifications_operatorScalarWhereInput = {
    AND?: notifications_operatorScalarWhereInput | notifications_operatorScalarWhereInput[]
    OR?: notifications_operatorScalarWhereInput[]
    NOT?: notifications_operatorScalarWhereInput | notifications_operatorScalarWhereInput[]
    id?: UuidFilter<"notifications_operator"> | string
    created_at?: DateTimeFilter<"notifications_operator"> | Date | string
    updated_at?: DateTimeNullableFilter<"notifications_operator"> | Date | string | null
    title?: StringFilter<"notifications_operator"> | string
    message?: StringFilter<"notifications_operator"> | string
    is_read?: BoolNullableFilter<"notifications_operator"> | boolean | null
    operator_id?: UuidFilter<"notifications_operator"> | string
    data?: JsonNullableFilter<"notifications_operator">
    notification_type?: StringNullableFilter<"notifications_operator"> | string | null
    priority?: StringNullableFilter<"notifications_operator"> | string | null
    action_required?: BoolNullableFilter<"notifications_operator"> | boolean | null
    action_type?: StringNullableFilter<"notifications_operator"> | string | null
    action_data?: JsonNullableFilter<"notifications_operator">
    expiry_date?: DateTimeNullableFilter<"notifications_operator"> | Date | string | null
  }

  export type branchesUpsertWithoutOperatorsInput = {
    update: XOR<branchesUpdateWithoutOperatorsInput, branchesUncheckedUpdateWithoutOperatorsInput>
    create: XOR<branchesCreateWithoutOperatorsInput, branchesUncheckedCreateWithoutOperatorsInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutOperatorsInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutOperatorsInput, branchesUncheckedUpdateWithoutOperatorsInput>
  }

  export type branchesUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type operator_typesUpsertWithoutOperatorsInput = {
    update: XOR<operator_typesUpdateWithoutOperatorsInput, operator_typesUncheckedUpdateWithoutOperatorsInput>
    create: XOR<operator_typesCreateWithoutOperatorsInput, operator_typesUncheckedCreateWithoutOperatorsInput>
    where?: operator_typesWhereInput
  }

  export type operator_typesUpdateToOneWithWhereWithoutOperatorsInput = {
    where?: operator_typesWhereInput
    data: XOR<operator_typesUpdateWithoutOperatorsInput, operator_typesUncheckedUpdateWithoutOperatorsInput>
  }

  export type operator_typesUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type operator_typesUncheckedUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type packagesUpsertWithWhereUniqueWithoutOperatorsInput = {
    where: packagesWhereUniqueInput
    update: XOR<packagesUpdateWithoutOperatorsInput, packagesUncheckedUpdateWithoutOperatorsInput>
    create: XOR<packagesCreateWithoutOperatorsInput, packagesUncheckedCreateWithoutOperatorsInput>
  }

  export type packagesUpdateWithWhereUniqueWithoutOperatorsInput = {
    where: packagesWhereUniqueInput
    data: XOR<packagesUpdateWithoutOperatorsInput, packagesUncheckedUpdateWithoutOperatorsInput>
  }

  export type packagesUpdateManyWithWhereWithoutOperatorsInput = {
    where: packagesScalarWhereInput
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyWithoutOperatorsInput>
  }

  export type invoice_packagesCreateWithoutPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoices: invoicesCreateNestedOneWithoutInvoice_packagesInput
  }

  export type invoice_packagesUncheckedCreateWithoutPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
  }

  export type invoice_packagesCreateOrConnectWithoutPackagesInput = {
    where: invoice_packagesWhereUniqueInput
    create: XOR<invoice_packagesCreateWithoutPackagesInput, invoice_packagesUncheckedCreateWithoutPackagesInput>
  }

  export type invoice_packagesCreateManyPackagesInputEnvelope = {
    data: invoice_packagesCreateManyPackagesInput | invoice_packagesCreateManyPackagesInput[]
    skipDuplicates?: boolean
  }

  export type branchesCreateWithoutPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutPackagesInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutPackagesInput, branchesUncheckedCreateWithoutPackagesInput>
  }

  export type usersCreateWithoutPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPackagesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPackagesInput, usersUncheckedCreateWithoutPackagesInput>
  }

  export type operatorsCreateWithoutPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorCreateNestedManyWithoutOperatorsInput
    branches: branchesCreateNestedOneWithoutOperatorsInput
    operator_types: operator_typesCreateNestedOneWithoutOperatorsInput
  }

  export type operatorsUncheckedCreateWithoutPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutOperatorsInput
    email_templates?: email_templatesUncheckedCreateNestedManyWithoutOperatorsInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutOperatorsInput
    notifications_operator?: notifications_operatorUncheckedCreateNestedManyWithoutOperatorsInput
  }

  export type operatorsCreateOrConnectWithoutPackagesInput = {
    where: operatorsWhereUniqueInput
    create: XOR<operatorsCreateWithoutPackagesInput, operatorsUncheckedCreateWithoutPackagesInput>
  }

  export type invoice_packagesUpsertWithWhereUniqueWithoutPackagesInput = {
    where: invoice_packagesWhereUniqueInput
    update: XOR<invoice_packagesUpdateWithoutPackagesInput, invoice_packagesUncheckedUpdateWithoutPackagesInput>
    create: XOR<invoice_packagesCreateWithoutPackagesInput, invoice_packagesUncheckedCreateWithoutPackagesInput>
  }

  export type invoice_packagesUpdateWithWhereUniqueWithoutPackagesInput = {
    where: invoice_packagesWhereUniqueInput
    data: XOR<invoice_packagesUpdateWithoutPackagesInput, invoice_packagesUncheckedUpdateWithoutPackagesInput>
  }

  export type invoice_packagesUpdateManyWithWhereWithoutPackagesInput = {
    where: invoice_packagesScalarWhereInput
    data: XOR<invoice_packagesUpdateManyMutationInput, invoice_packagesUncheckedUpdateManyWithoutPackagesInput>
  }

  export type branchesUpsertWithoutPackagesInput = {
    update: XOR<branchesUpdateWithoutPackagesInput, branchesUncheckedUpdateWithoutPackagesInput>
    create: XOR<branchesCreateWithoutPackagesInput, branchesUncheckedCreateWithoutPackagesInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutPackagesInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutPackagesInput, branchesUncheckedUpdateWithoutPackagesInput>
  }

  export type branchesUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type usersUpsertWithoutPackagesInput = {
    update: XOR<usersUpdateWithoutPackagesInput, usersUncheckedUpdateWithoutPackagesInput>
    create: XOR<usersCreateWithoutPackagesInput, usersUncheckedCreateWithoutPackagesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPackagesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPackagesInput, usersUncheckedUpdateWithoutPackagesInput>
  }

  export type usersUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type operatorsUpsertWithoutPackagesInput = {
    update: XOR<operatorsUpdateWithoutPackagesInput, operatorsUncheckedUpdateWithoutPackagesInput>
    create: XOR<operatorsCreateWithoutPackagesInput, operatorsUncheckedCreateWithoutPackagesInput>
    where?: operatorsWhereInput
  }

  export type operatorsUpdateToOneWithWhereWithoutPackagesInput = {
    where?: operatorsWhereInput
    data: XOR<operatorsUpdateWithoutPackagesInput, operatorsUncheckedUpdateWithoutPackagesInput>
  }

  export type operatorsUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUpdateManyWithoutOperatorsNestedInput
    branches?: branchesUpdateOneRequiredWithoutOperatorsNestedInput
    operator_types?: operator_typesUpdateOneRequiredWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUncheckedUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUncheckedUpdateManyWithoutOperatorsNestedInput
  }

  export type payment_methodsCreateWithoutPayment_typesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payments?: paymentsCreateNestedManyWithoutPayment_methodsInput
    transactions?: transactionsCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsUncheckedCreateWithoutPayment_typesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payments?: paymentsUncheckedCreateNestedManyWithoutPayment_methodsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsCreateOrConnectWithoutPayment_typesInput = {
    where: payment_methodsWhereUniqueInput
    create: XOR<payment_methodsCreateWithoutPayment_typesInput, payment_methodsUncheckedCreateWithoutPayment_typesInput>
  }

  export type payment_methodsCreateManyPayment_typesInputEnvelope = {
    data: payment_methodsCreateManyPayment_typesInput | payment_methodsCreateManyPayment_typesInput[]
    skipDuplicates?: boolean
  }

  export type payment_methodsUpsertWithWhereUniqueWithoutPayment_typesInput = {
    where: payment_methodsWhereUniqueInput
    update: XOR<payment_methodsUpdateWithoutPayment_typesInput, payment_methodsUncheckedUpdateWithoutPayment_typesInput>
    create: XOR<payment_methodsCreateWithoutPayment_typesInput, payment_methodsUncheckedCreateWithoutPayment_typesInput>
  }

  export type payment_methodsUpdateWithWhereUniqueWithoutPayment_typesInput = {
    where: payment_methodsWhereUniqueInput
    data: XOR<payment_methodsUpdateWithoutPayment_typesInput, payment_methodsUncheckedUpdateWithoutPayment_typesInput>
  }

  export type payment_methodsUpdateManyWithWhereWithoutPayment_typesInput = {
    where: payment_methodsScalarWhereInput
    data: XOR<payment_methodsUpdateManyMutationInput, payment_methodsUncheckedUpdateManyWithoutPayment_typesInput>
  }

  export type payment_methodsScalarWhereInput = {
    AND?: payment_methodsScalarWhereInput | payment_methodsScalarWhereInput[]
    OR?: payment_methodsScalarWhereInput[]
    NOT?: payment_methodsScalarWhereInput | payment_methodsScalarWhereInput[]
    id?: UuidFilter<"payment_methods"> | string
    created_at?: DateTimeNullableFilter<"payment_methods"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payment_methods"> | Date | string | null
    name?: StringFilter<"payment_methods"> | string
    is_active?: BoolNullableFilter<"payment_methods"> | boolean | null
    details?: JsonNullableFilter<"payment_methods">
    payment_type_id?: IntNullableFilter<"payment_methods"> | number | null
  }

  export type payment_methodsCreateWithoutPaymentsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_types?: payment_typesCreateNestedOneWithoutPayment_methodsInput
    transactions?: transactionsCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_type_id?: number | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsCreateOrConnectWithoutPaymentsInput = {
    where: payment_methodsWhereUniqueInput
    create: XOR<payment_methodsCreateWithoutPaymentsInput, payment_methodsUncheckedCreateWithoutPaymentsInput>
  }

  export type invoicesCreateWithoutPaymentsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesCreateNestedManyWithoutInvoicesInput
    branches?: branchesCreateNestedOneWithoutInvoicesInput
    operators?: operatorsCreateNestedOneWithoutInvoicesInput
    users?: usersCreateNestedOneWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutPaymentsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    branch_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutPaymentsInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
  }

  export type transactionsCreateWithoutPaymentsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: Decimal | DecimalJsLike | number | string | null
    transaction_categories?: transaction_categoriesCreateNestedOneWithoutTransactionsInput
    payment_methods?: payment_methodsCreateNestedOneWithoutTransactionsInput
    transaction_types?: transaction_typesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    payment_method_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: string | null
    transaction_type_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type transactionsCreateOrConnectWithoutPaymentsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutPaymentsInput, transactionsUncheckedCreateWithoutPaymentsInput>
  }

  export type payment_methodsUpsertWithoutPaymentsInput = {
    update: XOR<payment_methodsUpdateWithoutPaymentsInput, payment_methodsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<payment_methodsCreateWithoutPaymentsInput, payment_methodsUncheckedCreateWithoutPaymentsInput>
    where?: payment_methodsWhereInput
  }

  export type payment_methodsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: payment_methodsWhereInput
    data: XOR<payment_methodsUpdateWithoutPaymentsInput, payment_methodsUncheckedUpdateWithoutPaymentsInput>
  }

  export type payment_methodsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_types?: payment_typesUpdateOneWithoutPayment_methodsNestedInput
    transactions?: transactionsUpdateManyWithoutPayment_methodsNestedInput
  }

  export type payment_methodsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    transactions?: transactionsUncheckedUpdateManyWithoutPayment_methodsNestedInput
  }

  export type invoicesUpsertWithoutPaymentsInput = {
    update: XOR<invoicesUpdateWithoutPaymentsInput, invoicesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutPaymentsInput, invoicesUncheckedUpdateWithoutPaymentsInput>
  }

  export type invoicesUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUpdateManyWithoutInvoicesNestedInput
    branches?: branchesUpdateOneWithoutInvoicesNestedInput
    operators?: operatorsUpdateOneWithoutInvoicesNestedInput
    users?: usersUpdateOneWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type transactionsUpsertWithoutPaymentsInput = {
    update: XOR<transactionsUpdateWithoutPaymentsInput, transactionsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<transactionsCreateWithoutPaymentsInput, transactionsUncheckedCreateWithoutPaymentsInput>
    where?: transactionsWhereInput
  }

  export type transactionsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: transactionsWhereInput
    data: XOR<transactionsUpdateWithoutPaymentsInput, transactionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type transactionsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transaction_categories?: transaction_categoriesUpdateOneWithoutTransactionsNestedInput
    payment_methods?: payment_methodsUpdateOneWithoutTransactionsNestedInput
    transaction_types?: transaction_typesUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type plansCreateWithoutPlan_addressesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresCreateNestedManyWithoutPlansInput
    branches?: branchesCreateNestedOneWithoutPlansInput
    users?: usersCreateNestedManyWithoutPlansInput
  }

  export type plansUncheckedCreateWithoutPlan_addressesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    branch_id?: string | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresUncheckedCreateNestedManyWithoutPlansInput
    users?: usersUncheckedCreateNestedManyWithoutPlansInput
  }

  export type plansCreateOrConnectWithoutPlan_addressesInput = {
    where: plansWhereUniqueInput
    create: XOR<plansCreateWithoutPlan_addressesInput, plansUncheckedCreateWithoutPlan_addressesInput>
  }

  export type plansUpsertWithoutPlan_addressesInput = {
    update: XOR<plansUpdateWithoutPlan_addressesInput, plansUncheckedUpdateWithoutPlan_addressesInput>
    create: XOR<plansCreateWithoutPlan_addressesInput, plansUncheckedCreateWithoutPlan_addressesInput>
    where?: plansWhereInput
  }

  export type plansUpdateToOneWithWhereWithoutPlan_addressesInput = {
    where?: plansWhereInput
    data: XOR<plansUpdateWithoutPlan_addressesInput, plansUncheckedUpdateWithoutPlan_addressesInput>
  }

  export type plansUpdateWithoutPlan_addressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUpdateManyWithoutPlansNestedInput
    branches?: branchesUpdateOneWithoutPlansNestedInput
    users?: usersUpdateManyWithoutPlansNestedInput
  }

  export type plansUncheckedUpdateWithoutPlan_addressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUncheckedUpdateManyWithoutPlansNestedInput
    users?: usersUncheckedUpdateManyWithoutPlansNestedInput
  }

  export type plansCreateWithoutPlan_featuresInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsCreateNestedManyWithoutPlansInput
    plan_addresses?: plan_addressesCreateNestedManyWithoutPlansInput
    branches?: branchesCreateNestedOneWithoutPlansInput
    users?: usersCreateNestedManyWithoutPlansInput
  }

  export type plansUncheckedCreateWithoutPlan_featuresInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    branch_id?: string | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutPlansInput
    plan_addresses?: plan_addressesUncheckedCreateNestedManyWithoutPlansInput
    users?: usersUncheckedCreateNestedManyWithoutPlansInput
  }

  export type plansCreateOrConnectWithoutPlan_featuresInput = {
    where: plansWhereUniqueInput
    create: XOR<plansCreateWithoutPlan_featuresInput, plansUncheckedCreateWithoutPlan_featuresInput>
  }

  export type plansUpsertWithoutPlan_featuresInput = {
    update: XOR<plansUpdateWithoutPlan_featuresInput, plansUncheckedUpdateWithoutPlan_featuresInput>
    create: XOR<plansCreateWithoutPlan_featuresInput, plansUncheckedCreateWithoutPlan_featuresInput>
    where?: plansWhereInput
  }

  export type plansUpdateToOneWithWhereWithoutPlan_featuresInput = {
    where?: plansWhereInput
    data: XOR<plansUpdateWithoutPlan_featuresInput, plansUncheckedUpdateWithoutPlan_featuresInput>
  }

  export type plansUpdateWithoutPlan_featuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUpdateManyWithoutPlansNestedInput
    plan_addresses?: plan_addressesUpdateManyWithoutPlansNestedInput
    branches?: branchesUpdateOneWithoutPlansNestedInput
    users?: usersUpdateManyWithoutPlansNestedInput
  }

  export type plansUncheckedUpdateWithoutPlan_featuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutPlansNestedInput
    plan_addresses?: plan_addressesUncheckedUpdateManyWithoutPlansNestedInput
    users?: usersUncheckedUpdateManyWithoutPlansNestedInput
  }

  export type invoice_itemsCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
    invoices: invoicesCreateNestedOneWithoutInvoice_itemsInput
    products?: productsCreateNestedOneWithoutInvoice_itemsInput
  }

  export type invoice_itemsUncheckedCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    product_id?: string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
  }

  export type invoice_itemsCreateOrConnectWithoutPlansInput = {
    where: invoice_itemsWhereUniqueInput
    create: XOR<invoice_itemsCreateWithoutPlansInput, invoice_itemsUncheckedCreateWithoutPlansInput>
  }

  export type invoice_itemsCreateManyPlansInputEnvelope = {
    data: invoice_itemsCreateManyPlansInput | invoice_itemsCreateManyPlansInput[]
    skipDuplicates?: boolean
  }

  export type plan_addressesCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    address_type: string
    address_line1: string
    address_line2: string
    city: string
    state: string
    country: string
    postal_code: string
    contact_name?: string | null
    contact_phone: string
    is_primary?: boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_addressesUncheckedCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    address_type: string
    address_line1: string
    address_line2: string
    city: string
    state: string
    country: string
    postal_code: string
    contact_name?: string | null
    contact_phone: string
    is_primary?: boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_addressesCreateOrConnectWithoutPlansInput = {
    where: plan_addressesWhereUniqueInput
    create: XOR<plan_addressesCreateWithoutPlansInput, plan_addressesUncheckedCreateWithoutPlansInput>
  }

  export type plan_addressesCreateManyPlansInputEnvelope = {
    data: plan_addressesCreateManyPlansInput | plan_addressesCreateManyPlansInput[]
    skipDuplicates?: boolean
  }

  export type plan_featuresCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    feature_name: string
    feature_value?: string | null
    is_included?: boolean | null
    limit_quantity?: number | null
    description?: string | null
  }

  export type plan_featuresUncheckedCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    feature_name: string
    feature_value?: string | null
    is_included?: boolean | null
    limit_quantity?: number | null
    description?: string | null
  }

  export type plan_featuresCreateOrConnectWithoutPlansInput = {
    where: plan_featuresWhereUniqueInput
    create: XOR<plan_featuresCreateWithoutPlansInput, plan_featuresUncheckedCreateWithoutPlansInput>
  }

  export type plan_featuresCreateManyPlansInputEnvelope = {
    data: plan_featuresCreateManyPlansInput | plan_featuresCreateManyPlansInput[]
    skipDuplicates?: boolean
  }

  export type branchesCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutPlansInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutPlansInput, branchesUncheckedCreateWithoutPlansInput>
  }

  export type usersCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPlansInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPlansInput, usersUncheckedCreateWithoutPlansInput>
  }

  export type usersCreateManyPlansInputEnvelope = {
    data: usersCreateManyPlansInput | usersCreateManyPlansInput[]
    skipDuplicates?: boolean
  }

  export type invoice_itemsUpsertWithWhereUniqueWithoutPlansInput = {
    where: invoice_itemsWhereUniqueInput
    update: XOR<invoice_itemsUpdateWithoutPlansInput, invoice_itemsUncheckedUpdateWithoutPlansInput>
    create: XOR<invoice_itemsCreateWithoutPlansInput, invoice_itemsUncheckedCreateWithoutPlansInput>
  }

  export type invoice_itemsUpdateWithWhereUniqueWithoutPlansInput = {
    where: invoice_itemsWhereUniqueInput
    data: XOR<invoice_itemsUpdateWithoutPlansInput, invoice_itemsUncheckedUpdateWithoutPlansInput>
  }

  export type invoice_itemsUpdateManyWithWhereWithoutPlansInput = {
    where: invoice_itemsScalarWhereInput
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyWithoutPlansInput>
  }

  export type plan_addressesUpsertWithWhereUniqueWithoutPlansInput = {
    where: plan_addressesWhereUniqueInput
    update: XOR<plan_addressesUpdateWithoutPlansInput, plan_addressesUncheckedUpdateWithoutPlansInput>
    create: XOR<plan_addressesCreateWithoutPlansInput, plan_addressesUncheckedCreateWithoutPlansInput>
  }

  export type plan_addressesUpdateWithWhereUniqueWithoutPlansInput = {
    where: plan_addressesWhereUniqueInput
    data: XOR<plan_addressesUpdateWithoutPlansInput, plan_addressesUncheckedUpdateWithoutPlansInput>
  }

  export type plan_addressesUpdateManyWithWhereWithoutPlansInput = {
    where: plan_addressesScalarWhereInput
    data: XOR<plan_addressesUpdateManyMutationInput, plan_addressesUncheckedUpdateManyWithoutPlansInput>
  }

  export type plan_addressesScalarWhereInput = {
    AND?: plan_addressesScalarWhereInput | plan_addressesScalarWhereInput[]
    OR?: plan_addressesScalarWhereInput[]
    NOT?: plan_addressesScalarWhereInput | plan_addressesScalarWhereInput[]
    id?: UuidFilter<"plan_addresses"> | string
    created_at?: DateTimeFilter<"plan_addresses"> | Date | string
    updated_at?: DateTimeFilter<"plan_addresses"> | Date | string
    plan_id?: UuidFilter<"plan_addresses"> | string
    address_type?: StringFilter<"plan_addresses"> | string
    address_line1?: StringFilter<"plan_addresses"> | string
    address_line2?: StringFilter<"plan_addresses"> | string
    city?: StringFilter<"plan_addresses"> | string
    state?: StringFilter<"plan_addresses"> | string
    country?: StringFilter<"plan_addresses"> | string
    postal_code?: StringFilter<"plan_addresses"> | string
    contact_name?: StringNullableFilter<"plan_addresses"> | string | null
    contact_phone?: StringFilter<"plan_addresses"> | string
    is_primary?: BoolFilter<"plan_addresses"> | boolean
    additional_info?: JsonNullableFilter<"plan_addresses">
  }

  export type plan_featuresUpsertWithWhereUniqueWithoutPlansInput = {
    where: plan_featuresWhereUniqueInput
    update: XOR<plan_featuresUpdateWithoutPlansInput, plan_featuresUncheckedUpdateWithoutPlansInput>
    create: XOR<plan_featuresCreateWithoutPlansInput, plan_featuresUncheckedCreateWithoutPlansInput>
  }

  export type plan_featuresUpdateWithWhereUniqueWithoutPlansInput = {
    where: plan_featuresWhereUniqueInput
    data: XOR<plan_featuresUpdateWithoutPlansInput, plan_featuresUncheckedUpdateWithoutPlansInput>
  }

  export type plan_featuresUpdateManyWithWhereWithoutPlansInput = {
    where: plan_featuresScalarWhereInput
    data: XOR<plan_featuresUpdateManyMutationInput, plan_featuresUncheckedUpdateManyWithoutPlansInput>
  }

  export type plan_featuresScalarWhereInput = {
    AND?: plan_featuresScalarWhereInput | plan_featuresScalarWhereInput[]
    OR?: plan_featuresScalarWhereInput[]
    NOT?: plan_featuresScalarWhereInput | plan_featuresScalarWhereInput[]
    id?: UuidFilter<"plan_features"> | string
    created_at?: DateTimeFilter<"plan_features"> | Date | string
    updated_at?: DateTimeNullableFilter<"plan_features"> | Date | string | null
    plan_id?: UuidFilter<"plan_features"> | string
    feature_name?: StringFilter<"plan_features"> | string
    feature_value?: StringNullableFilter<"plan_features"> | string | null
    is_included?: BoolNullableFilter<"plan_features"> | boolean | null
    limit_quantity?: IntNullableFilter<"plan_features"> | number | null
    description?: StringNullableFilter<"plan_features"> | string | null
  }

  export type branchesUpsertWithoutPlansInput = {
    update: XOR<branchesUpdateWithoutPlansInput, branchesUncheckedUpdateWithoutPlansInput>
    create: XOR<branchesCreateWithoutPlansInput, branchesUncheckedCreateWithoutPlansInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutPlansInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutPlansInput, branchesUncheckedUpdateWithoutPlansInput>
  }

  export type branchesUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type usersUpsertWithWhereUniqueWithoutPlansInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutPlansInput, usersUncheckedUpdateWithoutPlansInput>
    create: XOR<usersCreateWithoutPlansInput, usersUncheckedCreateWithoutPlansInput>
  }

  export type usersUpdateWithWhereUniqueWithoutPlansInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutPlansInput, usersUncheckedUpdateWithoutPlansInput>
  }

  export type usersUpdateManyWithWhereWithoutPlansInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutPlansInput>
  }

  export type invoice_itemsCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
    invoices: invoicesCreateNestedOneWithoutInvoice_itemsInput
    plans?: plansCreateNestedOneWithoutInvoice_itemsInput
  }

  export type invoice_itemsUncheckedCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    plan_id?: string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
  }

  export type invoice_itemsCreateOrConnectWithoutProductsInput = {
    where: invoice_itemsWhereUniqueInput
    create: XOR<invoice_itemsCreateWithoutProductsInput, invoice_itemsUncheckedCreateWithoutProductsInput>
  }

  export type invoice_itemsCreateManyProductsInputEnvelope = {
    data: invoice_itemsCreateManyProductsInput | invoice_itemsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type branchesCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutProductsInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutProductsInput, branchesUncheckedCreateWithoutProductsInput>
  }

  export type categoriesCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    icon?: string | null
    is_active?: boolean | null
    order_position?: number | null
  }

  export type categoriesUncheckedCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    icon?: string | null
    is_active?: boolean | null
    order_position?: number | null
  }

  export type categoriesCreateOrConnectWithoutProductsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutProductsInput, categoriesUncheckedCreateWithoutProductsInput>
  }

  export type invoice_itemsUpsertWithWhereUniqueWithoutProductsInput = {
    where: invoice_itemsWhereUniqueInput
    update: XOR<invoice_itemsUpdateWithoutProductsInput, invoice_itemsUncheckedUpdateWithoutProductsInput>
    create: XOR<invoice_itemsCreateWithoutProductsInput, invoice_itemsUncheckedCreateWithoutProductsInput>
  }

  export type invoice_itemsUpdateWithWhereUniqueWithoutProductsInput = {
    where: invoice_itemsWhereUniqueInput
    data: XOR<invoice_itemsUpdateWithoutProductsInput, invoice_itemsUncheckedUpdateWithoutProductsInput>
  }

  export type invoice_itemsUpdateManyWithWhereWithoutProductsInput = {
    where: invoice_itemsScalarWhereInput
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyWithoutProductsInput>
  }

  export type branchesUpsertWithoutProductsInput = {
    update: XOR<branchesUpdateWithoutProductsInput, branchesUncheckedUpdateWithoutProductsInput>
    create: XOR<branchesCreateWithoutProductsInput, branchesUncheckedCreateWithoutProductsInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutProductsInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutProductsInput, branchesUncheckedUpdateWithoutProductsInput>
  }

  export type branchesUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type categoriesUpsertWithoutProductsInput = {
    update: XOR<categoriesUpdateWithoutProductsInput, categoriesUncheckedUpdateWithoutProductsInput>
    create: XOR<categoriesCreateWithoutProductsInput, categoriesUncheckedCreateWithoutProductsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutProductsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutProductsInput, categoriesUncheckedUpdateWithoutProductsInput>
  }

  export type categoriesUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type categoriesUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersCreateWithoutType_usersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutType_usersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutType_usersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutType_usersInput, usersUncheckedCreateWithoutType_usersInput>
  }

  export type usersCreateManyType_usersInputEnvelope = {
    data: usersCreateManyType_usersInput | usersCreateManyType_usersInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutType_usersInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutType_usersInput, usersUncheckedUpdateWithoutType_usersInput>
    create: XOR<usersCreateWithoutType_usersInput, usersUncheckedCreateWithoutType_usersInput>
  }

  export type usersUpdateWithWhereUniqueWithoutType_usersInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutType_usersInput, usersUncheckedUpdateWithoutType_usersInput>
  }

  export type usersUpdateManyWithWhereWithoutType_usersInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutType_usersInput>
  }

  export type email_campaignsCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
    email_templates?: email_templatesCreateNestedOneWithoutEmail_campaignsInput
  }

  export type email_campaignsUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    template_id?: string | null
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsCreateOrConnectWithoutUsersInput = {
    where: email_campaignsWhereUniqueInput
    create: XOR<email_campaignsCreateWithoutUsersInput, email_campaignsUncheckedCreateWithoutUsersInput>
  }

  export type email_campaignsCreateManyUsersInputEnvelope = {
    data: email_campaignsCreateManyUsersInput | email_campaignsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type invoicesCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesCreateNestedManyWithoutInvoicesInput
    branches?: branchesCreateNestedOneWithoutInvoicesInput
    operators?: operatorsCreateNestedOneWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    branch_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutInvoicesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutUsersInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput>
  }

  export type invoicesCreateManyUsersInputEnvelope = {
    data: invoicesCreateManyUsersInput | invoicesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notification_preferencesCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    push_enabled?: boolean | null
    email_enabled?: boolean | null
    sms_enabled?: boolean | null
    news_and_updates?: boolean | null
    order_updates?: boolean | null
    promotions?: boolean | null
    security_alerts?: boolean | null
    quiet_hours_start?: Date | string | null
    quiet_hours_end?: Date | string | null
    quiet_hours_enabled?: boolean | null
    frequency?: string | null
  }

  export type notification_preferencesUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    push_enabled?: boolean | null
    email_enabled?: boolean | null
    sms_enabled?: boolean | null
    news_and_updates?: boolean | null
    order_updates?: boolean | null
    promotions?: boolean | null
    security_alerts?: boolean | null
    quiet_hours_start?: Date | string | null
    quiet_hours_end?: Date | string | null
    quiet_hours_enabled?: boolean | null
    frequency?: string | null
  }

  export type notification_preferencesCreateOrConnectWithoutUsersInput = {
    where: notification_preferencesWhereUniqueInput
    create: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput>
  }

  export type notification_preferencesCreateManyUsersInputEnvelope = {
    data: notification_preferencesCreateManyUsersInput | notification_preferencesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notification_usersCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    type: string
    is_read?: boolean | null
    is_deleted?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: string | null
    action_url?: string | null
    icon?: string | null
    expiry_date?: Date | string | null
    requires_action?: boolean | null
  }

  export type notification_usersUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    type: string
    is_read?: boolean | null
    is_deleted?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: string | null
    action_url?: string | null
    icon?: string | null
    expiry_date?: Date | string | null
    requires_action?: boolean | null
  }

  export type notification_usersCreateOrConnectWithoutUsersInput = {
    where: notification_usersWhereUniqueInput
    create: XOR<notification_usersCreateWithoutUsersInput, notification_usersUncheckedCreateWithoutUsersInput>
  }

  export type notification_usersCreateManyUsersInputEnvelope = {
    data: notification_usersCreateManyUsersInput | notification_usersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type packagesCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    position?: string | null
    invoice_packages?: invoice_packagesCreateNestedManyWithoutPackagesInput
    branches?: branchesCreateNestedOneWithoutPackagesInput
    operators?: operatorsCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    branch_id?: string | null
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    operator_id?: string | null
    position?: string | null
    invoice_packages?: invoice_packagesUncheckedCreateNestedManyWithoutPackagesInput
  }

  export type packagesCreateOrConnectWithoutUsersInput = {
    where: packagesWhereUniqueInput
    create: XOR<packagesCreateWithoutUsersInput, packagesUncheckedCreateWithoutUsersInput>
  }

  export type packagesCreateManyUsersInputEnvelope = {
    data: packagesCreateManyUsersInput | packagesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type saved_cardsCreateWithoutUsersInput = {
    card_token: string
    card_type?: string | null
    cardholder_name?: string | null
    expiry_month: number
    expiry_year: number
    brand?: string | null
    last_four_digits?: string | null
    is_default?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    nick_name?: string | null
  }

  export type saved_cardsUncheckedCreateWithoutUsersInput = {
    id?: number
    card_token: string
    card_type?: string | null
    cardholder_name?: string | null
    expiry_month: number
    expiry_year: number
    brand?: string | null
    last_four_digits?: string | null
    is_default?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    nick_name?: string | null
  }

  export type saved_cardsCreateOrConnectWithoutUsersInput = {
    where: saved_cardsWhereUniqueInput
    create: XOR<saved_cardsCreateWithoutUsersInput, saved_cardsUncheckedCreateWithoutUsersInput>
  }

  export type saved_cardsCreateManyUsersInputEnvelope = {
    data: saved_cardsCreateManyUsersInput | saved_cardsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type branchesCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutUsersInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutUsersInput, branchesUncheckedCreateWithoutUsersInput>
  }

  export type plansCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsCreateNestedManyWithoutPlansInput
    plan_addresses?: plan_addressesCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresCreateNestedManyWithoutPlansInput
    branches?: branchesCreateNestedOneWithoutPlansInput
  }

  export type plansUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    branch_id?: string | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutPlansInput
    plan_addresses?: plan_addressesUncheckedCreateNestedManyWithoutPlansInput
    plan_features?: plan_featuresUncheckedCreateNestedManyWithoutPlansInput
  }

  export type plansCreateOrConnectWithoutUsersInput = {
    where: plansWhereUniqueInput
    create: XOR<plansCreateWithoutUsersInput, plansUncheckedCreateWithoutUsersInput>
  }

  export type referral_sourcesCreateWithoutUsersInput = {
    id?: string
    source_name: string
  }

  export type referral_sourcesUncheckedCreateWithoutUsersInput = {
    id?: string
    source_name: string
  }

  export type referral_sourcesCreateOrConnectWithoutUsersInput = {
    where: referral_sourcesWhereUniqueInput
    create: XOR<referral_sourcesCreateWithoutUsersInput, referral_sourcesUncheckedCreateWithoutUsersInput>
  }

  export type type_usersCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code?: string | null
    description?: string | null
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type type_usersUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code?: string | null
    description?: string | null
    name: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type type_usersCreateOrConnectWithoutUsersInput = {
    where: type_usersWhereUniqueInput
    create: XOR<type_usersCreateWithoutUsersInput, type_usersUncheckedCreateWithoutUsersInput>
  }

  export type walletsCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean | null
    last_transaction_date?: Date | string | null
  }

  export type walletsUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean | null
    last_transaction_date?: Date | string | null
  }

  export type walletsCreateOrConnectWithoutUsersInput = {
    where: walletsWhereUniqueInput
    create: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput>
  }

  export type walletsCreateManyUsersInputEnvelope = {
    data: walletsCreateManyUsersInput | walletsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type email_campaignsUpsertWithWhereUniqueWithoutUsersInput = {
    where: email_campaignsWhereUniqueInput
    update: XOR<email_campaignsUpdateWithoutUsersInput, email_campaignsUncheckedUpdateWithoutUsersInput>
    create: XOR<email_campaignsCreateWithoutUsersInput, email_campaignsUncheckedCreateWithoutUsersInput>
  }

  export type email_campaignsUpdateWithWhereUniqueWithoutUsersInput = {
    where: email_campaignsWhereUniqueInput
    data: XOR<email_campaignsUpdateWithoutUsersInput, email_campaignsUncheckedUpdateWithoutUsersInput>
  }

  export type email_campaignsUpdateManyWithWhereWithoutUsersInput = {
    where: email_campaignsScalarWhereInput
    data: XOR<email_campaignsUpdateManyMutationInput, email_campaignsUncheckedUpdateManyWithoutUsersInput>
  }

  export type invoicesUpsertWithWhereUniqueWithoutUsersInput = {
    where: invoicesWhereUniqueInput
    update: XOR<invoicesUpdateWithoutUsersInput, invoicesUncheckedUpdateWithoutUsersInput>
    create: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput>
  }

  export type invoicesUpdateWithWhereUniqueWithoutUsersInput = {
    where: invoicesWhereUniqueInput
    data: XOR<invoicesUpdateWithoutUsersInput, invoicesUncheckedUpdateWithoutUsersInput>
  }

  export type invoicesUpdateManyWithWhereWithoutUsersInput = {
    where: invoicesScalarWhereInput
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyWithoutUsersInput>
  }

  export type notification_preferencesUpsertWithWhereUniqueWithoutUsersInput = {
    where: notification_preferencesWhereUniqueInput
    update: XOR<notification_preferencesUpdateWithoutUsersInput, notification_preferencesUncheckedUpdateWithoutUsersInput>
    create: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput>
  }

  export type notification_preferencesUpdateWithWhereUniqueWithoutUsersInput = {
    where: notification_preferencesWhereUniqueInput
    data: XOR<notification_preferencesUpdateWithoutUsersInput, notification_preferencesUncheckedUpdateWithoutUsersInput>
  }

  export type notification_preferencesUpdateManyWithWhereWithoutUsersInput = {
    where: notification_preferencesScalarWhereInput
    data: XOR<notification_preferencesUpdateManyMutationInput, notification_preferencesUncheckedUpdateManyWithoutUsersInput>
  }

  export type notification_preferencesScalarWhereInput = {
    AND?: notification_preferencesScalarWhereInput | notification_preferencesScalarWhereInput[]
    OR?: notification_preferencesScalarWhereInput[]
    NOT?: notification_preferencesScalarWhereInput | notification_preferencesScalarWhereInput[]
    id?: UuidFilter<"notification_preferences"> | string
    created_at?: DateTimeFilter<"notification_preferences"> | Date | string
    updated_at?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    user_id?: UuidFilter<"notification_preferences"> | string
    push_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    email_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    sms_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    news_and_updates?: BoolNullableFilter<"notification_preferences"> | boolean | null
    order_updates?: BoolNullableFilter<"notification_preferences"> | boolean | null
    promotions?: BoolNullableFilter<"notification_preferences"> | boolean | null
    security_alerts?: BoolNullableFilter<"notification_preferences"> | boolean | null
    quiet_hours_start?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    quiet_hours_end?: DateTimeNullableFilter<"notification_preferences"> | Date | string | null
    quiet_hours_enabled?: BoolNullableFilter<"notification_preferences"> | boolean | null
    frequency?: StringNullableFilter<"notification_preferences"> | string | null
  }

  export type notification_usersUpsertWithWhereUniqueWithoutUsersInput = {
    where: notification_usersWhereUniqueInput
    update: XOR<notification_usersUpdateWithoutUsersInput, notification_usersUncheckedUpdateWithoutUsersInput>
    create: XOR<notification_usersCreateWithoutUsersInput, notification_usersUncheckedCreateWithoutUsersInput>
  }

  export type notification_usersUpdateWithWhereUniqueWithoutUsersInput = {
    where: notification_usersWhereUniqueInput
    data: XOR<notification_usersUpdateWithoutUsersInput, notification_usersUncheckedUpdateWithoutUsersInput>
  }

  export type notification_usersUpdateManyWithWhereWithoutUsersInput = {
    where: notification_usersScalarWhereInput
    data: XOR<notification_usersUpdateManyMutationInput, notification_usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type notification_usersScalarWhereInput = {
    AND?: notification_usersScalarWhereInput | notification_usersScalarWhereInput[]
    OR?: notification_usersScalarWhereInput[]
    NOT?: notification_usersScalarWhereInput | notification_usersScalarWhereInput[]
    id?: UuidFilter<"notification_users"> | string
    created_at?: DateTimeFilter<"notification_users"> | Date | string
    updated_at?: DateTimeNullableFilter<"notification_users"> | Date | string | null
    title?: StringFilter<"notification_users"> | string
    message?: StringFilter<"notification_users"> | string
    type?: StringFilter<"notification_users"> | string
    is_read?: BoolNullableFilter<"notification_users"> | boolean | null
    is_deleted?: BoolNullableFilter<"notification_users"> | boolean | null
    user_id?: UuidFilter<"notification_users"> | string
    data?: JsonNullableFilter<"notification_users">
    priority?: StringNullableFilter<"notification_users"> | string | null
    action_url?: StringNullableFilter<"notification_users"> | string | null
    icon?: StringNullableFilter<"notification_users"> | string | null
    expiry_date?: DateTimeNullableFilter<"notification_users"> | Date | string | null
    requires_action?: BoolNullableFilter<"notification_users"> | boolean | null
  }

  export type packagesUpsertWithWhereUniqueWithoutUsersInput = {
    where: packagesWhereUniqueInput
    update: XOR<packagesUpdateWithoutUsersInput, packagesUncheckedUpdateWithoutUsersInput>
    create: XOR<packagesCreateWithoutUsersInput, packagesUncheckedCreateWithoutUsersInput>
  }

  export type packagesUpdateWithWhereUniqueWithoutUsersInput = {
    where: packagesWhereUniqueInput
    data: XOR<packagesUpdateWithoutUsersInput, packagesUncheckedUpdateWithoutUsersInput>
  }

  export type packagesUpdateManyWithWhereWithoutUsersInput = {
    where: packagesScalarWhereInput
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyWithoutUsersInput>
  }

  export type saved_cardsUpsertWithWhereUniqueWithoutUsersInput = {
    where: saved_cardsWhereUniqueInput
    update: XOR<saved_cardsUpdateWithoutUsersInput, saved_cardsUncheckedUpdateWithoutUsersInput>
    create: XOR<saved_cardsCreateWithoutUsersInput, saved_cardsUncheckedCreateWithoutUsersInput>
  }

  export type saved_cardsUpdateWithWhereUniqueWithoutUsersInput = {
    where: saved_cardsWhereUniqueInput
    data: XOR<saved_cardsUpdateWithoutUsersInput, saved_cardsUncheckedUpdateWithoutUsersInput>
  }

  export type saved_cardsUpdateManyWithWhereWithoutUsersInput = {
    where: saved_cardsScalarWhereInput
    data: XOR<saved_cardsUpdateManyMutationInput, saved_cardsUncheckedUpdateManyWithoutUsersInput>
  }

  export type saved_cardsScalarWhereInput = {
    AND?: saved_cardsScalarWhereInput | saved_cardsScalarWhereInput[]
    OR?: saved_cardsScalarWhereInput[]
    NOT?: saved_cardsScalarWhereInput | saved_cardsScalarWhereInput[]
    id?: IntFilter<"saved_cards"> | number
    user_id?: UuidFilter<"saved_cards"> | string
    card_token?: StringFilter<"saved_cards"> | string
    card_type?: StringNullableFilter<"saved_cards"> | string | null
    cardholder_name?: StringNullableFilter<"saved_cards"> | string | null
    expiry_month?: IntFilter<"saved_cards"> | number
    expiry_year?: IntFilter<"saved_cards"> | number
    brand?: StringNullableFilter<"saved_cards"> | string | null
    last_four_digits?: StringNullableFilter<"saved_cards"> | string | null
    is_default?: BoolNullableFilter<"saved_cards"> | boolean | null
    created_at?: DateTimeNullableFilter<"saved_cards"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"saved_cards"> | Date | string | null
    nick_name?: StringNullableFilter<"saved_cards"> | string | null
  }

  export type branchesUpsertWithoutUsersInput = {
    update: XOR<branchesUpdateWithoutUsersInput, branchesUncheckedUpdateWithoutUsersInput>
    create: XOR<branchesCreateWithoutUsersInput, branchesUncheckedCreateWithoutUsersInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutUsersInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutUsersInput, branchesUncheckedUpdateWithoutUsersInput>
  }

  export type branchesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type plansUpsertWithoutUsersInput = {
    update: XOR<plansUpdateWithoutUsersInput, plansUncheckedUpdateWithoutUsersInput>
    create: XOR<plansCreateWithoutUsersInput, plansUncheckedCreateWithoutUsersInput>
    where?: plansWhereInput
  }

  export type plansUpdateToOneWithWhereWithoutUsersInput = {
    where?: plansWhereInput
    data: XOR<plansUpdateWithoutUsersInput, plansUncheckedUpdateWithoutUsersInput>
  }

  export type plansUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUpdateManyWithoutPlansNestedInput
    plan_addresses?: plan_addressesUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUpdateManyWithoutPlansNestedInput
    branches?: branchesUpdateOneWithoutPlansNestedInput
  }

  export type plansUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutPlansNestedInput
    plan_addresses?: plan_addressesUncheckedUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUncheckedUpdateManyWithoutPlansNestedInput
  }

  export type referral_sourcesUpsertWithoutUsersInput = {
    update: XOR<referral_sourcesUpdateWithoutUsersInput, referral_sourcesUncheckedUpdateWithoutUsersInput>
    create: XOR<referral_sourcesCreateWithoutUsersInput, referral_sourcesUncheckedCreateWithoutUsersInput>
    where?: referral_sourcesWhereInput
  }

  export type referral_sourcesUpdateToOneWithWhereWithoutUsersInput = {
    where?: referral_sourcesWhereInput
    data: XOR<referral_sourcesUpdateWithoutUsersInput, referral_sourcesUncheckedUpdateWithoutUsersInput>
  }

  export type referral_sourcesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    source_name?: StringFieldUpdateOperationsInput | string
  }

  export type referral_sourcesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    source_name?: StringFieldUpdateOperationsInput | string
  }

  export type type_usersUpsertWithoutUsersInput = {
    update: XOR<type_usersUpdateWithoutUsersInput, type_usersUncheckedUpdateWithoutUsersInput>
    create: XOR<type_usersCreateWithoutUsersInput, type_usersUncheckedCreateWithoutUsersInput>
    where?: type_usersWhereInput
  }

  export type type_usersUpdateToOneWithWhereWithoutUsersInput = {
    where?: type_usersWhereInput
    data: XOR<type_usersUpdateWithoutUsersInput, type_usersUncheckedUpdateWithoutUsersInput>
  }

  export type type_usersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type type_usersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type walletsUpsertWithWhereUniqueWithoutUsersInput = {
    where: walletsWhereUniqueInput
    update: XOR<walletsUpdateWithoutUsersInput, walletsUncheckedUpdateWithoutUsersInput>
    create: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput>
  }

  export type walletsUpdateWithWhereUniqueWithoutUsersInput = {
    where: walletsWhereUniqueInput
    data: XOR<walletsUpdateWithoutUsersInput, walletsUncheckedUpdateWithoutUsersInput>
  }

  export type walletsUpdateManyWithWhereWithoutUsersInput = {
    where: walletsScalarWhereInput
    data: XOR<walletsUpdateManyMutationInput, walletsUncheckedUpdateManyWithoutUsersInput>
  }

  export type walletsScalarWhereInput = {
    AND?: walletsScalarWhereInput | walletsScalarWhereInput[]
    OR?: walletsScalarWhereInput[]
    NOT?: walletsScalarWhereInput | walletsScalarWhereInput[]
    id?: UuidFilter<"wallets"> | string
    created_at?: DateTimeFilter<"wallets"> | Date | string
    updated_at?: DateTimeNullableFilter<"wallets"> | Date | string | null
    balance?: DecimalNullableFilter<"wallets"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"wallets"> | string | null
    is_active?: BoolNullableFilter<"wallets"> | boolean | null
    last_transaction_date?: DateTimeNullableFilter<"wallets"> | Date | string | null
    user_id?: UuidNullableFilter<"wallets"> | string | null
  }

  export type branchesCreateWithoutVehiclesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesCreateNestedManyWithoutBranchesInput
    companies: companiesCreateNestedOneWithoutBranchesInput
    gift_cards?: gift_cardsCreateNestedManyWithoutBranchesInput
    invoices?: invoicesCreateNestedManyWithoutBranchesInput
    operators?: operatorsCreateNestedManyWithoutBranchesInput
    packages?: packagesCreateNestedManyWithoutBranchesInput
    plans?: plansCreateNestedManyWithoutBranchesInput
    products?: productsCreateNestedManyWithoutBranchesInput
    users?: usersCreateNestedManyWithoutBranchesInput
  }

  export type branchesUncheckedCreateWithoutVehiclesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    company_id: string
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
    activities?: activitiesUncheckedCreateNestedManyWithoutBranchesInput
    gift_cards?: gift_cardsUncheckedCreateNestedManyWithoutBranchesInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutBranchesInput
    operators?: operatorsUncheckedCreateNestedManyWithoutBranchesInput
    packages?: packagesUncheckedCreateNestedManyWithoutBranchesInput
    plans?: plansUncheckedCreateNestedManyWithoutBranchesInput
    products?: productsUncheckedCreateNestedManyWithoutBranchesInput
    users?: usersUncheckedCreateNestedManyWithoutBranchesInput
  }

  export type branchesCreateOrConnectWithoutVehiclesInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutVehiclesInput, branchesUncheckedCreateWithoutVehiclesInput>
  }

  export type branchesUpsertWithoutVehiclesInput = {
    update: XOR<branchesUpdateWithoutVehiclesInput, branchesUncheckedUpdateWithoutVehiclesInput>
    create: XOR<branchesCreateWithoutVehiclesInput, branchesUncheckedCreateWithoutVehiclesInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutVehiclesInput, branchesUncheckedUpdateWithoutVehiclesInput>
  }

  export type branchesUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    companies?: companiesUpdateOneRequiredWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: StringFieldUpdateOperationsInput | string
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type usersCreateWithoutWalletsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutWalletsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutWalletsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWalletsInput, usersUncheckedCreateWithoutWalletsInput>
  }

  export type usersUpsertWithoutWalletsInput = {
    update: XOR<usersUpdateWithoutWalletsInput, usersUncheckedUpdateWithoutWalletsInput>
    create: XOR<usersCreateWithoutWalletsInput, usersUncheckedCreateWithoutWalletsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWalletsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWalletsInput, usersUncheckedUpdateWithoutWalletsInput>
  }

  export type usersUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutSaved_cardsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    referral_sources?: referral_sourcesCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSaved_cardsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSaved_cardsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSaved_cardsInput, usersUncheckedCreateWithoutSaved_cardsInput>
  }

  export type usersUpsertWithoutSaved_cardsInput = {
    update: XOR<usersUpdateWithoutSaved_cardsInput, usersUncheckedUpdateWithoutSaved_cardsInput>
    create: XOR<usersCreateWithoutSaved_cardsInput, usersUncheckedCreateWithoutSaved_cardsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSaved_cardsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSaved_cardsInput, usersUncheckedUpdateWithoutSaved_cardsInput>
  }

  export type usersUpdateWithoutSaved_cardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSaved_cardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type payment_typesCreateWithoutPayment_methodsInput = {
    name: string
    description?: string | null
    is_active?: boolean | null
    processing_fee_percentage?: Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: Decimal | DecimalJsLike | number | string | null
    requires_approval?: boolean | null
    icon?: string | null
  }

  export type payment_typesUncheckedCreateWithoutPayment_methodsInput = {
    id?: number
    name: string
    description?: string | null
    is_active?: boolean | null
    processing_fee_percentage?: Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: Decimal | DecimalJsLike | number | string | null
    requires_approval?: boolean | null
    icon?: string | null
  }

  export type payment_typesCreateOrConnectWithoutPayment_methodsInput = {
    where: payment_typesWhereUniqueInput
    create: XOR<payment_typesCreateWithoutPayment_methodsInput, payment_typesUncheckedCreateWithoutPayment_methodsInput>
  }

  export type paymentsCreateWithoutPayment_methodsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    invoices: invoicesCreateNestedOneWithoutPaymentsInput
    transactions?: transactionsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutPayment_methodsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    transaction_id?: string | null
  }

  export type paymentsCreateOrConnectWithoutPayment_methodsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutPayment_methodsInput, paymentsUncheckedCreateWithoutPayment_methodsInput>
  }

  export type paymentsCreateManyPayment_methodsInputEnvelope = {
    data: paymentsCreateManyPayment_methodsInput | paymentsCreateManyPayment_methodsInput[]
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutPayment_methodsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutTransactionsInput
    transaction_categories?: transaction_categoriesCreateNestedOneWithoutTransactionsInput
    transaction_types?: transaction_typesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutPayment_methodsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: string | null
    transaction_type_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutPayment_methodsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutPayment_methodsInput, transactionsUncheckedCreateWithoutPayment_methodsInput>
  }

  export type transactionsCreateManyPayment_methodsInputEnvelope = {
    data: transactionsCreateManyPayment_methodsInput | transactionsCreateManyPayment_methodsInput[]
    skipDuplicates?: boolean
  }

  export type payment_typesUpsertWithoutPayment_methodsInput = {
    update: XOR<payment_typesUpdateWithoutPayment_methodsInput, payment_typesUncheckedUpdateWithoutPayment_methodsInput>
    create: XOR<payment_typesCreateWithoutPayment_methodsInput, payment_typesUncheckedCreateWithoutPayment_methodsInput>
    where?: payment_typesWhereInput
  }

  export type payment_typesUpdateToOneWithWhereWithoutPayment_methodsInput = {
    where?: payment_typesWhereInput
    data: XOR<payment_typesUpdateWithoutPayment_methodsInput, payment_typesUncheckedUpdateWithoutPayment_methodsInput>
  }

  export type payment_typesUpdateWithoutPayment_methodsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processing_fee_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requires_approval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type payment_typesUncheckedUpdateWithoutPayment_methodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processing_fee_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processing_fee_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requires_approval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutPayment_methodsInput, paymentsUncheckedUpdateWithoutPayment_methodsInput>
    create: XOR<paymentsCreateWithoutPayment_methodsInput, paymentsUncheckedCreateWithoutPayment_methodsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutPayment_methodsInput, paymentsUncheckedUpdateWithoutPayment_methodsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutPayment_methodsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutPayment_methodsInput>
  }

  export type transactionsUpsertWithWhereUniqueWithoutPayment_methodsInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutPayment_methodsInput, transactionsUncheckedUpdateWithoutPayment_methodsInput>
    create: XOR<transactionsCreateWithoutPayment_methodsInput, transactionsUncheckedCreateWithoutPayment_methodsInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutPayment_methodsInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutPayment_methodsInput, transactionsUncheckedUpdateWithoutPayment_methodsInput>
  }

  export type transactionsUpdateManyWithWhereWithoutPayment_methodsInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutPayment_methodsInput>
  }

  export type transactionsScalarWhereInput = {
    AND?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    OR?: transactionsScalarWhereInput[]
    NOT?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    id?: UuidFilter<"transactions"> | string
    created_at?: DateTimeNullableFilter<"transactions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transactions"> | Date | string | null
    description?: StringNullableFilter<"transactions"> | string | null
    status?: StringFilter<"transactions"> | string
    transaction_date?: DateTimeNullableFilter<"transactions"> | Date | string | null
    transaction_type?: StringFilter<"transactions"> | string
    reference_id?: UuidNullableFilter<"transactions"> | string | null
    entity_type?: StringNullableFilter<"transactions"> | string | null
    entity_id?: UuidNullableFilter<"transactions"> | string | null
    payment_method_id?: UuidNullableFilter<"transactions"> | string | null
    metadata?: JsonNullableFilter<"transactions">
    category_id?: UuidNullableFilter<"transactions"> | string | null
    transaction_type_id?: UuidNullableFilter<"transactions"> | string | null
    amount?: DecimalNullableFilter<"transactions"> | Decimal | DecimalJsLike | number | string | null
  }

  export type transaction_categoriesCreateWithoutOther_transaction_categoriesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    is_active?: boolean | null
    transaction_categories?: transaction_categoriesCreateNestedOneWithoutOther_transaction_categoriesInput
    transactions?: transactionsCreateNestedManyWithoutTransaction_categoriesInput
  }

  export type transaction_categoriesUncheckedCreateWithoutOther_transaction_categoriesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    parent_id?: string | null
    is_active?: boolean | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutTransaction_categoriesInput
  }

  export type transaction_categoriesCreateOrConnectWithoutOther_transaction_categoriesInput = {
    where: transaction_categoriesWhereUniqueInput
    create: XOR<transaction_categoriesCreateWithoutOther_transaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutOther_transaction_categoriesInput>
  }

  export type transaction_categoriesCreateWithoutTransaction_categoriesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    is_active?: boolean | null
    other_transaction_categories?: transaction_categoriesCreateNestedManyWithoutTransaction_categoriesInput
    transactions?: transactionsCreateNestedManyWithoutTransaction_categoriesInput
  }

  export type transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    is_active?: boolean | null
    other_transaction_categories?: transaction_categoriesUncheckedCreateNestedManyWithoutTransaction_categoriesInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutTransaction_categoriesInput
  }

  export type transaction_categoriesCreateOrConnectWithoutTransaction_categoriesInput = {
    where: transaction_categoriesWhereUniqueInput
    create: XOR<transaction_categoriesCreateWithoutTransaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput>
  }

  export type transaction_categoriesCreateManyTransaction_categoriesInputEnvelope = {
    data: transaction_categoriesCreateManyTransaction_categoriesInput | transaction_categoriesCreateManyTransaction_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutTransaction_categoriesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutTransactionsInput
    payment_methods?: payment_methodsCreateNestedOneWithoutTransactionsInput
    transaction_types?: transaction_typesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutTransaction_categoriesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    payment_method_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    transaction_type_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutTransaction_categoriesInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutTransaction_categoriesInput, transactionsUncheckedCreateWithoutTransaction_categoriesInput>
  }

  export type transactionsCreateManyTransaction_categoriesInputEnvelope = {
    data: transactionsCreateManyTransaction_categoriesInput | transactionsCreateManyTransaction_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type transaction_categoriesUpsertWithoutOther_transaction_categoriesInput = {
    update: XOR<transaction_categoriesUpdateWithoutOther_transaction_categoriesInput, transaction_categoriesUncheckedUpdateWithoutOther_transaction_categoriesInput>
    create: XOR<transaction_categoriesCreateWithoutOther_transaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutOther_transaction_categoriesInput>
    where?: transaction_categoriesWhereInput
  }

  export type transaction_categoriesUpdateToOneWithWhereWithoutOther_transaction_categoriesInput = {
    where?: transaction_categoriesWhereInput
    data: XOR<transaction_categoriesUpdateWithoutOther_transaction_categoriesInput, transaction_categoriesUncheckedUpdateWithoutOther_transaction_categoriesInput>
  }

  export type transaction_categoriesUpdateWithoutOther_transaction_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    transaction_categories?: transaction_categoriesUpdateOneWithoutOther_transaction_categoriesNestedInput
    transactions?: transactionsUpdateManyWithoutTransaction_categoriesNestedInput
  }

  export type transaction_categoriesUncheckedUpdateWithoutOther_transaction_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    transactions?: transactionsUncheckedUpdateManyWithoutTransaction_categoriesNestedInput
  }

  export type transaction_categoriesUpsertWithWhereUniqueWithoutTransaction_categoriesInput = {
    where: transaction_categoriesWhereUniqueInput
    update: XOR<transaction_categoriesUpdateWithoutTransaction_categoriesInput, transaction_categoriesUncheckedUpdateWithoutTransaction_categoriesInput>
    create: XOR<transaction_categoriesCreateWithoutTransaction_categoriesInput, transaction_categoriesUncheckedCreateWithoutTransaction_categoriesInput>
  }

  export type transaction_categoriesUpdateWithWhereUniqueWithoutTransaction_categoriesInput = {
    where: transaction_categoriesWhereUniqueInput
    data: XOR<transaction_categoriesUpdateWithoutTransaction_categoriesInput, transaction_categoriesUncheckedUpdateWithoutTransaction_categoriesInput>
  }

  export type transaction_categoriesUpdateManyWithWhereWithoutTransaction_categoriesInput = {
    where: transaction_categoriesScalarWhereInput
    data: XOR<transaction_categoriesUpdateManyMutationInput, transaction_categoriesUncheckedUpdateManyWithoutTransaction_categoriesInput>
  }

  export type transaction_categoriesScalarWhereInput = {
    AND?: transaction_categoriesScalarWhereInput | transaction_categoriesScalarWhereInput[]
    OR?: transaction_categoriesScalarWhereInput[]
    NOT?: transaction_categoriesScalarWhereInput | transaction_categoriesScalarWhereInput[]
    id?: UuidFilter<"transaction_categories"> | string
    created_at?: DateTimeNullableFilter<"transaction_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"transaction_categories"> | Date | string | null
    name?: StringFilter<"transaction_categories"> | string
    description?: StringNullableFilter<"transaction_categories"> | string | null
    parent_id?: UuidNullableFilter<"transaction_categories"> | string | null
    is_active?: BoolNullableFilter<"transaction_categories"> | boolean | null
  }

  export type transactionsUpsertWithWhereUniqueWithoutTransaction_categoriesInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutTransaction_categoriesInput, transactionsUncheckedUpdateWithoutTransaction_categoriesInput>
    create: XOR<transactionsCreateWithoutTransaction_categoriesInput, transactionsUncheckedCreateWithoutTransaction_categoriesInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutTransaction_categoriesInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutTransaction_categoriesInput, transactionsUncheckedUpdateWithoutTransaction_categoriesInput>
  }

  export type transactionsUpdateManyWithWhereWithoutTransaction_categoriesInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransaction_categoriesInput>
  }

  export type paymentsCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    payment_methods?: payment_methodsCreateNestedOneWithoutPaymentsInput
    invoices: invoicesCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    payment_method_id?: string | null
  }

  export type paymentsCreateOrConnectWithoutTransactionsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutTransactionsInput, paymentsUncheckedCreateWithoutTransactionsInput>
  }

  export type paymentsCreateManyTransactionsInputEnvelope = {
    data: paymentsCreateManyTransactionsInput | paymentsCreateManyTransactionsInput[]
    skipDuplicates?: boolean
  }

  export type transaction_categoriesCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    is_active?: boolean | null
    transaction_categories?: transaction_categoriesCreateNestedOneWithoutOther_transaction_categoriesInput
    other_transaction_categories?: transaction_categoriesCreateNestedManyWithoutTransaction_categoriesInput
  }

  export type transaction_categoriesUncheckedCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    parent_id?: string | null
    is_active?: boolean | null
    other_transaction_categories?: transaction_categoriesUncheckedCreateNestedManyWithoutTransaction_categoriesInput
  }

  export type transaction_categoriesCreateOrConnectWithoutTransactionsInput = {
    where: transaction_categoriesWhereUniqueInput
    create: XOR<transaction_categoriesCreateWithoutTransactionsInput, transaction_categoriesUncheckedCreateWithoutTransactionsInput>
  }

  export type payment_methodsCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_types?: payment_typesCreateNestedOneWithoutPayment_methodsInput
    payments?: paymentsCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsUncheckedCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_type_id?: number | null
    payments?: paymentsUncheckedCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsCreateOrConnectWithoutTransactionsInput = {
    where: payment_methodsWhereUniqueInput
    create: XOR<payment_methodsCreateWithoutTransactionsInput, payment_methodsUncheckedCreateWithoutTransactionsInput>
  }

  export type transaction_typesCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    code: string
    name: string
    description?: string | null
    affects_balance: string
    is_active?: boolean | null
  }

  export type transaction_typesUncheckedCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    code: string
    name: string
    description?: string | null
    affects_balance: string
    is_active?: boolean | null
  }

  export type transaction_typesCreateOrConnectWithoutTransactionsInput = {
    where: transaction_typesWhereUniqueInput
    create: XOR<transaction_typesCreateWithoutTransactionsInput, transaction_typesUncheckedCreateWithoutTransactionsInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutTransactionsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutTransactionsInput, paymentsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<paymentsCreateWithoutTransactionsInput, paymentsUncheckedCreateWithoutTransactionsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutTransactionsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutTransactionsInput, paymentsUncheckedUpdateWithoutTransactionsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutTransactionsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type transaction_categoriesUpsertWithoutTransactionsInput = {
    update: XOR<transaction_categoriesUpdateWithoutTransactionsInput, transaction_categoriesUncheckedUpdateWithoutTransactionsInput>
    create: XOR<transaction_categoriesCreateWithoutTransactionsInput, transaction_categoriesUncheckedCreateWithoutTransactionsInput>
    where?: transaction_categoriesWhereInput
  }

  export type transaction_categoriesUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: transaction_categoriesWhereInput
    data: XOR<transaction_categoriesUpdateWithoutTransactionsInput, transaction_categoriesUncheckedUpdateWithoutTransactionsInput>
  }

  export type transaction_categoriesUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    transaction_categories?: transaction_categoriesUpdateOneWithoutOther_transaction_categoriesNestedInput
    other_transaction_categories?: transaction_categoriesUpdateManyWithoutTransaction_categoriesNestedInput
  }

  export type transaction_categoriesUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    other_transaction_categories?: transaction_categoriesUncheckedUpdateManyWithoutTransaction_categoriesNestedInput
  }

  export type payment_methodsUpsertWithoutTransactionsInput = {
    update: XOR<payment_methodsUpdateWithoutTransactionsInput, payment_methodsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<payment_methodsCreateWithoutTransactionsInput, payment_methodsUncheckedCreateWithoutTransactionsInput>
    where?: payment_methodsWhereInput
  }

  export type payment_methodsUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: payment_methodsWhereInput
    data: XOR<payment_methodsUpdateWithoutTransactionsInput, payment_methodsUncheckedUpdateWithoutTransactionsInput>
  }

  export type payment_methodsUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_types?: payment_typesUpdateOneWithoutPayment_methodsNestedInput
    payments?: paymentsUpdateManyWithoutPayment_methodsNestedInput
  }

  export type payment_methodsUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    payments?: paymentsUncheckedUpdateManyWithoutPayment_methodsNestedInput
  }

  export type transaction_typesUpsertWithoutTransactionsInput = {
    update: XOR<transaction_typesUpdateWithoutTransactionsInput, transaction_typesUncheckedUpdateWithoutTransactionsInput>
    create: XOR<transaction_typesCreateWithoutTransactionsInput, transaction_typesUncheckedCreateWithoutTransactionsInput>
    where?: transaction_typesWhereInput
  }

  export type transaction_typesUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: transaction_typesWhereInput
    data: XOR<transaction_typesUpdateWithoutTransactionsInput, transaction_typesUncheckedUpdateWithoutTransactionsInput>
  }

  export type transaction_typesUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affects_balance?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type transaction_typesUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affects_balance?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type transactionsCreateWithoutTransaction_typesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutTransactionsInput
    transaction_categories?: transaction_categoriesCreateNestedOneWithoutTransactionsInput
    payment_methods?: payment_methodsCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutTransaction_typesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    payment_method_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutTransaction_typesInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutTransaction_typesInput, transactionsUncheckedCreateWithoutTransaction_typesInput>
  }

  export type transactionsCreateManyTransaction_typesInputEnvelope = {
    data: transactionsCreateManyTransaction_typesInput | transactionsCreateManyTransaction_typesInput[]
    skipDuplicates?: boolean
  }

  export type transactionsUpsertWithWhereUniqueWithoutTransaction_typesInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutTransaction_typesInput, transactionsUncheckedUpdateWithoutTransaction_typesInput>
    create: XOR<transactionsCreateWithoutTransaction_typesInput, transactionsUncheckedCreateWithoutTransaction_typesInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutTransaction_typesInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutTransaction_typesInput, transactionsUncheckedUpdateWithoutTransaction_typesInput>
  }

  export type transactionsUpdateManyWithWhereWithoutTransaction_typesInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransaction_typesInput>
  }

  export type usersCreateWithoutReferral_sourcesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsCreateNestedManyWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersCreateNestedManyWithoutUsersInput
    packages?: packagesCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsCreateNestedManyWithoutUsersInput
    branches?: branchesCreateNestedOneWithoutUsersInput
    plans?: plansCreateNestedOneWithoutUsersInput
    type_users?: type_usersCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReferral_sourcesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    email_campaigns?: email_campaignsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedManyWithoutUsersInput
    notification_users?: notification_usersUncheckedCreateNestedManyWithoutUsersInput
    packages?: packagesUncheckedCreateNestedManyWithoutUsersInput
    saved_cards?: saved_cardsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReferral_sourcesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReferral_sourcesInput, usersUncheckedCreateWithoutReferral_sourcesInput>
  }

  export type usersCreateManyReferral_sourcesInputEnvelope = {
    data: usersCreateManyReferral_sourcesInput | usersCreateManyReferral_sourcesInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutReferral_sourcesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutReferral_sourcesInput, usersUncheckedUpdateWithoutReferral_sourcesInput>
    create: XOR<usersCreateWithoutReferral_sourcesInput, usersUncheckedCreateWithoutReferral_sourcesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutReferral_sourcesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutReferral_sourcesInput, usersUncheckedUpdateWithoutReferral_sourcesInput>
  }

  export type usersUpdateManyWithWhereWithoutReferral_sourcesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutReferral_sourcesInput>
  }

  export type activitiesCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    operator_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type gift_cardsCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string | null
    status?: string
    issue_date?: Date | string
    expiry_date?: Date | string | null
    recipient_name?: string | null
    recipient_email?: string | null
    sender_id?: string | null
    redeemed_at?: Date | string | null
    message?: string | null
    payment_method?: $Enums.payment_method_enum | null
    send_date?: Date | string | null
    design_template?: string | null
    is_reloadable?: boolean | null
    access_pin?: string | null
    usage_history?: gift_cardsCreateusage_historyInput | InputJsonValue[]
  }

  export type invoicesCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
  }

  export type operatorsCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    type_operator_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
  }

  export type packagesCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_reference?: string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    operator_id?: string | null
    position?: string | null
  }

  export type plansCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle?: string
    color?: string | null
    is_active?: boolean | null
    trial_period_days?: number | null
    setup_fee?: Decimal | DecimalJsLike | number | string | null
    max_users?: number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
  }

  export type productsCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    category_id?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
  }

  export type usersCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
  }

  export type vehiclesCreateManyBranchesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    make: string
    model: string
    year?: number | null
    license_plate: string
    status?: string
    color?: string | null
    vin?: string | null
    purchase_date?: Date | string | null
    last_maintenance_date?: Date | string | null
    mileage?: number | null
    fuel_type?: string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    operators?: operatorsUpdateOneWithoutActivitiesNestedInput
  }

  export type activitiesUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type gift_cardsUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    recipient_email?: NullableStringFieldUpdateOperationsInput | string | null
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    redeemed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableEnumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    design_template?: NullableStringFieldUpdateOperationsInput | string | null
    is_reloadable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_pin?: NullableStringFieldUpdateOperationsInput | string | null
    usage_history?: gift_cardsUpdateusage_historyInput | InputJsonValue[]
  }

  export type gift_cardsUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    recipient_email?: NullableStringFieldUpdateOperationsInput | string | null
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    redeemed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableEnumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    design_template?: NullableStringFieldUpdateOperationsInput | string | null
    is_reloadable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_pin?: NullableStringFieldUpdateOperationsInput | string | null
    usage_history?: gift_cardsUpdateusage_historyInput | InputJsonValue[]
  }

  export type gift_cardsUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    recipient_email?: NullableStringFieldUpdateOperationsInput | string | null
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    redeemed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableEnumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum | null
    send_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    design_template?: NullableStringFieldUpdateOperationsInput | string | null
    is_reloadable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_pin?: NullableStringFieldUpdateOperationsInput | string | null
    usage_history?: gift_cardsUpdateusage_historyInput | InputJsonValue[]
  }

  export type invoicesUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUpdateManyWithoutInvoicesNestedInput
    operators?: operatorsUpdateOneWithoutInvoicesNestedInput
    users?: usersUpdateOneWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type operatorsUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUpdateManyWithoutOperatorsNestedInput
    operator_types?: operator_typesUpdateOneRequiredWithoutOperatorsNestedInput
    packages?: packagesUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUncheckedUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUncheckedUpdateManyWithoutOperatorsNestedInput
    packages?: packagesUncheckedUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type_operator_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type packagesUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_packages?: invoice_packagesUpdateManyWithoutPackagesNestedInput
    users?: usersUpdateOneWithoutPackagesNestedInput
    operators?: operatorsUpdateOneWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_reference?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_reference?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plansUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUpdateManyWithoutPlansNestedInput
    plan_addresses?: plan_addressesUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUpdateManyWithoutPlansNestedInput
    users?: usersUpdateManyWithoutPlansNestedInput
  }

  export type plansUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutPlansNestedInput
    plan_addresses?: plan_addressesUncheckedUpdateManyWithoutPlansNestedInput
    plan_features?: plan_featuresUncheckedUpdateManyWithoutPlansNestedInput
    users?: usersUncheckedUpdateManyWithoutPlansNestedInput
  }

  export type plansUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_period_days?: NullableIntFieldUpdateOperationsInput | number | null
    setup_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_users?: NullableIntFieldUpdateOperationsInput | number | null
    discounts?: NullableJsonNullValueInput | InputJsonValue
  }

  export type productsUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutProductsNestedInput
    categories?: categoriesUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type usersUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehiclesUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_maintenance_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_maintenance_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUncheckedUpdateManyWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    license_plate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_maintenance_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mileage?: NullableIntFieldUpdateOperationsInput | number | null
    fuel_type?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableJsonNullValueInput | InputJsonValue
    technical_specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type productsCreateManyCategoriesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sale_price?: Decimal | DecimalJsLike | number | string | null
    sku?: string | null
    barcode?: string | null
    stock_quantity?: number | null
    is_active?: boolean | null
    status?: $Enums.product_status_enum | null
    branch_id?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsCreateimagesInput | string[]
    tags?: productsCreatetagsInput | string[]
    min_stock_alert?: number | null
    manufacturer?: string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
  }

  export type productsUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutProductsNestedInput
    branches?: branchesUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stock_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableEnumproduct_status_enumFieldUpdateOperationsInput | $Enums.product_status_enum | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: productsUpdateimagesInput | string[]
    tags?: productsUpdatetagsInput | string[]
    min_stock_alert?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type branchesCreateManyCompaniesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    postal_code?: string | null
    phone?: string | null
    email?: string | null
    is_active?: boolean | null
    prefix?: string | null
    manager_name?: string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: string | null
  }

  export type branchesUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUpdateManyWithoutBranchesNestedInput
    packages?: packagesUpdateManyWithoutBranchesNestedInput
    plans?: plansUpdateManyWithoutBranchesNestedInput
    products?: productsUpdateManyWithoutBranchesNestedInput
    users?: usersUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutBranchesNestedInput
    gift_cards?: gift_cardsUncheckedUpdateManyWithoutBranchesNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutBranchesNestedInput
    operators?: operatorsUncheckedUpdateManyWithoutBranchesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutBranchesNestedInput
    plans?: plansUncheckedUpdateManyWithoutBranchesNestedInput
    products?: productsUncheckedUpdateManyWithoutBranchesNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchesNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutBranchesNestedInput
  }

  export type branchesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours?: NullableJsonNullValueInput | InputJsonValue
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type email_campaignsCreateManyEmail_templatesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    user_id?: string | null
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsUpdateWithoutEmail_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUpdateOneWithoutEmail_campaignsNestedInput
  }

  export type email_campaignsUncheckedUpdateWithoutEmail_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsUncheckedUpdateManyWithoutEmail_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type invoice_itemsCreateManyInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    product_id?: string | null
    plan_id?: string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
  }

  export type invoice_packagesCreateManyInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_id: string
  }

  export type paymentsCreateManyInvoicesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    transaction_id?: string | null
    payment_method_id?: string | null
  }

  export type invoice_itemsUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
    plans?: plansUpdateOneWithoutInvoice_itemsNestedInput
    products?: productsUpdateOneWithoutInvoice_itemsNestedInput
  }

  export type invoice_itemsUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type invoice_itemsUncheckedUpdateManyWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type invoice_packagesUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    packages?: packagesUpdateOneRequiredWithoutInvoice_packagesNestedInput
  }

  export type invoice_packagesUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_id?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_packagesUncheckedUpdateManyWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_id?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_methods?: payment_methodsUpdateOneWithoutPaymentsNestedInput
    transactions?: transactionsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operatorsCreateManyOperator_typesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    email: string
    password: string
    first_name: string
    last_name: string
    phone?: string | null
    photo?: string | null
    role?: $Enums.operator_role_enum
    status?: $Enums.operator_status_enum
    last_login_at?: Date | string | null
    branch_id: string
    position?: string | null
    hire_date?: Date | string | null
    birth_date?: Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsCreateskillsInput | string[]
    personal_id?: string | null
    address?: string | null
  }

  export type operatorsUpdateWithoutOperator_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUpdateManyWithoutOperatorsNestedInput
    branches?: branchesUpdateOneRequiredWithoutOperatorsNestedInput
    packages?: packagesUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateWithoutOperator_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: activitiesUncheckedUpdateManyWithoutOperatorsNestedInput
    email_templates?: email_templatesUncheckedUpdateManyWithoutOperatorsNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutOperatorsNestedInput
    notifications_operator?: notifications_operatorUncheckedUpdateManyWithoutOperatorsNestedInput
    packages?: packagesUncheckedUpdateManyWithoutOperatorsNestedInput
  }

  export type operatorsUncheckedUpdateManyWithoutOperator_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumoperator_role_enumFieldUpdateOperationsInput | $Enums.operator_role_enum
    status?: Enumoperator_status_enumFieldUpdateOperationsInput | $Enums.operator_status_enum
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    hire_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergency_contact?: NullableJsonNullValueInput | InputJsonValue
    skills?: operatorsUpdateskillsInput | string[]
    personal_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type activitiesCreateManyOperatorsInput = {
    id?: string
    created_at?: Date | string
    action: string
    type: $Enums.activity_type_enum
    description?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status?: $Enums.activity_status_enum | null
    branch_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_templatesCreateManyOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject?: string | null
    body?: string | null
    html_body?: string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    category?: string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: boolean | null
    version?: number | null
  }

  export type invoicesCreateManyOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    user_id?: string | null
    branch_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
  }

  export type notifications_operatorCreateManyOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: string | null
    priority?: string | null
    action_required?: boolean | null
    action_type?: string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: Date | string | null
  }

  export type packagesCreateManyOperatorsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    user_reference?: string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    branch_id?: string | null
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    position?: string | null
  }

  export type activitiesUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    branches?: branchesUpdateOneWithoutActivitiesNestedInput
  }

  export type activitiesUncheckedUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type activitiesUncheckedUpdateManyWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    type?: Enumactivity_type_enumFieldUpdateOperationsInput | $Enums.activity_type_enum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumactivity_status_enumFieldUpdateOperationsInput | $Enums.activity_status_enum | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    old_values?: NullableJsonNullValueInput | InputJsonValue
    new_values?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_templatesUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    email_campaigns?: email_campaignsUpdateManyWithoutEmail_templatesNestedInput
  }

  export type email_templatesUncheckedUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutEmail_templatesNestedInput
  }

  export type email_templatesUncheckedUpdateManyWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    html_body?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: NullableJsonNullValueInput | InputJsonValue
    editor_settings?: NullableJsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NullableJsonNullValueInput | InputJsonValue
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    version?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invoicesUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUpdateManyWithoutInvoicesNestedInput
    branches?: branchesUpdateOneWithoutInvoicesNestedInput
    users?: usersUpdateOneWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateManyWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notifications_operatorUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    action_type?: NullableStringFieldUpdateOperationsInput | string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notifications_operatorUncheckedUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    action_type?: NullableStringFieldUpdateOperationsInput | string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notifications_operatorUncheckedUpdateManyWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    action_type?: NullableStringFieldUpdateOperationsInput | string | null
    action_data?: NullableJsonNullValueInput | InputJsonValue
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type packagesUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_packages?: invoice_packagesUpdateManyWithoutPackagesNestedInput
    branches?: branchesUpdateOneWithoutPackagesNestedInput
    users?: usersUpdateOneWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_reference?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateManyWithoutOperatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_reference?: NullableStringFieldUpdateOperationsInput | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoice_packagesCreateManyPackagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
  }

  export type invoice_packagesUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: invoicesUpdateOneRequiredWithoutInvoice_packagesNestedInput
  }

  export type invoice_packagesUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_packagesUncheckedUpdateManyWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_methodsCreateManyPayment_typesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    is_active?: boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type payment_methodsUpdateWithoutPayment_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payments?: paymentsUpdateManyWithoutPayment_methodsNestedInput
    transactions?: transactionsUpdateManyWithoutPayment_methodsNestedInput
  }

  export type payment_methodsUncheckedUpdateWithoutPayment_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
    payments?: paymentsUncheckedUpdateManyWithoutPayment_methodsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutPayment_methodsNestedInput
  }

  export type payment_methodsUncheckedUpdateManyWithoutPayment_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type invoice_itemsCreateManyPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    product_id?: string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
  }

  export type plan_addressesCreateManyPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    address_type: string
    address_line1: string
    address_line2: string
    city: string
    state: string
    country: string
    postal_code: string
    contact_name?: string | null
    contact_phone: string
    is_primary?: boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_featuresCreateManyPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    feature_name: string
    feature_value?: string | null
    is_included?: boolean | null
    limit_quantity?: number | null
    description?: string | null
  }

  export type usersCreateManyPlansInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
  }

  export type invoice_itemsUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
    invoices?: invoicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
    products?: productsUpdateOneWithoutInvoice_itemsNestedInput
  }

  export type invoice_itemsUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type invoice_itemsUncheckedUpdateManyWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type plan_addressesUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_type?: StringFieldUpdateOperationsInput | string
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_addressesUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_type?: StringFieldUpdateOperationsInput | string
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_addressesUncheckedUpdateManyWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_type?: StringFieldUpdateOperationsInput | string
    address_line1?: StringFieldUpdateOperationsInput | string
    address_line2?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    contact_phone?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    additional_info?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plan_featuresUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feature_name?: StringFieldUpdateOperationsInput | string
    feature_value?: NullableStringFieldUpdateOperationsInput | string | null
    is_included?: NullableBoolFieldUpdateOperationsInput | boolean | null
    limit_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_featuresUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feature_name?: StringFieldUpdateOperationsInput | string
    feature_value?: NullableStringFieldUpdateOperationsInput | string | null
    is_included?: NullableBoolFieldUpdateOperationsInput | boolean | null
    limit_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_featuresUncheckedUpdateManyWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feature_name?: StringFieldUpdateOperationsInput | string
    feature_value?: NullableStringFieldUpdateOperationsInput | string | null
    is_included?: NullableBoolFieldUpdateOperationsInput | boolean | null
    limit_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invoice_itemsCreateManyProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    plan_id?: string | null
    description: string
    quantity?: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    discount_rate?: Decimal | DecimalJsLike | number | string | null
    tax_rate?: Decimal | DecimalJsLike | number | string | null
    item_order?: number | null
    unit_of_measure?: string | null
    is_taxable?: boolean | null
    serial_numbers?: invoice_itemsCreateserial_numbersInput | string[]
  }

  export type invoice_itemsUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
    invoices?: invoicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
    plans?: plansUpdateOneWithoutInvoice_itemsNestedInput
  }

  export type invoice_itemsUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type invoice_itemsUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item_order?: NullableIntFieldUpdateOperationsInput | number | null
    unit_of_measure?: NullableStringFieldUpdateOperationsInput | string | null
    is_taxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    serial_numbers?: invoice_itemsUpdateserial_numbersInput | string[]
  }

  export type usersCreateManyType_usersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
    referral_source_id?: string | null
  }

  export type usersUpdateWithoutType_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    referral_sources?: referral_sourcesUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutType_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutType_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type email_campaignsCreateManyUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    name: string
    subject: string
    status?: string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: boolean | null
    tracking?: boolean | null
    tracking_id?: string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    template_id?: string | null
    scheduled_for?: Date | string | null
    sender_name?: string | null
    sender_email?: string | null
    reply_to?: string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsCreatetest_recipientsInput | string[]
    is_recurring?: boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type invoicesCreateManyUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_number: string
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.invoice_status_enum
    is_paid?: boolean | null
    total_amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    discount_amount?: Decimal | DecimalJsLike | number | string | null
    branch_id?: string | null
    operator_id?: string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    payment_terms?: string | null
    currency?: string | null
    conversion_rate?: Decimal | DecimalJsLike | number | string | null
    tracking_number?: string | null
    shipping_method?: string | null
    invoice_type?: $Enums.invoice_type_enum | null
    commission_amount?: Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: Decimal | DecimalJsLike | number | string | null
    platform?: string | null
    external_reference_id?: string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: Decimal | DecimalJsLike | number | string
    shipping_insurance?: boolean
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    remaining_amount?: Decimal | DecimalJsLike | number | string | null
    last_payment_date?: Date | string | null
  }

  export type notification_preferencesCreateManyUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    push_enabled?: boolean | null
    email_enabled?: boolean | null
    sms_enabled?: boolean | null
    news_and_updates?: boolean | null
    order_updates?: boolean | null
    promotions?: boolean | null
    security_alerts?: boolean | null
    quiet_hours_start?: Date | string | null
    quiet_hours_end?: Date | string | null
    quiet_hours_enabled?: boolean | null
    frequency?: string | null
  }

  export type notification_usersCreateManyUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    title: string
    message: string
    type: string
    is_read?: boolean | null
    is_deleted?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: string | null
    action_url?: string | null
    icon?: string | null
    expiry_date?: Date | string | null
    requires_action?: boolean | null
  }

  export type packagesCreateManyUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    package_status?: $Enums.package_status_enum
    tracking_number?: string | null
    height?: Decimal | DecimalJsLike | number | string | null
    width?: Decimal | DecimalJsLike | number | string | null
    length?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: Decimal | DecimalJsLike | number | string | null
    insurance?: boolean | null
    shipping_stages?: packagesCreateshipping_stagesInput | InputJsonValue[]
    branch_id?: string | null
    notes?: string | null
    declared_value?: Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: boolean | null
    estimated_delivery_date?: Date | string | null
    operator_id?: string | null
    position?: string | null
  }

  export type saved_cardsCreateManyUsersInput = {
    id?: number
    card_token: string
    card_type?: string | null
    cardholder_name?: string | null
    expiry_month: number
    expiry_year: number
    brand?: string | null
    last_four_digits?: string | null
    is_default?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    nick_name?: string | null
  }

  export type walletsCreateManyUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean | null
    last_transaction_date?: Date | string | null
  }

  export type email_campaignsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
    email_templates?: email_templatesUpdateOneWithoutEmail_campaignsNestedInput
  }

  export type email_campaignsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    template_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type email_campaignsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NullableJsonNullValueInput | InputJsonValue
    send_to_all?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tracking_id?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableJsonNullValueInput | InputJsonValue
    template_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender_name?: NullableStringFieldUpdateOperationsInput | string | null
    sender_email?: NullableStringFieldUpdateOperationsInput | string | null
    reply_to?: NullableStringFieldUpdateOperationsInput | string | null
    segment_criteria?: NullableJsonNullValueInput | InputJsonValue
    test_recipients?: email_campaignsUpdatetest_recipientsInput | string[]
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recurrence_pattern?: NullableJsonNullValueInput | InputJsonValue
  }

  export type invoicesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUpdateManyWithoutInvoicesNestedInput
    branches?: branchesUpdateOneWithoutInvoicesNestedInput
    operators?: operatorsUpdateOneWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_number?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    billing_address?: NullableJsonNullValueInput | InputJsonValue
    shipping_address?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_terms?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_method?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_type?: NullableEnuminvoice_type_enumFieldUpdateOperationsInput | $Enums.invoice_type_enum | null
    commission_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplace_fee_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    external_reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    tax_details?: NullableJsonNullValueInput | InputJsonValue
    price_plan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remaining_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notification_preferencesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    push_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sms_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    news_and_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    promotions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security_alerts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quiet_hours_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notification_preferencesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    push_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sms_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    news_and_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    promotions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security_alerts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quiet_hours_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notification_preferencesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    push_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sms_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    news_and_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    order_updates?: NullableBoolFieldUpdateOperationsInput | boolean | null
    promotions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    security_alerts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    quiet_hours_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiet_hours_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notification_usersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_url?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requires_action?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notification_usersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_url?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requires_action?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notification_usersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    action_url?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requires_action?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type packagesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_packages?: invoice_packagesUpdateManyWithoutPackagesNestedInput
    branches?: branchesUpdateOneWithoutPackagesNestedInput
    operators?: operatorsUpdateOneWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_packages?: invoice_packagesUncheckedUpdateManyWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    package_status?: Enumpackage_status_enumFieldUpdateOperationsInput | $Enums.package_status_enum
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    width?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volumetric_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    shipping_stages?: packagesUpdateshipping_stagesInput | InputJsonValue[]
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    declared_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    customs_information?: NullableJsonNullValueInput | InputJsonValue
    is_fragile?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estimated_delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator_id?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saved_cardsUpdateWithoutUsersInput = {
    card_token?: StringFieldUpdateOperationsInput | string
    card_type?: NullableStringFieldUpdateOperationsInput | string | null
    cardholder_name?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last_four_digits?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nick_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saved_cardsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_token?: StringFieldUpdateOperationsInput | string
    card_type?: NullableStringFieldUpdateOperationsInput | string | null
    cardholder_name?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last_four_digits?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nick_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saved_cardsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_token?: StringFieldUpdateOperationsInput | string
    card_type?: NullableStringFieldUpdateOperationsInput | string | null
    cardholder_name?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_month?: IntFieldUpdateOperationsInput | number
    expiry_year?: IntFieldUpdateOperationsInput | number
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    last_four_digits?: NullableStringFieldUpdateOperationsInput | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nick_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type walletsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type walletsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateManyPayment_methodsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    transaction_id?: string | null
  }

  export type transactionsCreateManyPayment_methodsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: string | null
    transaction_type_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type paymentsUpdateWithoutPayment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: invoicesUpdateOneRequiredWithoutPaymentsNestedInput
    transactions?: transactionsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutPayment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutPayment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionsUpdateWithoutPayment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutTransactionsNestedInput
    transaction_categories?: transaction_categoriesUpdateOneWithoutTransactionsNestedInput
    transaction_types?: transaction_typesUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutPayment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutPayment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type transaction_categoriesCreateManyTransaction_categoriesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    name: string
    description?: string | null
    is_active?: boolean | null
  }

  export type transactionsCreateManyTransaction_categoriesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    payment_method_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    transaction_type_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type transaction_categoriesUpdateWithoutTransaction_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    other_transaction_categories?: transaction_categoriesUpdateManyWithoutTransaction_categoriesNestedInput
    transactions?: transactionsUpdateManyWithoutTransaction_categoriesNestedInput
  }

  export type transaction_categoriesUncheckedUpdateWithoutTransaction_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    other_transaction_categories?: transaction_categoriesUncheckedUpdateManyWithoutTransaction_categoriesNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutTransaction_categoriesNestedInput
  }

  export type transaction_categoriesUncheckedUpdateManyWithoutTransaction_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type transactionsUpdateWithoutTransaction_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutTransactionsNestedInput
    payment_methods?: payment_methodsUpdateOneWithoutTransactionsNestedInput
    transaction_types?: transaction_typesUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutTransaction_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    transaction_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutTransaction_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    transaction_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type paymentsCreateManyTransactionsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    invoice_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: $Enums.payment_method_enum
    status?: $Enums.payment_status_enum
    payment_provider?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: string | null
    notes?: string | null
    payment_method_id?: string | null
  }

  export type paymentsUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_methods?: payment_methodsUpdateOneWithoutPaymentsNestedInput
    invoices?: invoicesUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    payment_provider?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payer_details?: NullableJsonNullValueInput | InputJsonValue
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionsCreateManyTransaction_typesInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    description?: string | null
    status?: string
    transaction_date?: Date | string | null
    transaction_type: string
    reference_id?: string | null
    entity_type?: string | null
    entity_id?: string | null
    payment_method_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type transactionsUpdateWithoutTransaction_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutTransactionsNestedInput
    transaction_categories?: transaction_categoriesUpdateOneWithoutTransactionsNestedInput
    payment_methods?: payment_methodsUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutTransaction_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutTransaction_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transaction_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_type?: StringFieldUpdateOperationsInput | string
    reference_id?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type usersCreateManyReferral_sourcesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string | null
    account_status?: boolean | null
    birth_date?: Date | string | null
    branch_id?: string | null
    email?: string | null
    first_name?: string | null
    is_email_verified?: boolean | null
    is_online?: boolean | null
    is_verified?: boolean | null
    last_name?: string | null
    last_seen?: Date | string | null
    phone?: string | null
    photo_url?: string | null
    plan_id?: string | null
    type_user_id?: string | null
    shipping_insurance?: boolean
    is_business?: boolean | null
    ruc?: string | null
    company_name?: string | null
  }

  export type usersUpdateWithoutReferral_sourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUpdateManyWithoutUsersNestedInput
    packages?: packagesUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUpdateManyWithoutUsersNestedInput
    branches?: branchesUpdateOneWithoutUsersNestedInput
    plans?: plansUpdateOneWithoutUsersNestedInput
    type_users?: type_usersUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReferral_sourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    email_campaigns?: email_campaignsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateManyWithoutUsersNestedInput
    notification_users?: notification_usersUncheckedUpdateManyWithoutUsersNestedInput
    packages?: packagesUncheckedUpdateManyWithoutUsersNestedInput
    saved_cards?: saved_cardsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutReferral_sourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_email_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    type_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_insurance?: BoolFieldUpdateOperationsInput | boolean
    is_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}